{"version":3,"sources":["index.js","../../danfojs-base/index.js","../../danfojs-base/core/generic.js","../../danfojs-base/shared/utils.js","../../danfojs-base/shared/defaults.js","../../danfojs-base/shared/config.js","../../danfojs-base/shared/errors.js","../../danfojs-base/shared/tensorflowlib.js","../../danfojs-base/core/series.js","../../danfojs-base/transformers/encoders/dummy.encoder.js","../../danfojs-base/core/frame.js","../../danfojs-base/aggregators/groupby.js","../../danfojs-base/transformers/concat.js","../../danfojs-base/core/indexing.js","../../danfojs-base/plotting/index.js","../../danfojs-base/plotting/plotly/index.js","../../danfojs-base/plotting/plotly/line.js","../../danfojs-base/plotting/plotly/utils.js","../../danfojs-base/plotting/plotly/bar.js","../../danfojs-base/plotting/plotly/scatter.js","../../danfojs-base/plotting/plotly/hist.js","../../danfojs-base/plotting/plotly/pie.js","../../danfojs-base/plotting/plotly/box.js","../../danfojs-base/plotting/plotly/violin.js","../../danfojs-base/plotting/plotly/table.js","../../danfojs-base/core/math.ops.js","../../danfojs-base/core/strings.js","../../danfojs-base/core/datetime.js","../../danfojs-base/transformers/scalers/min.max.scaler.js","../../danfojs-base/transformers/scalers/standard.scaler.js","../../danfojs-base/transformers/encoders/label.encoder.js","../../danfojs-base/transformers/encoders/one.hot.encoder.js","../../danfojs-base/transformers/merge.js","../../danfojs-base/core/daterange.js","../../danfojs-base/io/browser/index.js","../../danfojs-base/io/browser/io.csv.js","../../danfojs-base/io/browser/io.excel.js","core/frame.js","core/series.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AIZA,ADGA,ADGA,AHSA;AELA,ADGA,AIZA,ADGA,ADGA,AHSA;AELA,ADGA,AIZA,ADGA,ADGA,AHSA;AELA,ADGA,AIZA,ADGA,AENA,AHSA,AHSA;AELA,ADGA,AIZA,ADGA,AENA,AHSA,AHSA;AELA,ADGA,AIZA,ADGA,AENA,AHSA,AHSA;AELA,ADGA,AIZA,ADGA,AENA,ACHA,AJYA,AHSA;AELA,ADGA,AIZA,ADGA,AENA,ACHA,AJYA,AHSA;AELA,ADGA,AIZA,ADGA,AENA,ACHA,AJYA,AHSA;AELA,AMlBA,APqBA,AIZA,ADGA,AENA,ACHA,AJYA,AHSA;AELA,AMlBA,APqBA,AIZA,ADGA,AENA,ACHA,AJYA,AHSA;AELA,AMlBA,APqBA,AIZA,ADGA,AENA,ACHA,AJYA,AHSA;AELA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AELA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AELA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AU7BA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AU7BA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AU7BA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AWhCA,ADGA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AWhCA,ADGA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AWhCA,ADGA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AMlBA,AT2BA;AWhCA,ADGA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AMlBA,APqBA,AIZA,ADGA,AENA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AIZA,ADGA,AENA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AIZA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AIZA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AT2BA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AT2BA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AT2BA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,AV8BA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,AV8BA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,AV8BA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,ACHA,AXiCA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,ACHA,AXiCA,ACHA,AHSA,AS3BA,AHSA,AT2BA;AWhCA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,ACHA,AXiCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,ACHA,ACHA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,ACHA,ACHA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,ACHA,ACHA,ACHA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AHSA,ACHA,ACHA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AHSA,ACHA,ACHA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AHSA,ACHA,ACHA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AHSA,ACHA,AGTA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AHSA,ACHA,AGTA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AHSA,ACHA,AGTA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AENA,ALeA,ACHA,AGTA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AENA,ALeA,ACHA,AGTA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AENA,ALeA,ACHA,AGTA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AENA,ALeA,ACHA,AKfA,AFMA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AENA,ALeA,ACHA,AKfA,AFMA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AENA,ALeA,ACHA,AKfA,AFMA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AFMA,AZoCA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AFMA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AFMA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AFMA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,ALeA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,AYpCA,AjBmDA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,AYpCA,AjBmDA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,AYpCA,AjBmDA,APqBA,AavCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,ALeA,ACHA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,ADGA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,APqBA,AMlBA,AlBsDA,ACHA,AHSA,AS3BA,AHSA;AELA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AmBzDA;AjBoDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AmBzDA;AjBoDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AmBzDA;AjBoDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AmBzDA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AmBzDA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AmBzDA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,ACHA,AHSA,AS3BA,AHSA,AqB/DA,AFMA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,AFMA,AS3BA,AHSA,AqB/DA,AFMA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,AFMA,AS3BA,AHSA,AqB/DA,AFMA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,AlBsDA,AFMA,AS3BA,AHSA,AqB/DA,ACHA,AHSA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,AHSA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,AHSA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AgBhDA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AZoCA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ApB4DA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ApB4DA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ApB4DA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ArB+DA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ArB+DA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ArB+DA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA;A1B+EA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA;A1B+EA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA;A1B+EA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AKfA,ADGA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AQxBA,ACHA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AtBkEA,AIZA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,AFMA,AJYA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ANkBA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ANkBA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ANkBA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ANkBA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ANkBA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ANkBA,AKfA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AQxBA,ACHA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AS3BA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AS3BA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA,AS3BA;A3BkFA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AlBsDA,AIZA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AS3BA,AHSA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,AMlBA,AqB/DA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Ad0CA,ADGA,AFMA,AIZA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AENA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AENA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AENA,ApB4DA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,Af6CA,AlBsDA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,AYpCA,AjBmDA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,ACHA,ACHA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA,ACHA;AlBuDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA;AjBoDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA;AjBoDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA,AJYA;AjBoDA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,ACHA,AjCmGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A2BjFA,AENA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AS3BA,AhCgGA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,ANkBA,AjBmDA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,AsBlEA,AvBqEA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AWjCA,ALeA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA,A6BvFA;ArBgEA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,ARwBA,AMlBA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,AkBtDA,AvBqEA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AQvBA,ADGA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA,ALeA;AOpBA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.__version = exports.tensorflow = exports.dateRange = exports.merge = exports.concat = exports.getDummies = exports.OneHotEncoder = exports.LabelEncoder = exports.StandardScaler = exports.MinMaxScaler = exports.toExcel = exports.readExcel = exports.toJSON = exports.readJSON = exports.toCSV = exports.streamCSV = exports.readCSV = exports.DataFrame = exports.Series = exports.toDateTime = exports.Dt = exports.Str = exports.Utils = exports.Config = exports.NDframe = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar danfojs_base_1 = require(\"../../danfojs-base\");\nObject.defineProperty(exports, \"NDframe\", { enumerable: true, get: function () { return danfojs_base_1.NDframe; } });\nObject.defineProperty(exports, \"Config\", { enumerable: true, get: function () { return danfojs_base_1.Config; } });\nObject.defineProperty(exports, \"Utils\", { enumerable: true, get: function () { return danfojs_base_1.Utils; } });\nObject.defineProperty(exports, \"Str\", { enumerable: true, get: function () { return danfojs_base_1.Str; } });\nObject.defineProperty(exports, \"Dt\", { enumerable: true, get: function () { return danfojs_base_1.Dt; } });\nObject.defineProperty(exports, \"MinMaxScaler\", { enumerable: true, get: function () { return danfojs_base_1.MinMaxScaler; } });\nObject.defineProperty(exports, \"StandardScaler\", { enumerable: true, get: function () { return danfojs_base_1.StandardScaler; } });\nObject.defineProperty(exports, \"LabelEncoder\", { enumerable: true, get: function () { return danfojs_base_1.LabelEncoder; } });\nObject.defineProperty(exports, \"OneHotEncoder\", { enumerable: true, get: function () { return danfojs_base_1.OneHotEncoder; } });\nObject.defineProperty(exports, \"getDummies\", { enumerable: true, get: function () { return danfojs_base_1.getDummies; } });\nObject.defineProperty(exports, \"concat\", { enumerable: true, get: function () { return danfojs_base_1.concat; } });\nObject.defineProperty(exports, \"merge\", { enumerable: true, get: function () { return danfojs_base_1.merge; } });\nObject.defineProperty(exports, \"toDateTime\", { enumerable: true, get: function () { return danfojs_base_1.toDateTime; } });\nObject.defineProperty(exports, \"dateRange\", { enumerable: true, get: function () { return danfojs_base_1.dateRange; } });\nObject.defineProperty(exports, \"tensorflow\", { enumerable: true, get: function () { return danfojs_base_1.tensorflow; } });\nObject.defineProperty(exports, \"__version\", { enumerable: true, get: function () { return danfojs_base_1.__version; } });\nvar browser_1 = require(\"../../danfojs-base/io/browser\");\nObject.defineProperty(exports, \"readCSV\", { enumerable: true, get: function () { return browser_1.readCSVBrowser; } });\nObject.defineProperty(exports, \"streamCSV\", { enumerable: true, get: function () { return browser_1.streamCSVBrowser; } });\nObject.defineProperty(exports, \"toCSV\", { enumerable: true, get: function () { return browser_1.toCSVBrowser; } });\nObject.defineProperty(exports, \"readJSON\", { enumerable: true, get: function () { return browser_1.readJSONBrowser; } });\nObject.defineProperty(exports, \"toJSON\", { enumerable: true, get: function () { return browser_1.toJSONBrowser; } });\nObject.defineProperty(exports, \"readExcel\", { enumerable: true, get: function () { return browser_1.readExcelBrowser; } });\nObject.defineProperty(exports, \"toExcel\", { enumerable: true, get: function () { return browser_1.toExcelBrowser; } });\nvar frame_1 = __importDefault(require(\"./core/frame\"));\nexports.DataFrame = frame_1.default;\nvar series_1 = __importDefault(require(\"./core/series\"));\nexports.Series = series_1.default;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.__version = exports.tensorflow = exports.dateRange = exports.merge = exports.concat = exports.getDummies = exports.OneHotEncoder = exports.LabelEncoder = exports.StandardScaler = exports.MinMaxScaler = exports.DataFrame = exports.Series = exports.toDateTime = exports.Dt = exports.Str = exports.Utils = exports.Config = exports.NDframe = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar generic_1 = __importDefault(require(\"./core/generic\"));\nexports.NDframe = generic_1.default;\nvar config_1 = __importDefault(require(\"./shared/config\"));\nexports.Config = config_1.default;\nvar utils_1 = __importDefault(require(\"./shared/utils\"));\nexports.Utils = utils_1.default;\nvar series_1 = __importDefault(require(\"./core/series\"));\nexports.Series = series_1.default;\nvar frame_1 = __importDefault(require(\"./core/frame\"));\nexports.DataFrame = frame_1.default;\nvar strings_1 = __importDefault(require(\"./core/strings\"));\nexports.Str = strings_1.default;\nvar datetime_1 = __importStar(require(\"./core/datetime\"));\nexports.Dt = datetime_1.default;\nObject.defineProperty(exports, \"toDateTime\", { enumerable: true, get: function () { return datetime_1.toDateTime; } });\nvar min_max_scaler_1 = __importDefault(require(\"./transformers/scalers/min.max.scaler\"));\nexports.MinMaxScaler = min_max_scaler_1.default;\nvar standard_scaler_1 = __importDefault(require(\"./transformers/scalers/standard.scaler\"));\nexports.StandardScaler = standard_scaler_1.default;\nvar label_encoder_1 = __importDefault(require(\"./transformers/encoders/label.encoder\"));\nexports.LabelEncoder = label_encoder_1.default;\nvar one_hot_encoder_1 = __importDefault(require(\"./transformers/encoders/one.hot.encoder\"));\nexports.OneHotEncoder = one_hot_encoder_1.default;\nvar dummy_encoder_1 = __importDefault(require(\"./transformers/encoders/dummy.encoder\"));\nexports.getDummies = dummy_encoder_1.default;\nvar concat_1 = __importDefault(require(\"./transformers/concat\"));\nexports.concat = concat_1.default;\nvar merge_1 = __importDefault(require(\"./transformers/merge\"));\nexports.merge = merge_1.default;\nvar daterange_1 = __importDefault(require(\"./core/daterange\"));\nexports.dateRange = daterange_1.default;\nvar tensorflowlib_1 = __importDefault(require(\"./shared/tensorflowlib\"));\nexports.tensorflow = tensorflowlib_1.default;\nvar __version = \"1.1.2\";\nexports.__version = __version;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar config_1 = __importDefault(require(\"../shared/config\"));\nvar errors_1 = __importDefault(require(\"../shared/errors\"));\nvar defaults_1 = require(\"../shared/defaults\");\nvar tensorflowlib_1 = __importDefault(require(\"../shared/tensorflowlib\"));\nvar utils = new utils_1.default();\n/**\n * N-Dimension data structure. Stores multi-dimensional\n * data in a size-mutable, labeled data structure. Analogous to the Python Pandas DataFrame.\n *\n * @param  Object\n *\n *  data:  1D or 2D Array, JSON, Tensor, Block of data.\n *\n *  index: Array of numeric or string names for subseting array. If not specified, indexes are auto generated.\n *\n *  columns: Array of column names. If not specified, column names are auto generated.\n *\n *  dtypes: Array of data types for each the column. If not specified, dtypes inferred.\n *\n *  config: General configuration object for NDframe\n *\n * @returns NDframe\n */\nvar NDframe = /** @class */ (function () {\n    function NDframe(_a) {\n        var data = _a.data, index = _a.index, columns = _a.columns, dtypes = _a.dtypes, config = _a.config, isSeries = _a.isSeries;\n        this.$dataIncolumnFormat = [];\n        this.$index = [];\n        this.$columns = [];\n        this.$dtypes = [];\n        this.$isSeries = isSeries;\n        if (config) {\n            this.$config = new config_1.default(__assign(__assign({}, defaults_1.BASE_CONFIG), config));\n        }\n        else {\n            this.$config = new config_1.default(defaults_1.BASE_CONFIG);\n        }\n        if (data instanceof tensorflowlib_1.default.Tensor) {\n            data = data.arraySync();\n        }\n        if (data === undefined || (Array.isArray(data) && data.length === 0)) {\n            if (columns === undefined)\n                columns = [];\n            if (dtypes === undefined)\n                dtypes = [];\n            if (columns.length === 0 && dtypes.length !== 0)\n                errors_1.default.throwDtypeWithoutColumnError();\n            this.loadArrayIntoNdframe({ data: [], index: [], columns: columns, dtypes: dtypes });\n        }\n        else if (utils.is1DArray(data)) {\n            this.loadArrayIntoNdframe({ data: data, index: index, columns: columns, dtypes: dtypes });\n        }\n        else {\n            if (Array.isArray(data) && utils.isObject(data[0])) {\n                this.loadObjectIntoNdframe({ data: data, type: 1, index: index, columns: columns, dtypes: dtypes });\n            }\n            else if (utils.isObject(data)) {\n                this.loadObjectIntoNdframe({ data: data, type: 2, index: index, columns: columns, dtypes: dtypes });\n            }\n            else if (Array.isArray((data)[0]) ||\n                utils.isNumber((data)[0]) ||\n                utils.isString((data)[0])) {\n                this.loadArrayIntoNdframe({ data: data, index: index, columns: columns, dtypes: dtypes });\n            }\n            else if (Array.isArray(data) && data.length > 0 && utils.isDate(data[0])) {\n                this.loadArrayIntoNdframe({ data: data, index: index, columns: columns, dtypes: dtypes });\n            }\n            else {\n                throw new Error(\"File format not supported!\");\n            }\n        }\n    }\n    /**\n     * Internal function to load array of data into NDFrame\n     * @param data The array of data to load into NDFrame\n     * @param index Array of numeric or string names for subsetting array.\n     * @param columns Array of column names.\n     * @param dtypes Array of data types for each the column.\n    */\n    NDframe.prototype.loadArrayIntoNdframe = function (_a) {\n        var data = _a.data, index = _a.index, columns = _a.columns, dtypes = _a.dtypes;\n        // this.$data = utils.replaceUndefinedWithNaN(data, this.$isSeries);\n        this.$data = data;\n        if (!this.$config.isLowMemoryMode) {\n            //In NOT low memory mode, we transpose the array and save in column format.\n            //This makes column data retrieval run in constant time\n            this.$dataIncolumnFormat = utils.transposeArray(data);\n        }\n        this.$setIndex(index);\n        this.$setDtypes(dtypes);\n        this.$setColumnNames(columns);\n    };\n    /**\n     * Internal function to format and load a Javascript object or object of arrays into NDFrame.\n     * @param data Object or object of arrays.\n     * @param type The type of the object. There are two recognized types:\n     *\n     * - type 1 object are in JSON format `[{a: 1, b: 2}, {a: 30, b: 20}]`.\n     *\n     * - type 2 object are of the form `{a: [1,2,3,4], b: [30,20, 30, 20}]}`\n     * @param index Array of numeric or string names for subsetting array.\n     * @param columns Array of column names.\n     * @param dtypes Array of data types for each the column.\n    */\n    NDframe.prototype.loadObjectIntoNdframe = function (_a) {\n        var data = _a.data, type = _a.type, index = _a.index, columns = _a.columns, dtypes = _a.dtypes;\n        if (type === 1 && Array.isArray(data)) {\n            var _data = (data).map(function (item) {\n                return Object.values(item);\n            });\n            var _columnNames = void 0;\n            if (columns) {\n                _columnNames = columns;\n            }\n            else {\n                _columnNames = Object.keys((data)[0]);\n            }\n            this.loadArrayIntoNdframe({ data: _data, index: index, columns: _columnNames, dtypes: dtypes });\n        }\n        else {\n            var _b = utils.getRowAndColValues(data), _data = _b[0], _colNames = _b[1];\n            var _columnNames = void 0;\n            if (columns) {\n                _columnNames = columns;\n            }\n            else {\n                _columnNames = _colNames;\n            }\n            this.loadArrayIntoNdframe({ data: _data, index: index, columns: _columnNames, dtypes: dtypes });\n        }\n    };\n    Object.defineProperty(NDframe.prototype, \"tensor\", {\n        /**\n         * Converts and returns the data in the NDframe as a Tensorflow.js Tensor.\n        */\n        get: function () {\n            if (this.$isSeries) {\n                return tensorflowlib_1.default.tensor1d(this.$data, this.$dtypes[0]);\n            }\n            else {\n                return tensorflowlib_1.default.tensor2d(this.$data, this.shape, \"float32\");\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NDframe.prototype, \"dtypes\", {\n        /**\n         * Returns the dtypes of the columns\n        */\n        get: function () {\n            return this.$dtypes;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Internal function to set the Dtypes of the NDFrame from an array. This function\n     * performs the necessary checks.\n    */\n    NDframe.prototype.$setDtypes = function (dtypes) {\n        if (this.$isSeries) {\n            if (dtypes) {\n                if (this.$data.length != 0 && dtypes.length != 1) {\n                    errors_1.default.throwDtypesLengthError(this, dtypes);\n                }\n                if (!(defaults_1.DATA_TYPES.includes(\"\" + dtypes[0]))) {\n                    errors_1.default.throwDtypeNotSupportedError(dtypes[0]);\n                }\n                this.$dtypes = dtypes;\n            }\n            else {\n                this.$dtypes = utils.inferDtype(this.$data);\n            }\n        }\n        else {\n            if (dtypes) {\n                if (this.$data.length != 0 && dtypes.length != this.shape[1]) {\n                    errors_1.default.throwDtypesLengthError(this, dtypes);\n                }\n                if (this.$data.length == 0 && dtypes.length == 0) {\n                    this.$dtypes = dtypes;\n                }\n                else {\n                    dtypes.forEach(function (dtype) {\n                        if (!(defaults_1.DATA_TYPES.includes(dtype))) {\n                            errors_1.default.throwDtypeNotSupportedError(dtype);\n                        }\n                    });\n                    this.$dtypes = dtypes;\n                }\n            }\n            else {\n                this.$dtypes = utils.inferDtype(this.$data);\n            }\n        }\n    };\n    Object.defineProperty(NDframe.prototype, \"ndim\", {\n        /**\n         * Returns the dimension of the data. Series have a dimension of 1,\n         * while DataFrames have a dimension of 2.\n        */\n        get: function () {\n            if (this.$isSeries) {\n                return 1;\n            }\n            else {\n                return 2;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NDframe.prototype, \"axis\", {\n        /**\n         * Returns the axis labels of the NDFrame.\n        */\n        get: function () {\n            return {\n                index: this.$index,\n                columns: this.$columns\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NDframe.prototype, \"config\", {\n        /**\n         * Returns the configuration object of the NDFrame.\n        */\n        get: function () {\n            return this.$config;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Internal function to set the configuration of the ndframe\n    */\n    NDframe.prototype.$setConfig = function (config) {\n        this.$config = config;\n    };\n    Object.defineProperty(NDframe.prototype, \"index\", {\n        /**\n         * Returns the indices of the NDFrame\n        */\n        get: function () {\n            return this.$index;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Internal function to set the index of the NDFrame with the specified\n     * array of indices. Performs all necessary checks to ensure that the\n     * index is valid.\n    */\n    NDframe.prototype.$setIndex = function (index) {\n        if (index) {\n            if (this.$data.length != 0 && index.length != this.shape[0]) {\n                errors_1.default.throwIndexLengthError(this, index);\n            }\n            if (Array.from(new Set(index)).length !== this.shape[0]) {\n                errors_1.default.throwIndexDuplicateError();\n            }\n            this.$index = index;\n        }\n        else {\n            this.$index = utils.range(0, this.shape[0] - 1); //generate index\n        }\n    };\n    /**\n     * Internal function to reset the index of the NDFrame using a range of indices.\n    */\n    NDframe.prototype.$resetIndex = function () {\n        this.$index = utils.range(0, this.shape[0] - 1);\n    };\n    Object.defineProperty(NDframe.prototype, \"columns\", {\n        /**\n         * Returns the column names of the NDFrame\n        */\n        get: function () {\n            return this.$columns;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Internal function to set the column names for the NDFrame. This function\n     * performs a check to ensure that the column names are unique, and same length as the\n     * number of columns in the data.\n    */\n    NDframe.prototype.$setColumnNames = function (columns) {\n        // console.log(columns);\n        if (this.$isSeries) {\n            if (columns) {\n                if (this.$data.length != 0 && columns.length != 1 && typeof columns != 'string') {\n                    errors_1.default.throwColumnNamesLengthError(this, columns);\n                }\n                this.$columns = columns;\n            }\n            else {\n                this.$columns = [\"0\"];\n            }\n        }\n        else {\n            if (columns) {\n                if (this.$data.length != 0 && columns.length != this.shape[1]) {\n                    errors_1.default.throwColumnNamesLengthError(this, columns);\n                }\n                if (Array.from(new Set(columns)).length !== columns.length) {\n                    errors_1.default.throwColumnDuplicateError();\n                }\n                this.$columns = columns;\n            }\n            else {\n                this.$columns = (utils.range(0, this.shape[1] - 1)).map(function (val) { return \"\" + val; }); //generate columns\n            }\n        }\n    };\n    Object.defineProperty(NDframe.prototype, \"shape\", {\n        /**\n         * Returns the shape of the NDFrame. Shape is determined by [row length, column length]\n        */\n        get: function () {\n            if (this.$data.length === 0) {\n                if (this.$columns.length === 0)\n                    return [0, 0];\n                else\n                    return [0, this.$columns.length];\n            }\n            if (this.$isSeries) {\n                return [this.$data.length, 1];\n            }\n            else {\n                var rowLen = (this.$data).length;\n                var colLen = this.$data[0].length;\n                return [rowLen, colLen];\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NDframe.prototype, \"values\", {\n        /**\n         * Returns the underlying data in Array format.\n        */\n        get: function () {\n            return this.$data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Updates the internal $data property to the specified value\n     * @param values An array of values to set\n     * @param checkLength Whether to check the length of the new values and the existing row length\n     * @param checkColumnLength Whether to check the length of the new values and the existing column length\n     * */\n    NDframe.prototype.$setValues = function (values, checkLength, checkColumnLength) {\n        var _this = this;\n        if (checkLength === void 0) { checkLength = true; }\n        if (checkColumnLength === void 0) { checkColumnLength = true; }\n        if (this.$isSeries) {\n            if (checkLength && values.length != this.shape[0]) {\n                errors_1.default.throwRowLengthError(this, values.length);\n            }\n            this.$data = values;\n            this.$dtypes = utils.inferDtype(values); //Dtype may change depeneding on the value set\n            if (!this.$config.isLowMemoryMode) {\n                this.$dataIncolumnFormat = values;\n            }\n        }\n        else {\n            if (checkLength && values.length != this.shape[0]) {\n                errors_1.default.throwRowLengthError(this, values.length);\n            }\n            if (checkColumnLength) {\n                values.forEach(function (value) {\n                    if (value.length != _this.shape[1]) {\n                        errors_1.default.throwColumnLengthError(_this, values.length);\n                    }\n                });\n            }\n            this.$data = values;\n            this.$dtypes = utils.inferDtype(values);\n            if (!this.$config.isLowMemoryMode) {\n                this.$dataIncolumnFormat = utils.transposeArray(values);\n            }\n        }\n    };\n    Object.defineProperty(NDframe.prototype, \"getColumnData\", {\n        /**\n          * Returns the underlying data in Array column format.\n          * Similar to this.values, but in column format.\n        */\n        get: function () {\n            if (this.config.isLowMemoryMode) {\n                return utils.transposeArray(this.values);\n            }\n            else {\n                return this.$dataIncolumnFormat;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NDframe.prototype, \"size\", {\n        /**\n         * Returns the size of the NDFrame object\n         *\n        */\n        get: function () {\n            return this.shape[0] * this.shape[1];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Converts a DataFrame or Series to CSV.\n     * @deprecated Use `toCSV` function directly instead.\n    * @example\n    * ```\n    * import * as dfd from \"danfojs\"\n    * const df = new dfd.DataFrame([[1, 2, 3], [4, 5, 6]])\n    * const csv = dfd.toCSV(df)\n    * ```\n    * @example\n    * ```\n    * import { toCSV } from \"danfojs-node\"\n    * const df = new DataFrame([[1, 2, 3], [4, 5, 6]])\n    * toCSV(df, {\n    *     filePath: \"./data/sample.csv\",\n    *     header: true,\n    *     sep: \"+\"\n    *   })\n     */\n    NDframe.prototype.toCSV = function (options) {\n        throw new Error(\"`toCSV` function is deprecated. Use `toCSV` function directly instead. e.g. `dfd.toCSV(df)`\");\n    };\n    /**\n     * Converts a DataFrame or Series to JSON.\n     * @deprecated Use `toJSON` function directly instead.\n    * @example\n    * ```\n    * import * as dfd from \"danfojs-node\"\n    * const df = new dfd.DataFrame([[1, 2, 3], [4, 5, 6]])\n    * const json = dfd.toJSON(df)\n    * ```\n    * @example\n    * ```\n    * import { toJSON } from \"danfojs-node\"\n    * const df = new DataFrame([[1, 2, 3], [4, 5, 6]])\n    * toJSON(df, {\n    *     filePath: \"./data/sample.json\",\n    *     format: \"row\"\n    *   })\n    * ```\n    */\n    NDframe.prototype.toJSON = function (options) {\n        throw new Error(\"`toJSON` function is deprecated. Use `toJSON` function directly instead. e.g. `dfd.toJSON(df, { format: 'row' })`\");\n    };\n    /**\n     * Converts a DataFrame or Series to Excel.\n     * @deprecated Use `toExcel` function directly instead.\n     * @example\n     * ```\n     * import * as dfd from \"danfojs\"\n     * const df = new dfd.DataFrame([[1, 2, 3], [4, 5, 6]])\n     * dfd.toExcel(df, {\n     *     filePath: \"./data/sample.xlsx\",\n     *     sheetName: \"MySheet\",\n     *   })\n     * ```\n     *\n     * @example\n     * ```\n     * import { toExcel } from \"danfojs-node\"\n     * const df = new DataFrame([[1, 2, 3], [4, 5, 6]])\n     * toExcel(df, {\n     *     filePath: \"./data/sample.xlsx\",\n     *     sheetName: \"MySheet\",\n     *   })\n     * ```\n     */\n    NDframe.prototype.toExcel = function (options) {\n        throw new Error(\"Deprecated. Use `toExcel` function directly instead. e.g. `dfd.toExcel(df, {filePath: 'path/to/file.xlsx'})`\");\n    };\n    /**\n     * Pretty prints a DataFrame or Series to the console\n     */\n    NDframe.prototype.print = function () {\n        console.log(this + \"\");\n    };\n    return NDframe;\n}());\nexports.default = NDframe;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar defaults_1 = require(\"./defaults\");\nvar config_1 = __importDefault(require(\"./config\"));\nvar __1 = require(\"../\");\nvar __2 = require(\"../\");\nvar errors_1 = __importDefault(require(\"../shared/errors\"));\nvar config = new config_1.default(defaults_1.BASE_CONFIG);\n/**\n * General Utility class\n */\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    /**\n     * Removes an element from a 1D array\n     *\n     * ```js\n     *\n     * ```\n     * @param arr The array to filter.\n     * @param index The index to filter by.\n     */\n    Utils.prototype.removeElementFromArray = function (arr, index) {\n        var newArr = arr.filter(function (_, i) { return i != index; });\n        return newArr;\n    };\n    /**\n     * Check if value is a string.\n     * @param value The value to check.\n     * @returns\n     */\n    Utils.prototype.isString = function (value) {\n        return typeof value === \"string\";\n    };\n    /**\n     * Checks if value is a number.\n     * @param value The value to check.\n     * @returns\n     */\n    Utils.prototype.isNumber = function (value) {\n        return typeof value === \"number\" && isFinite(value);\n    };\n    /**\n     * Checks if value is an object.\n     * @param value The value to check.\n     * @returns\n     */\n    Utils.prototype.isObject = function (value) {\n        return value && typeof value === \"object\" && value.constructor && value.constructor.name === \"Object\";\n    };\n    /**\n     * Checks if a value is null\n     * @param value The value to check.\n     * @returns\n     */\n    Utils.prototype.isNull = function (value) {\n        return value === null;\n    };\n    /**\n     * Checks if a value is undefined\n     * @param value The value to check.\n     * @returns\n     */\n    Utils.prototype.isUndefined = function (value) {\n        return typeof value === \"undefined\";\n    };\n    /**\n     * Checks if a value is empty. Empty means it's either null, undefined or NaN\n     * @param value The value to check.\n     * @returns\n     */\n    Utils.prototype.isEmpty = function (value) {\n        return value === undefined || value === null || (isNaN(value) && typeof value !== \"string\");\n    };\n    /**\n     * Checks if a value is a date object\n     * @param value A date object\n     * @returns boolean\n     */\n    Utils.prototype.isDate = function (value) {\n        return value instanceof Date;\n    };\n    /**\n     * Generates an array of integers between specified range\n     * @param start The starting number.\n     * @param end The ending number.\n     */\n    Utils.prototype.range = function (start, end) {\n        if (end < start) {\n            throw new Error(\"ParamError: end must be greater than start\");\n        }\n        if (start === end) {\n            return [start];\n        }\n        var arr = [];\n        for (var i = start; i <= end; i++) {\n            arr.push(i);\n        }\n        return arr;\n    };\n    /**\n     * Checks if object has the specified key\n     * @param obj The object to check.\n     * @param key The key to find.\n     */\n    Utils.prototype.keyInObject = function (obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n    };\n    /**\n     * Transposes an array of array\n     * @param obj The object to check.\n     * @param key The key to find.\n     */\n    Utils.prototype.transposeArray = function (arr) {\n        if (arr.length === 0)\n            return arr;\n        var rowLen = arr.length;\n        if (Array.isArray(arr[0])) {\n            var colLen = arr[0].length;\n            var newArr = [];\n            for (var i = 0; i <= colLen - 1; i++) {\n                var temp = [];\n                for (var j = 0; j < rowLen; j++) {\n                    var _elem = arr[j][i];\n                    temp.push(_elem);\n                }\n                newArr.push(temp);\n            }\n            return newArr;\n        }\n        else {\n            return arr;\n        }\n    };\n    /**\n     * Retrieve row array and column names from an object of the form {a: [1,2,3,4], b: [30,20, 30, 20]}\n     * @param obj The object to retrieve rows and column names from.\n     */\n    Utils.prototype.getRowAndColValues = function (obj) {\n        var colNames = Object.keys(obj);\n        var colData = Object.values(obj);\n        var firstColLen = colData[0].length;\n        colData.forEach(function (cdata) {\n            if (cdata.length != firstColLen) {\n                throw Error(\"Length Error: Length of columns must be the same!\");\n            }\n        });\n        var rowsArr = this.transposeArray(colData);\n        return [rowsArr, colNames];\n    };\n    /**\n     * Converts a 2D array of array to 1D array for Series Class\n     * @param arr The array to convert.\n     */\n    Utils.prototype.convert2DArrayToSeriesArray = function (arr) {\n        var _this = this;\n        var newArr = arr.map(function (val) {\n            if (_this.isObject(val)) {\n                return JSON.stringify(val);\n            }\n            else {\n                return \"\" + val;\n            }\n        });\n        return newArr;\n    };\n    /**\n     * Replaces all missing values with NaN. Missing values are undefined, Null and Infinity\n     * @param arr The array\n     * @param isSeries Whether the arr is a series or not\n     */\n    Utils.prototype.replaceUndefinedWithNaN = function (arr, isSeries) {\n        if (arr.length === 0)\n            return arr;\n        if (isSeries && Array.isArray(arr)) {\n            var newArr = arr.map(function (ele) {\n                if (typeof ele === \"undefined\") {\n                    return NaN;\n                }\n                if (typeof ele === \"number\" && (isNaN(ele) || ele == Infinity)) {\n                    return NaN;\n                }\n                if (ele == null) {\n                    return NaN;\n                }\n                return ele;\n            });\n            return newArr;\n        }\n        else {\n            var newArr = [];\n            if (Array.isArray(arr)) {\n                for (var i = 0; i < arr.length; i++) {\n                    var innerArr = arr[i];\n                    var temp = innerArr.map(function (ele) {\n                        if (typeof ele === \"undefined\") {\n                            return NaN;\n                        }\n                        if (typeof ele === \"number\" && (isNaN(ele) || ele == Infinity)) {\n                            return NaN;\n                        }\n                        if (ele == null) {\n                            return NaN;\n                        }\n                        return ele;\n                    });\n                    newArr.push(temp);\n                }\n            }\n            return newArr;\n        }\n    };\n    /**\n     * Infer data type from an array or array of arrays\n     * @param arr An array or array of arrays\n    */\n    Utils.prototype.inferDtype = function (arr) {\n        var self = this;\n        if (this.is1DArray(arr)) {\n            return [this.$typeChecker(arr)];\n        }\n        else {\n            var arrSlice = this.transposeArray(arr.slice(0, config.getDtypeTestLim));\n            var dtypes = arrSlice.map(function (innerArr) {\n                return self.$typeChecker(innerArr);\n            });\n            return dtypes;\n        }\n    };\n    /**\n     * Private type checker used by inferDtype function\n     * @param arr The array\n     */\n    Utils.prototype.$typeChecker = function (arr) {\n        var dtypes;\n        var lim;\n        var intTracker = [];\n        var floatTracker = [];\n        var stringTracker = [];\n        var boolTracker = [];\n        var dateTracker = [];\n        if (arr.length < config.getDtypeTestLim) {\n            lim = arr.length;\n        }\n        else {\n            lim = config.getDtypeTestLim;\n        }\n        var arrSlice = arr.slice(0, lim);\n        for (var i = 0; i < lim; i++) {\n            var ele = arrSlice[i];\n            if (typeof ele == \"boolean\") {\n                floatTracker.push(false);\n                intTracker.push(false);\n                stringTracker.push(false);\n                boolTracker.push(true);\n                dateTracker.push(false);\n            }\n            else if (this.isEmpty(ele)) {\n                floatTracker.push(true);\n                intTracker.push(false);\n                stringTracker.push(false);\n                boolTracker.push(false);\n                dateTracker.push(false);\n            }\n            else if (this.isDate(ele)) {\n                floatTracker.push(false);\n                intTracker.push(false);\n                stringTracker.push(false);\n                boolTracker.push(false);\n                dateTracker.push(true);\n            }\n            else if (!isNaN(Number(ele))) {\n                if (ele.toString().includes(\".\")) {\n                    floatTracker.push(true);\n                    intTracker.push(false);\n                    stringTracker.push(false);\n                    boolTracker.push(false);\n                    dateTracker.push(false);\n                }\n                else {\n                    floatTracker.push(false);\n                    intTracker.push(true);\n                    stringTracker.push(false);\n                    boolTracker.push(false);\n                    dateTracker.push(false);\n                }\n            }\n            else {\n                floatTracker.push(false);\n                intTracker.push(false);\n                stringTracker.push(true);\n                boolTracker.push(false);\n                dateTracker.push(false);\n            }\n        }\n        var even = function (ele) { return ele == true; };\n        if (stringTracker.some(even)) {\n            dtypes = \"string\";\n        }\n        else if (floatTracker.some(even)) {\n            dtypes = \"float32\";\n        }\n        else if (intTracker.some(even)) {\n            dtypes = \"int32\";\n        }\n        else if (boolTracker.some(even)) {\n            dtypes = \"boolean\";\n        }\n        else if (dateTracker.some(even)) {\n            dtypes = \"datetime\";\n        }\n        else {\n            dtypes = \"undefined\";\n        }\n        return dtypes;\n    };\n    /**\n     * Returns the unique values in an 1D array\n     * @param arr The array\n    */\n    Utils.prototype.unique = function (arr) {\n        var uniqueArr = new Set(arr);\n        return Array.from(uniqueArr);\n    };\n    /**\n     * Checks if array is 1D\n     * @param arr The array\n    */\n    Utils.prototype.is1DArray = function (arr) {\n        if (typeof arr[0] == \"number\" ||\n            typeof arr[0] == \"string\" ||\n            typeof arr[0] == \"boolean\" ||\n            arr[0] === null) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Converts an array to an object using array index as object keys\n     * @param arr The array\n    */\n    Utils.prototype.convertArrayToObject = function (arr) {\n        var arrObj = {};\n        for (var i = 0; i < arr.length; i++) {\n            arrObj[i] = arr[i];\n        }\n        return arrObj;\n    };\n    /**\n     * Count the NaN and non-NaN values present in an array\n     * @param  arr Array object\n     * @param val whether to return the value count instead of the null count\n     * @param isSeries Whether the array is of type series or not\n     */\n    Utils.prototype.countNaNs = function (arr, returnVal, isSeries) {\n        if (returnVal === void 0) { returnVal = true; }\n        if (isSeries) {\n            var nullCount = 0;\n            var valCount = 0;\n            for (var i = 0; i < arr.length; i++) {\n                var ele = arr[i];\n                if (Number.isNaN(ele)) {\n                    nullCount = nullCount + 1;\n                }\n                else {\n                    valCount = valCount + 1;\n                }\n            }\n            if (returnVal) {\n                return valCount;\n            }\n            else {\n                return nullCount;\n            }\n        }\n        else {\n            var resultArr = [];\n            for (var i = 0; i < arr.length; i++) {\n                var innerArr = arr[i];\n                var nullCount = 0;\n                var valCount = 0;\n                for (var i_1 = 0; i_1 < innerArr.length; i_1++) {\n                    var ele = innerArr[i_1];\n                    if (Number.isNaN(ele)) {\n                        nullCount = nullCount + 1;\n                    }\n                    else {\n                        valCount = valCount + 1;\n                    }\n                }\n                if (returnVal) {\n                    resultArr.push(valCount);\n                }\n                else {\n                    resultArr.push(nullCount);\n                }\n            }\n            return resultArr;\n        }\n    };\n    /**\n     * Round elements of an array or array of arrays to specified dp\n     * @param arr The Array to round\n     * @param dp The number of dp to round to\n     * @param isSeries Whether the array is of type Series or not\n     */\n    Utils.prototype.round = function (arr, dp, isSeries) {\n        if (dp === void 0) { dp = 1; }\n        if (dp < 0) {\n            dp = 1;\n        }\n        if (isSeries) {\n            var newArr = [];\n            for (var i = 0; i < arr.length; i++) {\n                var ele = arr[i];\n                if (typeof ele == \"number\" && !isNaN(ele) && ele !== undefined && ele !== null) {\n                    newArr.push(Number((ele).toFixed(dp)));\n                }\n                else {\n                    newArr.push(ele);\n                }\n            }\n            return newArr;\n        }\n        else {\n            var resultArr = [];\n            for (var i = 0; i < arr.length; i++) {\n                var innerVal = arr[i];\n                var newArr = [];\n                if (Array.isArray(innerVal)) {\n                    for (var i_2 = 0; i_2 < innerVal.length; i_2++) {\n                        var ele = innerVal[i_2];\n                        if (typeof ele == \"number\" && !isNaN(ele) && ele !== undefined && ele !== null) {\n                            newArr.push(Number((ele).toFixed(dp)));\n                        }\n                        else {\n                            newArr.push(ele);\n                        }\n                    }\n                    resultArr.push(newArr);\n                }\n                else {\n                    if (typeof innerVal == \"number\" && !isNaN(innerVal) && innerVal !== undefined && innerVal !== null) {\n                        newArr.push(Number((innerVal).toFixed(dp)));\n                    }\n                    else {\n                        newArr.push(innerVal);\n                    }\n                }\n            }\n            return resultArr;\n        }\n    };\n    /**\n     * Checks if a func is a function\n     * @param func\n     */\n    Utils.prototype.isFunction = function (func) {\n        return typeof func == \"function\";\n    };\n    /**\n     * Generates n random numbers between start and end.\n     * @param start\n     * @param end\n     * @param size\n     */\n    Utils.prototype.randNumberGenerator = function (start, end, size) {\n        var genNum = [];\n        function randi(a, b) {\n            return Math.floor(Math.random() * (b - a) + a);\n        }\n        function recursive(val, arr) {\n            if (!arr.includes(val)) {\n                return val;\n            }\n            val = randi(start, end);\n            recursive(val, arr);\n        }\n        for (var i = 0; i < size; i++) {\n            var genVal = randi(start, end);\n            var recursiveVal = recursive(genVal, genNum);\n            genNum.push(recursiveVal);\n        }\n        return genNum;\n    };\n    /**\n     * Throws error when a required parameter is missing.\n     * @param paramsObject The parameters passed to the function\n     * @param paramsNeeded The required parameters in the function\n     */\n    Utils.prototype.throwErrorOnWrongParams = function (paramsObject, paramsNeeded) {\n        var keys = Object.keys(paramsObject);\n        var bool = [];\n        for (var i = 0; i < keys.length; i++) {\n            if (paramsNeeded.includes(keys[i])) {\n                bool.push(true);\n            }\n            else {\n                bool.push(false);\n            }\n        }\n        var truthy = function (element) { return element == false; };\n        if (bool.some(truthy)) {\n            throw Error(\"Params Error: Required parameter not found. Your params must include the following [\" + paramsNeeded + \"]\");\n        }\n    };\n    /**\n     * Maps integer values (0, 1) to boolean (false, true)\n     * @param arr The array of integers\n     * @param dim The dimension of the array\n     */\n    Utils.prototype.mapIntegersToBooleans = function (arr, dim) {\n        if (dim == 2) {\n            var newArr_1 = [];\n            arr.map(function (innerArr) {\n                var temp = [];\n                innerArr.map(function (val) { return temp.push(val == 1); });\n                newArr_1.push(temp);\n            });\n            return newArr_1;\n        }\n        else {\n            var newArr_2 = [];\n            arr.map(function (val) { return newArr_2.push(val == 1); });\n            return newArr_2;\n        }\n    };\n    /**\n     * Maps boolean values (false, true) to integer equivalent (0, 1)\n     * @param arr The array of booleans\n     * @param dim The dimension of the array\n     */\n    Utils.prototype.mapBooleansToIntegers = function (arr, dim) {\n        if (dim == 2) {\n            var newArr_3 = [];\n            arr.map(function (innerArr) {\n                var temp = [];\n                innerArr.map(function (val) { return temp.push(val ? 1 : 0); });\n                newArr_3.push(temp);\n            });\n            return newArr_3;\n        }\n        else {\n            var newArr_4 = [];\n            arr.map(function (val) { return newArr_4.push(val ? 1 : 0); });\n            return newArr_4;\n        }\n    };\n    /**\n     * Generates an array of dim (row x column) with inner values set to zero\n     * @param row\n     * @param column\n     */\n    Utils.prototype.zeros = function (row, column) {\n        var zeroData = [];\n        for (var i = 0; i < row; i++) {\n            var colData = Array(column);\n            for (var j = 0; j < column; j++) {\n                colData[j] = 0;\n            }\n            zeroData.push(colData);\n        }\n        return zeroData;\n    };\n    /**\n     * Shuffles and returns a random slice of an array\n     * @param num\n     * @param array\n     */\n    Utils.prototype.shuffle = function (array, num) {\n        var i = array.length;\n        var j = 0;\n        var temp;\n        while (i--) {\n            j = Math.floor(Math.random() * (i + 1));\n            temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array.slice(0, num);\n    };\n    /**\n     * Sorts an array in specified order\n     * @param arr\n     * @param ascending\n     * @returns\n     */\n    Utils.prototype.sort = function (arr, ascending) {\n        if (ascending === void 0) { ascending = true; }\n        var sorted = __spreadArray([], arr, true);\n        return sorted.sort(function (a, b) {\n            if (ascending) {\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    return a.charCodeAt(0) - b.charCodeAt(0);\n                }\n                else {\n                    return a - b;\n                }\n            }\n            else {\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    return b.charCodeAt(0) - a.charCodeAt(0);\n                }\n                else {\n                    return b - a;\n                }\n            }\n        });\n    };\n    /**\n     * Checks if current environment is Browser\n     */\n    Utils.prototype.isBrowserEnv = function () {\n        var isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\");\n        return isBrowser();\n    };\n    /**\n     * Checks if current environment is Node\n     */\n    Utils.prototype.isNodeEnv = function () {\n        var isNode = new Function(\"try {return this===global;}catch(e){return false;}\");\n        return isNode();\n    };\n    /**\n     * Remove NaN values from 1D array\n     * @param arr\n     */\n    Utils.prototype.removeMissingValuesFromArray = function (arr) {\n        var _this = this;\n        var values = arr.filter(function (val) {\n            return !(_this.isEmpty(val));\n        });\n        return values;\n    };\n    /**\n     * Replace NaN with null before tensor operations\n     * @param arr\n     */\n    Utils.prototype.replaceNanWithNull = function (arr) {\n        var values = arr.map(function (val) {\n            if (isNaN(val)) {\n                return null;\n            }\n            else {\n                return val;\n            }\n        });\n        return values;\n    };\n    /**\n     * Get duplicate values in a array\n     * @param arr\n     */\n    Utils.prototype.getDuplicate = function (arr) {\n        var tempObj = {};\n        var resultObj = {};\n        for (var i = 0; i < arr.length; i++) {\n            var val = arr[i];\n            if (this.keyInObject(tempObj, val)) {\n                tempObj[val][\"count\"] += 1;\n                tempObj[val][\"index\"].push(i);\n            }\n            else {\n                tempObj[val] = {};\n                tempObj[val][\"count\"] = 1;\n                tempObj[val][\"index\"] = [i];\n            }\n        }\n        for (var key in tempObj) {\n            if (tempObj[key][\"count\"] >= 2) {\n                resultObj[key] = {};\n                resultObj[key][\"count\"] = tempObj[key][\"count\"];\n                resultObj[key][\"index\"] = tempObj[key][\"index\"];\n            }\n        }\n        return resultObj;\n    };\n    /**\n     * Returns the index of a sorted array\n     * @param arr1 The first array\n     * @param arr2 The second array\n     * @param dtype The data type of the arrays\n     *\n     * @returns sorted index\n     */\n    Utils.prototype.sortArrayByIndex = function (arr1, arr2, dtype) {\n        var sortedIdx = arr1.map(function (item, index) {\n            return [arr2[index], item];\n        });\n        if (dtype == \"string\") {\n            sortedIdx.sort();\n        }\n        else {\n            sortedIdx.sort(function (_a, _b) {\n                var arg1 = _a[0];\n                var arg2 = _b[0];\n                return arg2 - arg1;\n            });\n        }\n        return sortedIdx.map(function (_a) {\n            var item = _a[1];\n            return item;\n        });\n    };\n    /**\n     * Returns a new series with properties of the old series\n     *\n     * @param series The series to copy\n    */\n    Utils.prototype.createNdframeFromNewDataWithOldProps = function (_a) {\n        var ndFrame = _a.ndFrame, newData = _a.newData, isSeries = _a.isSeries;\n        if (isSeries) {\n            return new __1.Series(newData, {\n                index: __spreadArray([], ndFrame.index, true),\n                columns: __spreadArray([], ndFrame.columns, true),\n                dtypes: __spreadArray([], ndFrame.dtypes, true),\n                config: __assign({}, ndFrame.config)\n            });\n        }\n        else {\n            return new __2.DataFrame(newData, {\n                index: __spreadArray([], ndFrame.index, true),\n                columns: __spreadArray([], ndFrame.columns, true),\n                dtypes: __spreadArray([], ndFrame.dtypes, true),\n                config: __assign({}, ndFrame.config)\n            });\n        }\n    };\n    /**\n    * Checks if two series are compatible for a mathematical operation\n    * @param object\n    *\n    *   firstSeries ==>  First Series object\n    *\n    *   secondSeries ==> Second Series object to comapre with\n    *\n    *   operation ==> The mathematical operation\n    */\n    Utils.prototype.checkSeriesOpCompactibility = function (_a) {\n        var firstSeries = _a.firstSeries, secondSeries = _a.secondSeries, operation = _a.operation;\n        if (firstSeries.shape[0] != secondSeries.shape[0]) {\n            errors_1.default.throwSeriesMathOpLengthError(firstSeries, secondSeries);\n        }\n        if (firstSeries.dtypes[0] == 'string' || secondSeries.dtypes[0] == 'string') {\n            errors_1.default.throwStringDtypeOperationError(operation);\n        }\n    };\n    /**\n    * Custom sort for an array of index and values\n    * @param arr The array of objects to sort\n    * @param ascending Whether to sort in ascending order or not\n    */\n    Utils.prototype.sortObj = function (arr, ascending) {\n        var sortedValues = arr.sort(function (obj1, obj2) {\n            var a = obj2.value;\n            var b = obj1.value;\n            if (!ascending) {\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    a = a.toUpperCase();\n                    b = b.toUpperCase();\n                    if (a < b) {\n                        return -1;\n                    }\n                    if (a > b) {\n                        return 1;\n                    }\n                    return 0;\n                }\n                else {\n                    return Number(a) - Number(b);\n                }\n            }\n            else {\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    a = a.toUpperCase();\n                    b = b.toUpperCase();\n                    if (a > b) {\n                        return -1;\n                    }\n                    if (a < b) {\n                        return 1;\n                    }\n                    return 0;\n                }\n                else {\n                    return Number(b) - Number(a);\n                    ;\n                }\n            }\n        });\n        return sortedValues;\n    };\n    return Utils;\n}());\nexports.default = Utils;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DATA_TYPES = exports.BASE_CONFIG = void 0;\n/**\n * Default config object\n */\nexports.BASE_CONFIG = {\n    tableMaxRow: 10,\n    tableMaxColInConsole: 10,\n    dtypeTestLim: 20,\n    lowMemoryMode: false,\n};\nexports.DATA_TYPES = [\"float32\", \"int32\", \"string\", \"boolean\", \"datetime\", 'undefined'];\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package wide configuration class\n */\nvar Configs = /** @class */ (function () {\n    function Configs(options) {\n        var _a = __assign({ tableDisplayConfig: {}, tableMaxRow: 10, tableMaxColInConsole: 10, dtypeTestLim: 500, lowMemoryMode: false }, options), tableDisplayConfig = _a.tableDisplayConfig, tableMaxRow = _a.tableMaxRow, tableMaxColInConsole = _a.tableMaxColInConsole, dtypeTestLim = _a.dtypeTestLim, lowMemoryMode = _a.lowMemoryMode;\n        this.tableDisplayConfig = tableDisplayConfig;\n        this.tableMaxRow = tableMaxRow; // The maximum number of rows to display in console\n        this.tableMaxColInConsole = tableMaxColInConsole; // The maximum number of columns to display in console\n        this.dtypeTestLim = dtypeTestLim; // The number of rows to use when inferring data type\n        this.lowMemoryMode = lowMemoryMode; // Whether to use minimal memory or not.\n    }\n    Configs.prototype.setTableDisplayConfig = function (config) {\n        this.tableDisplayConfig = config;\n    };\n    Object.defineProperty(Configs.prototype, \"getTableDisplayConfig\", {\n        get: function () {\n            return this.tableDisplayConfig;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Configs.prototype.setTableMaxColInConsole = function (val) {\n        this.tableMaxColInConsole = val;\n    };\n    Object.defineProperty(Configs.prototype, \"getTableMaxColInConsole\", {\n        get: function () {\n            return this.tableMaxColInConsole;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Configs.prototype.setMaxRow = function (val) {\n        this.tableMaxRow = val;\n    };\n    Object.defineProperty(Configs.prototype, \"getMaxRow\", {\n        get: function () {\n            return this.tableMaxRow;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Configs.prototype, \"getDtypeTestLim\", {\n        get: function () {\n            return this.dtypeTestLim;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Configs.prototype.setDtypeTestLim = function (val) {\n        this.dtypeTestLim = val;\n    };\n    Object.defineProperty(Configs.prototype, \"isLowMemoryMode\", {\n        get: function () {\n            return this.lowMemoryMode;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Configs.prototype.setIsLowMemoryMode = function (val) {\n        this.lowMemoryMode = val;\n    };\n    return Configs;\n}());\nexports.default = Configs;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar defaults_1 = require(\"./defaults\");\n/**\n * Package wide error throwing class\n */\nvar ErrorThrower = /** @class */ (function () {\n    function ErrorThrower() {\n        this.throwColumnNamesLengthError = function (ndframe, columns) {\n            var msg = \"ParamError: Column names length mismatch. You provided a column of length \" + columns.length + \" but Ndframe columns has length of \" + ndframe.shape[1];\n            throw new Error(msg);\n        };\n        this.throwIndexLengthError = function (ndframe, index) {\n            var msg = \"IndexError: You provided an index of length \" + index.length + \" but Ndframe rows has length of \" + ndframe.shape[0];\n            throw new Error(msg);\n        };\n        this.throwIndexDuplicateError = function () {\n            var msg = \"IndexError: Row index must contain unique values\";\n            throw new Error(msg);\n        };\n        this.throwColumnDuplicateError = function () {\n            var msg = \"ColumnIndexError: Column index must contain unique values\";\n            throw new Error(msg);\n        };\n        this.throwDtypesLengthError = function (ndframe, dtypes) {\n            var msg = \"DtypeError: You provided a dtype array of length \" + dtypes.length + \" but Ndframe columns has length of \" + ndframe.shape[1];\n            throw new Error(msg);\n        };\n        this.throwDtypeNotSupportedError = function (dtype) {\n            var msg = \"DtypeError: Dtype \\\"\" + dtype + \"\\\" not supported. dtype must be one of \\\"\" + defaults_1.DATA_TYPES + \"\\\"\";\n            throw new Error(msg);\n        };\n        this.throwDtypeWithoutColumnError = function () {\n            var msg = \"DtypeError: columns parameter must be provided when dtypes parameter is provided\";\n            throw new Error(msg);\n        };\n        this.throwColumnLengthError = function (ndframe, arrLen) {\n            var msg = \"ParamError: Column data length mismatch. You provided data with length \" + arrLen + \" but Ndframe has column of length \" + ndframe.shape[0];\n            throw new Error(msg);\n        };\n        this.throwRowLengthError = function (ndframe, arrLen) {\n            var msg = \"ParamError: Row data length mismatch. You provided data with length \" + arrLen + \" but Ndframe has row of length \" + ndframe.shape[0];\n            throw new Error(msg);\n        };\n        this.throwColumnNotFoundError = function (ndframe) {\n            var msg = \"ParamError: Column not found!. Column name must be one of \" + ndframe.columns;\n            throw new Error(msg);\n        };\n        this.throwNotImplementedError = function () {\n            var msg = \"Method not implemented\";\n            throw new Error(msg);\n        };\n        this.throwIlocRowIndexError = function () {\n            var msg = \"ParamError: rows parameter must be a Array. For example: rows: [1,2] or rows: [\\\"0:10\\\"]\";\n            throw new Error(msg);\n        };\n        this.throwIlocColumnsIndexError = function () {\n            var msg = \"ParamError: columns parameter must be a Array. For example: columns: [1,2] or columns: [\\\"0:10\\\"]\";\n            throw new Error(msg);\n        };\n        this.throwStringDtypeOperationError = function (operation) {\n            var msg = \"DtypeError: String data type does not support \" + operation + \" operation\";\n            throw new Error(msg);\n        };\n        this.throwSeriesMathOpLengthError = function (ndframe, other) {\n            var msg = \"ParamError: Row length mismatch. Length of other (\" + other.shape[0] + \"), must be the same as Ndframe (\" + ndframe.shape[0] + \")\";\n            throw new Error(msg);\n        };\n    }\n    return ErrorThrower;\n}());\nexports.default = new ErrorThrower();\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This file is auto-generated by prebuild.js. Do not edit!\nvar tf = require(\"@tensorflow/tfjs\");\nexports.default = tf;\n","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar dummy_encoder_1 = __importDefault(require(\"../transformers/encoders/dummy.encoder\"));\nvar mathjs_1 = require(\"mathjs\");\nvar tensorflowlib_1 = __importDefault(require(\"../shared/tensorflowlib\"));\nvar defaults_1 = require(\"../shared/defaults\");\nvar math_ops_1 = require(\"./math.ops\");\nvar errors_1 = __importDefault(require(\"../shared/errors\"));\nvar indexing_1 = require(\"./indexing\");\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar generic_1 = __importDefault(require(\"./generic\"));\nvar table_1 = require(\"table\");\nvar strings_1 = __importDefault(require(\"./strings\"));\nvar datetime_1 = __importDefault(require(\"./datetime\"));\nvar plotting_1 = require(\"../../danfojs-base/plotting\");\nvar utils = new utils_1.default();\n/**\n * One-dimensional ndarray with axis labels.\n * The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index.\n * Operations between Series (+, -, /, , *) align values based on their associated index values  they need not be the same length.\n * @param data 1D Array, JSON, Tensor, Block of data.\n * @param options.index Array of numeric or string index for subseting array. If not specified, indices are auto generated.\n * @param options.columns Column name. This is like the name of the Series. If not specified, column name is set to 0.\n * @param options.dtypes Data types of the Series data. If not specified, dtypes is inferred.\n * @param options.config General configuration object for extending or setting Series behavior.\n */\nvar Series = /** @class */ (function (_super) {\n    __extends(Series, _super);\n    function Series(data, options) {\n        if (data === void 0) { data = []; }\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        var index = options.index, columns = options.columns, dtypes = options.dtypes, config = options.config;\n        if (Array.isArray(data[0]) || utils.isObject(data[0])) {\n            data = utils.convert2DArrayToSeriesArray(data);\n            _this = _super.call(this, {\n                data: data,\n                index: index,\n                columns: columns,\n                dtypes: dtypes,\n                config: config,\n                isSeries: true\n            }) || this;\n        }\n        else {\n            _this = _super.call(this, {\n                data: data,\n                index: index,\n                columns: columns,\n                dtypes: dtypes,\n                config: config,\n                isSeries: true\n            }) || this;\n        }\n        return _this;\n    }\n    /**\n    * Purely integer-location based indexing for selection by position.\n    * ``.iloc`` is primarily integer position based (from ``0`` to\n    * ``length-1`` of the axis), but may also be used with a boolean array.\n    *\n    * @param rows Array of row indexes\n    *\n    * Allowed inputs are in rows and columns params are:\n    *\n    * - An array of single integer, e.g. ``[5]``.\n    * - A list or array of integers, e.g. ``[4, 3, 0]``.\n    * - A slice array string with ints, e.g. ``[\"1:7\"]``.\n    * - A boolean array.\n    * - A ``callable`` function with one argument (the calling Series or\n    * DataFrame) and that returns valid output for indexing (one of the above).\n    * This is useful in method chains, when you don't have a reference to the\n    * calling object, but would like to base your selection on some value.\n    *\n    * ``.iloc`` will raise ``IndexError`` if a requested indexer is\n    * out-of-bounds.\n    *\n    * @example\n    * ```\n    * const sf = new Series([1, 2, 3, 4, 5, 6], { index: ['a', 'b', 'c', 'd', 'e', 'f'] });\n    * const sf2 = sf.iloc([0, 2, 4]);\n    * sf2.print();\n    * ```\n    */\n    Series.prototype.iloc = function (rows) {\n        return (0, indexing_1._iloc)({ ndFrame: this, rows: rows });\n    };\n    /**\n     * Access a group of rows by label(s) or a boolean array.\n     * ``loc`` is primarily label based, but may also be used with a boolean array.\n     *\n     * @param rows Array of row indexes\n     *\n     * Allowed inputs are:\n     *\n     * - A single label, e.g. ``[\"5\"]`` or ``['a']``, (note that ``5`` is interpreted as a\n     *   *label* of the index, and **never** as an integer position along the index).\n     *\n     * - A list or array of labels, e.g. ``['a', 'b', 'c']``.\n     *\n     * - A slice object with labels, e.g. ``[\"a:f\"]``. Note that start and the stop are included\n     *\n     * - A boolean array of the same length as the axis being sliced,\n     * e.g. ``[True, False, True]``.\n     *\n     * - A ``callable`` function with one argument (the calling Series or\n     * DataFrame) and that returns valid output for indexing (one of the above)\n     *\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6], { index: ['a', 'b', 'c', 'd', 'e', 'f'] });\n     * const sf2 = sf.loc(['a', 'c', 'e']);\n     * sf2.print();\n     * ```\n     *\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6], { index: ['a', 'b', 'c', 'd', 'e', 'f'] });\n     * const sf2 = sf.loc(sf.gt(2));\n     * sf2.print();\n     * ```\n    */\n    Series.prototype.loc = function (rows) {\n        return (0, indexing_1._loc)({ ndFrame: this, rows: rows });\n    };\n    /**\n      * Returns the first n values in a Series\n      * @param rows The number of rows to return\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6], { index: ['a', 'b', 'c', 'd', 'e', 'f'] });\n      * const sf2 = sf.head(3);\n      * sf2.print();\n      * ```\n    */\n    Series.prototype.head = function (rows) {\n        if (rows === void 0) { rows = 5; }\n        if (rows <= 0) {\n            throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n        }\n        if (this.shape[0] <= rows) {\n            return this.copy();\n        }\n        if (this.shape[0] - rows < 0) {\n            throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n        }\n        return this.iloc([\"0:\" + rows]);\n    };\n    /**\n      * Returns the last n values in a Series\n      * @param rows The number of rows to return\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6], { index: ['a', 'b', 'c', 'd', 'e', 'f'] });\n      * const sf2 = sf.tail(3);\n      * sf2.print();\n      * ```\n    */\n    Series.prototype.tail = function (rows) {\n        if (rows === void 0) { rows = 5; }\n        if (rows <= 0) {\n            throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n        }\n        if (this.shape[0] <= rows) {\n            return this.copy();\n        }\n        if (this.shape[0] - rows < 0) {\n            throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n        }\n        var startIdx = this.shape[0] - rows;\n        return this.iloc([startIdx + \":\"]);\n    };\n    /**\n     * Returns specified number of random rows in a Series\n     * @param num The number of rows to return\n     * @param options.seed An integer specifying the random seed that will be used to create the distribution.\n     * @example\n     * ```\n     * const df = new Series([1, 2, 3, 4])\n     * const df2 = await df.sample(2)\n     * df2.print()\n     * ```\n     * @example\n     * ```\n     * const df = new Series([1, 2, 3, 4])\n     * const df2 = await df.sample(1, { seed: 1 })\n     * df2.print()\n     * ```\n    */\n    Series.prototype.sample = function (num, options) {\n        if (num === void 0) { num = 5; }\n        return __awaiter(this, void 0, void 0, function () {\n            var seed, shuffledIndex, sf;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        seed = __assign({ seed: 1 }, options).seed;\n                        if (num > this.shape[0]) {\n                            throw new Error(\"Sample size n cannot be bigger than size of dataset\");\n                        }\n                        if (num < -1 || num == 0) {\n                            throw new Error(\"Sample size cannot be less than -1 or be equal to 0\");\n                        }\n                        num = num === -1 ? this.shape[0] : num;\n                        return [4 /*yield*/, tensorflowlib_1.default.data.array(this.index).shuffle(num, \"\" + seed).take(num).toArray()];\n                    case 1:\n                        shuffledIndex = _a.sent();\n                        sf = this.iloc(shuffledIndex);\n                        return [2 /*return*/, sf];\n                }\n            });\n        });\n    };\n    Series.prototype.add = function (other, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"add\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"add\" });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({ ndFrame: this, newData: newData, isSeries: true });\n        }\n    };\n    Series.prototype.sub = function (other, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"sub\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"sub\" });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({ ndFrame: this, newData: newData, isSeries: true });\n        }\n    };\n    Series.prototype.mul = function (other, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"mul\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"mul\" });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({ ndFrame: this, newData: newData, isSeries: true });\n        }\n    };\n    Series.prototype.div = function (other, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"div\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"div\" });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({ ndFrame: this, newData: newData, isSeries: true });\n        }\n    };\n    Series.prototype.pow = function (other, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"pow\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"pow\" });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({ ndFrame: this, newData: newData, isSeries: true });\n        }\n    };\n    Series.prototype.mod = function (other, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"mod\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"mod\" });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({ ndFrame: this, newData: newData, isSeries: true });\n        }\n    };\n    /**\n     * Checks if the array value passed has a compatible dtype, removes NaN values, and if\n     * boolean values are present, converts them to integer values.\n    */\n    Series.prototype.$checkAndCleanValues = function (values, operation) {\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(operation);\n        values = utils.removeMissingValuesFromArray(values);\n        if (this.dtypes[0] == \"boolean\") {\n            values = utils.mapBooleansToIntegers(values, 1);\n        }\n        return values;\n    };\n    /**\n     * Returns the mean of elements in Series.\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6]);\n     * console.log(sf.mean());\n     * //output 3.5\n     * ```\n    */\n    Series.prototype.mean = function () {\n        var values = this.$checkAndCleanValues(this.values, \"mean\");\n        return (values.reduce(function (a, b) { return a + b; }) / values.length);\n    };\n    /**\n      * Returns the median of elements in Series\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * console.log(sf.median());\n      * //output 3.5\n      * ```\n    */\n    Series.prototype.median = function () {\n        var values = this.$checkAndCleanValues(this.values, \"median\");\n        return (0, mathjs_1.median)(values);\n    };\n    /**\n      * Returns the modal value of elements in Series\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 4, 5, 6]);\n      * console.log(sf.mode());\n      * //output [ 4 ]\n      * ```\n      *\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 4, 5, 5, 6]);\n      * console.log(sf.mode());\n      * //output [ 4, 5 ]\n      * ```\n      *\n    */\n    Series.prototype.mode = function () {\n        var values = this.$checkAndCleanValues(this.values, \"mode\");\n        return (0, mathjs_1.mode)(values);\n    };\n    /**\n      * Returns the minimum value in a Series\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * console.log(sf.min());\n      * //output 1\n      * ```\n      *\n    */\n    Series.prototype.min = function () {\n        var values = this.$checkAndCleanValues(this.values, \"min\");\n        var smallestValue = values[0];\n        for (var i = 0; i < values.length; i++) {\n            smallestValue = smallestValue < values[i] ? smallestValue : values[i];\n        }\n        return smallestValue;\n    };\n    /**\n      * Returns the maximum value in a Series\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * console.log(sf.max());\n      * //output 6\n      * ```\n    */\n    Series.prototype.max = function () {\n        var values = this.$checkAndCleanValues(this.values, \"max\");\n        var biggestValue = values[0];\n        for (var i = 0; i < values.length; i++) {\n            biggestValue = biggestValue > values[i] ? biggestValue : values[i];\n        }\n        return biggestValue;\n    };\n    /**\n      * Return the sum of the values in a series.\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * console.log(sf.sum());\n      * //output 21\n      * ```\n    */\n    Series.prototype.sum = function () {\n        var values = this.$checkAndCleanValues(this.values, \"sum\");\n        return values.reduce(function (sum, value) { return sum + value; }, 0);\n    };\n    /**\n       * Return number of non-null elements in a Series\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * console.log(sf.count());\n       * //output 6\n       * ```\n       *\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6, NaN]);\n       * console.log(sf.count());\n       * //output 6\n       * ```\n    */\n    Series.prototype.count = function () {\n        var values = utils.removeMissingValuesFromArray(this.values);\n        return values.length;\n    };\n    /**\n      * Return maximum of series and other.\n      * @param other Series, number or Array of numbers to check against\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * const sf2 = sf.maximum(3);\n      * console.log(sf2.values);\n      * //output [ 3, 3, 3, 4, 5, 6 ]\n      * ```\n      *\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * const sf2 = new Series([4, 1, 3, 40, 5, 3]);\n      * const sf3 = sf.maximum(sf2);\n      * console.log(sf3.values);\n      * //output [ 4, 2, 3, 40, 5, 6 ]\n      * ```\n    */\n    Series.prototype.maximum = function (other) {\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"maximum\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"maximum\" });\n        return new Series(newData, {\n            columns: this.columns,\n            index: this.index\n        });\n    };\n    /**\n      * Return minimum of series and other.\n      * @param other Series, number of Array of numbers to check against\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * const sf2 = sf.minimum(3);\n      * console.log(sf2.values);\n      * //output [ 1, 2, 3, 3, 3, 3 ]\n      * ```\n      *\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * const sf2 = new Series([4, 1, 3, 40, 5, 3]);\n      * const sf3 = sf.minimum(sf2);\n      * console.log(sf3.values);\n      * //output [ 1, 1, 3, 4, 5, 3 ]\n      * ```\n      *\n    */\n    Series.prototype.minimum = function (other) {\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"maximum\");\n        var newData = (0, math_ops_1._genericMathOp)({ ndFrame: this, other: other, operation: \"minimum\" });\n        return new Series(newData, {\n            columns: this.columns,\n            index: this.index\n        });\n    };\n    Series.prototype.round = function (dp, options) {\n        if (dp === void 0) { dp = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (dp === undefined)\n            dp = 1;\n        var newValues = utils.round(this.values, dp, true);\n        if (inplace) {\n            this.$setValues(newValues);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({\n                ndFrame: this,\n                newData: newValues,\n                isSeries: true\n            });\n        }\n    };\n    /**\n      * Return sample standard deviation of elements in Series\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * console.log(sf.std());\n      * //output 1.8708286933869707\n      * ```\n    */\n    Series.prototype.std = function () {\n        var values = this.$checkAndCleanValues(this.values, \"max\");\n        return (0, mathjs_1.std)(values);\n    };\n    /**\n      *  Return unbiased variance of elements in a Series.\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * console.log(sf.var());\n      * //output 3.5\n      * ```\n    */\n    Series.prototype.var = function () {\n        var values = this.$checkAndCleanValues(this.values, \"max\");\n        return (0, mathjs_1.variance)(values);\n    };\n    /**\n     * Return a boolean same-sized object indicating where elements are NaN.\n     * NaN and undefined values gets mapped to true, and everything else gets mapped to false.\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, NaN, 6]);\n     * console.log(sf.isNaN());\n     * //output [ false, false, false, false, true, false ]\n     * ```\n     *\n    */\n    Series.prototype.isNa = function () {\n        var newData = this.values.map(function (value) {\n            if (utils.isEmpty(value)) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        });\n        var sf = new Series(newData, {\n            index: this.index,\n            dtypes: [\"boolean\"],\n            config: this.config\n        });\n        return sf;\n    };\n    Series.prototype.fillNa = function (value, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!value && typeof value !== \"boolean\" && typeof value !== \"number\") {\n            throw Error('ParamError: value must be specified');\n        }\n        var newValues = [];\n        this.values.forEach(function (val) {\n            if (utils.isEmpty(val)) {\n                newValues.push(value);\n            }\n            else {\n                newValues.push(val);\n            }\n        });\n        if (inplace) {\n            this.$setValues(newValues);\n        }\n        else {\n            return utils.createNdframeFromNewDataWithOldProps({\n                ndFrame: this,\n                newData: newValues,\n                isSeries: true\n            });\n        }\n    };\n    Series.prototype.sortValues = function (options) {\n        var _a = __assign({ ascending: true, inplace: false }, options), ascending = _a.ascending, inplace = _a.inplace;\n        var sortedValues = [];\n        var sortedIndex = [];\n        var rangeIdx = utils.range(0, this.index.length - 1);\n        var sortedIdx = utils.sortArrayByIndex(rangeIdx, this.values, this.dtypes[0]);\n        for (var _i = 0, sortedIdx_1 = sortedIdx; _i < sortedIdx_1.length; _i++) {\n            var indx = sortedIdx_1[_i];\n            sortedValues.push(this.values[indx]);\n            sortedIndex.push(this.index[indx]);\n        }\n        if (ascending) {\n            sortedValues = sortedValues.reverse();\n            sortedIndex = sortedIndex.reverse();\n        }\n        if (inplace) {\n            this.$setValues(sortedValues);\n            this.$setIndex(sortedIndex);\n        }\n        else {\n            var sf = new Series(sortedValues, {\n                index: sortedIndex,\n                dtypes: this.dtypes,\n                config: this.config\n            });\n            return sf;\n        }\n    };\n    /**\n      * Makes a deep copy of a Series\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * const sf2 = sf.copy();\n      * ```\n      *\n    */\n    Series.prototype.copy = function () {\n        var sf = new Series(__spreadArray([], this.values, true), {\n            columns: __spreadArray([], this.columns, true),\n            index: __spreadArray([], this.index, true),\n            dtypes: __spreadArray([], this.dtypes, true),\n            config: __assign({}, this.config)\n        });\n        return sf;\n    };\n    /**\n      * Generate descriptive statistics.\n      * Descriptive statistics include those that summarize the central tendency,\n      * dispersion and shape of a datasets distribution, excluding NaN values.\n      * @example\n      * ```\n      * const sf = new Series([1, 2, 3, 4, 5, 6]);\n      * const sf2 = sf.describe();\n      * sf2.print();\n      * ```\n    */\n    Series.prototype.describe = function () {\n        if (this.dtypes[0] == \"string\") {\n            throw new Error(\"DType Error: Cannot generate descriptive statistics for Series with string dtype\");\n        }\n        else {\n            var index = ['count', 'mean', 'std', 'min', 'median', 'max', 'variance'];\n            var count = this.count();\n            var mean = this.mean();\n            var std_1 = this.std();\n            var min = this.min();\n            var median_1 = this.median();\n            var max = this.max();\n            var variance_1 = this.var();\n            var data = [count, mean, std_1, min, median_1, max, variance_1];\n            var sf = new Series(data, { index: index });\n            return sf;\n        }\n    };\n    Series.prototype.resetIndex = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (inplace) {\n            this.$resetIndex();\n        }\n        else {\n            var sf = this.copy();\n            sf.$resetIndex();\n            return sf;\n        }\n    };\n    Series.prototype.setIndex = function (index, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!index) {\n            throw Error('Param Error: Must specify index array');\n        }\n        if (inplace) {\n            this.$setIndex(index);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setIndex(index);\n            return sf;\n        }\n    };\n    Series.prototype.map = function (callable, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var isCallable = utils.isFunction(callable);\n        var data = this.values.map(function (val, i) {\n            if (isCallable) {\n                return callable(val, i);\n            }\n            else if (utils.isObject(callable)) {\n                if (val in callable) {\n                    //@ts-ignore\n                    return callable[val];\n                }\n                else {\n                    return val;\n                }\n            }\n            else {\n                throw new Error(\"Param Error: callable must either be a function or an object\");\n            }\n        });\n        if (inplace) {\n            this.$setValues(data);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(data);\n            return sf;\n        }\n    };\n    Series.prototype.apply = function (callable, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var isCallable = utils.isFunction(callable);\n        if (!isCallable) {\n            throw new Error(\"Param Error: callable must be a function\");\n        }\n        var data = this.values.map(function (val) {\n            return callable(val);\n        });\n        if (inplace) {\n            this.$setValues(data);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(data);\n            return sf;\n        }\n    };\n    /**\n     * Returns a Series with only the unique value(s) in the original Series\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]);\n     * const sf2 = sf.unique();\n     * console.log(sf2.values);\n     * //output [ 1, 2, 3, 4, 5, 6 ]\n     * ```\n    */\n    Series.prototype.unique = function () {\n        var newValues = new Set(this.values);\n        var series = new Series(Array.from(newValues));\n        return series;\n    };\n    /**\n     * Return the number of unique elements in a Series\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]);\n     * console.log(sf.nUnique());\n     * //output 6\n     * ```\n     *\n    */\n    Series.prototype.nUnique = function () {\n        return (new Set(this.values)).size;\n    };\n    /**\n     * Returns unique values and their counts in a Series\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]);\n     * const sf2 = sf.valueCounts();\n     * sf2.print();\n     * ```\n    */\n    Series.prototype.valueCounts = function () {\n        var sData = this.values;\n        var dataDict = {};\n        for (var i = 0; i < sData.length; i++) {\n            var val = sData[i];\n            if (\"\" + val in dataDict) {\n                dataDict[\"\" + val] = dataDict[\"\" + val] + 1;\n            }\n            else {\n                dataDict[\"\" + val] = 1;\n            }\n        }\n        var index = Object.keys(dataDict).map(function (x) {\n            return parseInt(x) ? parseInt(x) : x;\n        });\n        var data = Object.values(dataDict);\n        var series = new Series(data, { index: index });\n        return series;\n    };\n    Series.prototype.abs = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(\"abs\");\n        var newValues;\n        newValues = this.values.map(function (val) { return Math.abs(val); });\n        if (inplace) {\n            this.$setValues(newValues);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(newValues);\n            return sf;\n        }\n    };\n    Series.prototype.cumSum = function (options) {\n        var ops = __assign({ inplace: false }, options);\n        return this.cumOps(\"sum\", ops);\n    };\n    Series.prototype.cumMin = function (options) {\n        var ops = __assign({ inplace: false }, options);\n        return this.cumOps(\"min\", ops);\n    };\n    Series.prototype.cumMax = function (options) {\n        var ops = __assign({ inplace: false }, options);\n        return this.cumOps(\"max\", ops);\n    };\n    Series.prototype.cumProd = function (options) {\n        var ops = __assign({ inplace: false }, options);\n        return this.cumOps(\"prod\", ops);\n    };\n    /**\n     * Internal helper function to calculate cumulative operations on series data\n    */\n    Series.prototype.cumOps = function (ops, options) {\n        if (this.dtypes[0] == \"string\")\n            errors_1.default.throwStringDtypeOperationError(ops);\n        var inplace = options.inplace;\n        var sData = this.values;\n        var tempval = sData[0];\n        var data = [tempval];\n        for (var i = 1; i < sData.length; i++) {\n            var currVal = sData[i];\n            switch (ops) {\n                case \"max\":\n                    if (currVal > tempval) {\n                        data.push(currVal);\n                        tempval = currVal;\n                    }\n                    else {\n                        data.push(tempval);\n                    }\n                    break;\n                case \"min\":\n                    if (currVal < tempval) {\n                        data.push(currVal);\n                        tempval = currVal;\n                    }\n                    else {\n                        data.push(tempval);\n                    }\n                    break;\n                case \"sum\":\n                    tempval = tempval + currVal;\n                    data.push(tempval);\n                    break;\n                case \"prod\":\n                    tempval = tempval * currVal;\n                    data.push(tempval);\n                    break;\n            }\n        }\n        if (inplace) {\n            this.$setValues(data);\n        }\n        else {\n            return new Series(data, {\n                index: this.index,\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n       * Returns less than of series and other. Supports element wise operations\n       * @param other Series, number, or Array of numbers to compare against\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.lt(3);\n       * console.log(sf2.values);\n       * //output [ true, true, false, false, false, false ]\n       * ```\n       *\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.lt([3, 4, 5, 6, 7, 8]);\n       * console.log(sf2.values);\n       * //output [ true, true, false, false, false, false ]\n       * ```\n    */\n    Series.prototype.lt = function (other) {\n        return this.boolOps(other, \"lt\");\n    };\n    /**\n       * Returns Greater than of series and other. Supports element wise operations\n       * @param other Series, number or Array of numbers to compare against\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.gt(3);\n       * console.log(sf2.values);\n       * //output [ false, false, true, true, true, true ]\n       * ```\n       *\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.gt([3, 4, 5, 6, 7, 8]);\n       * console.log(sf2.values);\n       * //output [ false, false, true, true, true, true ]\n       * ```\n    */\n    Series.prototype.gt = function (other) {\n        return this.boolOps(other, \"gt\");\n    };\n    /**\n       * Returns Less than or Equal to of series and other. Supports element wise operations\n       * @param other Series, number or Array of numbers to compare against\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.le(3);\n       * console.log(sf2.values);\n       * //output [ true, true, true, true, false, false ]\n       * ```\n       *\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.le([3, 4, 5, 6, 7, 8]);\n       * console.log(sf2.values);\n       * //output [ true, true, true, true, false, false ]\n       * ```\n       *\n    */\n    Series.prototype.le = function (other) {\n        return this.boolOps(other, \"le\");\n    };\n    /**\n       * Returns Greater than or Equal to of series and other. Supports element wise operations\n       * @param other Series, number or Array of numbers to compare against\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.ge(3);\n       * console.log(sf2.values);\n       * //output [ false, false, true, true, true, true ]\n       * ```\n       *\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.ge([3, 4, 5, 6, 7, 8]);\n       * console.log(sf2.values);\n       * //output [ false, false, true, true, true, true ]\n       * ```\n       */\n    Series.prototype.ge = function (other) {\n        return this.boolOps(other, \"ge\");\n    };\n    /**\n        * Returns Not Equal to of series and other. Supports element wise operations\n        * @param other Series, number or Array of numbers to compare against\n        * @example\n        * ```\n        * const sf = new Series([1, 2, 3, 4, 5, 6]);\n        * const sf2 = sf.ne(3);\n        * console.log(sf2.values);\n        * //output [ true, true, false, true, true, true ]\n        * ```\n        *\n        * @example\n        * ```\n        * const sf = new Series([1, 2, 3, 4, 5, 6]);\n        * const sf2 = sf.ne([3, 2, 5, 6, 7, 8]);\n        * console.log(sf2.values);\n        * //output [ true, false, true, true, true, true ]\n        * ```\n        *\n    */\n    Series.prototype.ne = function (other) {\n        return this.boolOps(other, \"ne\");\n    };\n    /**\n       * Returns Equal to of series and other. Supports element wise operations\n       * @param other Series, number or Array of numbers to compare against\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.eq(3);\n       * console.log(sf2.values);\n       * //output [ false, false, true, false, false, false ]\n       * ```\n       *\n       * @example\n       * ```\n       * const sf = new Series([1, 2, 3, 4, 5, 6]);\n       * const sf2 = sf.eq(new Series([3, 2, 5, 6, 7, 8]));\n       * console.log(sf2.values);\n       * //output [ false, true, false, false, false, false ]\n       * ```\n       */\n    Series.prototype.eq = function (other) {\n        return this.boolOps(other, \"eq\");\n    };\n    /**\n     * Internal function to perform boolean operations\n     * @param other Other Series or number to compare with\n     * @param bOps Name of operation to perform [ne, ge, le, gt, lt, eq]\n     */\n    Series.prototype.boolOps = function (other, bOps) {\n        var data = [];\n        var lSeries = this.values;\n        var rSeries;\n        if (typeof other == \"number\") {\n            rSeries = Array(this.values.length).fill(other); //create array of repeated value for broadcasting\n        }\n        else if (typeof other == \"string\" && [\"eq\", \"ne\"].includes(bOps)) {\n            rSeries = Array(this.values.length).fill(other);\n        }\n        else if (other instanceof Series) {\n            rSeries = other.values;\n        }\n        else if (Array.isArray(other)) {\n            rSeries = other;\n        }\n        else {\n            throw new Error(\"ParamError: value for other not supported. It must be either a scalar, Array or Series\");\n        }\n        if (!(lSeries.length === rSeries.length)) {\n            throw new Error(\"LengthError: length of other must be equal to length of Series\");\n        }\n        for (var i = 0; i < lSeries.length; i++) {\n            var lVal = lSeries[i];\n            var rVal = rSeries[i];\n            var bool = null;\n            switch (bOps) {\n                case \"lt\":\n                    bool = lVal < rVal ? true : false;\n                    data.push(bool);\n                    break;\n                case \"gt\":\n                    bool = lVal > rVal ? true : false;\n                    data.push(bool);\n                    break;\n                case \"le\":\n                    bool = lVal <= rVal ? true : false;\n                    data.push(bool);\n                    break;\n                case \"ge\":\n                    bool = lVal >= rVal ? true : false;\n                    data.push(bool);\n                    break;\n                case \"ne\":\n                    bool = lVal !== rVal ? true : false;\n                    data.push(bool);\n                    break;\n                case \"eq\":\n                    bool = lVal === rVal ? true : false;\n                    data.push(bool);\n                    break;\n            }\n        }\n        return new Series(data, {\n            index: this.index,\n            config: __assign({}, this.config)\n        });\n    };\n    Series.prototype.replace = function (oldValue, newValue, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!oldValue && typeof oldValue !== 'boolean') {\n            throw Error(\"Params Error: Must specify param 'oldValue' to replace\");\n        }\n        if (!newValue && typeof newValue !== 'boolean') {\n            throw Error(\"Params Error: Must specify param 'newValue' to replace with\");\n        }\n        var newArr = __spreadArray([], this.values, true).map(function (val) {\n            if (val === oldValue) {\n                return newValue;\n            }\n            else {\n                return val;\n            }\n        });\n        if (inplace) {\n            this.$setValues(newArr);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Series.prototype.dropNa = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var oldValues = this.values;\n        var oldIndex = this.index;\n        var newValues = [];\n        var newIndex = [];\n        var isNaVals = this.isNa().values;\n        isNaVals.forEach(function (val, i) {\n            if (!val) {\n                newValues.push(oldValues[i]);\n                newIndex.push(oldIndex[i]);\n            }\n        });\n        if (inplace) {\n            this.$setValues(newValues, false);\n            this.$setIndex(newIndex);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(newValues, false);\n            sf.$setIndex(newIndex);\n            return sf;\n        }\n    };\n    /**\n     * Returns the integer indices that would sort the Series.\n     * @param ascending Boolean indicating whether to sort in ascending order or not. Defaults to true\n     * @example\n     * ```\n     * const sf = new Series([3, 1, 2]);\n     * const sf2 = sf.argSort();\n     * console.log(sf2.values);\n     * //output [ 1, 2, 0 ]\n     * ```\n     *\n     * @example\n     * ```\n     * const sf = new Series([3, 1, 2]);\n     * const sf2 = sf.argSort({ascending: false});\n     * console.log(sf2.values);\n     * //output [ 0, 2, 1 ]\n     *\n     */\n    Series.prototype.argSort = function (options) {\n        var ascending = __assign({ ascending: true }, options).ascending;\n        var sortedIndex = this.sortValues({ ascending: ascending });\n        var sf = new Series(sortedIndex.index);\n        return sf;\n    };\n    /**\n       * Returns integer position of the largest value in the Series.\n       * @example\n       * ```\n       * const sf = new Series([3, 1, 2]);\n       * const sf2 = sf.argMax();\n       * console.log(sf2);\n       * //output 0\n       * ```\n       *\n    */\n    Series.prototype.argMax = function () {\n        return this.tensor.argMax().arraySync();\n    };\n    /**\n       * Returns integer position of the smallest value in the Series.\n       * @example\n       * ```\n       * const sf = new Series([3, 1, 2]);\n       * const sf2 = sf.argMin();\n       * console.log(sf2);\n       * //output 1\n       * ```\n       *\n    */\n    Series.prototype.argMin = function () {\n        return this.tensor.argMin().arraySync();\n    };\n    Series.prototype.dropDuplicates = function (options) {\n        var _a = __assign({ keep: \"first\", inplace: false }, options), keep = _a.keep, inplace = _a.inplace;\n        if (!([\"first\", \"last\"].includes(keep))) {\n            throw Error(\"Params Error: Keep must be one of 'first' or 'last'\");\n        }\n        var dataArr;\n        var newArr = [];\n        var oldIndex;\n        var newIndex = [];\n        if (keep === \"last\") {\n            dataArr = this.values.reverse();\n            oldIndex = this.index.reverse();\n        }\n        else {\n            dataArr = this.values;\n            oldIndex = this.index;\n        }\n        dataArr.forEach(function (val, i) {\n            if (!newArr.includes(val)) {\n                newIndex.push(oldIndex[i]);\n                newArr.push(val);\n            }\n        });\n        if (keep === \"last\") {\n            //re-reversed the array and index to its true order\n            newArr = newArr.reverse();\n            newIndex = newIndex.reverse();\n        }\n        if (inplace) {\n            this.$setValues(newArr, false);\n            this.$setIndex(newIndex);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(newArr, false);\n            sf.$setIndex(newIndex);\n            return sf;\n        }\n    };\n    Series.prototype.asType = function (dtype, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!dtype) {\n            throw Error(\"Param Error: Please specify dtype to cast to\");\n        }\n        if (!(defaults_1.DATA_TYPES.includes(dtype))) {\n            throw Error(\"dtype \" + dtype + \" not supported. dtype must be one of \" + defaults_1.DATA_TYPES);\n        }\n        var oldValues = __spreadArray([], this.values, true);\n        var newValues = [];\n        switch (dtype) {\n            case \"float32\":\n                oldValues.forEach(function (val) {\n                    newValues.push(Number(val));\n                });\n                break;\n            case \"int32\":\n                oldValues.forEach(function (val) {\n                    newValues.push(parseInt(val));\n                });\n                break;\n            case \"string\":\n                oldValues.forEach(function (val) {\n                    newValues.push(String(val));\n                });\n                break;\n            case \"boolean\":\n                oldValues.forEach(function (val) {\n                    newValues.push(Boolean(val));\n                });\n                break;\n            case \"undefined\":\n                oldValues.forEach(function (_) {\n                    newValues.push(NaN);\n                });\n                break;\n            default:\n                break;\n        }\n        if (inplace) {\n            this.$setValues(newValues, false);\n            this.$setDtypes([dtype]);\n        }\n        else {\n            var sf = this.copy();\n            sf.$setValues(newValues, false);\n            sf.$setDtypes([dtype]);\n            return sf;\n        }\n    };\n    Series.prototype.append = function (newValue, index, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!newValue && typeof newValue !== \"boolean\" && typeof newValue !== \"number\") {\n            throw Error(\"Param Error: newValue cannot be null or undefined\");\n        }\n        if (!index) {\n            throw Error(\"Param Error: index cannot be null or undefined\");\n        }\n        var newData = __spreadArray([], this.values, true);\n        var newIndx = __spreadArray([], this.index, true);\n        if (Array.isArray(newValue) && Array.isArray(index)) {\n            if (newValue.length !== index.length) {\n                throw Error(\"Param Error: Length of new values and index must be the same\");\n            }\n            newValue.forEach(function (el, i) {\n                newData.push(el);\n                newIndx.push(index[i]);\n            });\n        }\n        else if (newValue instanceof Series) {\n            var _value = newValue.values;\n            if (!Array.isArray(index)) {\n                throw Error(\"Param Error: index must be an array\");\n            }\n            if (index.length !== _value.length) {\n                throw Error(\"Param Error: Length of new values and index must be the same\");\n            }\n            _value.forEach(function (el, i) {\n                newData.push(el);\n                newIndx.push(index[i]);\n            });\n        }\n        else {\n            newData.push(newValue);\n            newIndx.push(index);\n        }\n        if (inplace) {\n            this.$setValues(newData, false);\n            this.$setIndex(newIndx);\n        }\n        else {\n            var sf = new Series(newData, {\n                index: newIndx,\n                columns: this.columns,\n                dtypes: this.dtypes,\n                config: this.config\n            });\n            return sf;\n        }\n    };\n    Object.defineProperty(Series.prototype, \"dtype\", {\n        /**\n         * Returns dtype of Series\n         * @example\n         * ```\n         * const sf = new Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n         * console.log(sf.dtype);\n         * //output \"int32\"\n         * ```\n        */\n        get: function () {\n            return this.dtypes[0];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Series.prototype, \"str\", {\n        /**\n         * Exposes numerous string methods to manipulate Series of string dtype\n         * @example\n         * ```\n         * const sf = new Series([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]);\n         * const sfs = sf.str.join(\"HelloWorld\", \"\");\n         * console.log(sfs.values);\n         * //output [\"aHelloWorld\", \"bHelloWorld\", \"cHelloWorld\", \"dHelloWorld\", \"eHelloWorld\", \"fHelloWorld\", \"gHelloWorld\", \"hHelloWorld\", \"iHelloWorld\", \"jHelloWorld\"]\n         * ```\n        */\n        get: function () {\n            if (this.dtypes[0] == \"string\") {\n                return new strings_1.default(this);\n            }\n            else {\n                throw new Error(\"Cannot call accessor str on non-string type\");\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Series.prototype, \"dt\", {\n        /**\n          * Returns time class that exposes different date time method\n          * @example\n          * ```\n          * const sf = new Series([\n          *  \"2020-01-01\",\n          *  \"2020-01-02\",\n          *  \"2020-01-03\",\n          *  \"2020-01-04\",\n          *  \"2020-01-05\",\n          * ]);\n          * const sfd = sf.dt.dayOfWeekName();\n          * console.log(sfd.values);\n          * //output [ 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday' ]\n          * ```\n        */\n        get: function () {\n            if ([\"string\", \"datetime\"].includes(this.dtypes[0])) {\n                return new datetime_1.default(this);\n            }\n            else {\n                throw new Error(\"Cannot call accessor dt on non-string type\");\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Overrides default toString implementation. This essentially makes `print()` works.\n    */\n    Series.prototype.toString = function () {\n        var maxRow = this.$config.getMaxRow;\n        var indx;\n        var values = [];\n        if (this.shape[0] > maxRow) {\n            //slice rows to show [max_rows] rows\n            var sfSlice = this.iloc([\"0:\" + maxRow]);\n            indx = sfSlice.index;\n            values = sfSlice.values;\n        }\n        else {\n            indx = this.index;\n            values = this.values;\n        }\n        var tabledata = values.map(function (x, i) { return [indx[i], x]; });\n        return (0, table_1.table)(tabledata);\n    };\n    /**\n     * Returns the logical AND between Series and other. Supports element wise operations and broadcasting.\n     * @param other Series, Scalar, Array of Scalars\n     * @example\n     * ```\n     * const sf = new Series([true, true, false, false, true]);\n     * const sf2 = new Series([true, false, true, false, true]);\n     * const sf3 = sf.and(sf2);\n     * console.log(sf3.values);\n     * //output [ true, false, false, false, false ]\n     * ```\n    */\n    Series.prototype.and = function (other) {\n        if (other === undefined) {\n            throw new Error(\"Param Error: other cannot be undefined\");\n        }\n        var newValues = [];\n        if (other instanceof Series) {\n            if (this.dtypes[0] !== other.dtypes[0]) {\n                throw new Error(\"Param Error: Series must be of same dtype\");\n            }\n            if (this.shape[0] !== other.shape[0]) {\n                throw new Error(\"Param Error: Series must be of same shape\");\n            }\n            this.values.forEach(function (val, i) {\n                newValues.push(Boolean(val) && Boolean(other.values[i]));\n            });\n        }\n        else if (typeof other === \"boolean\") {\n            this.values.forEach(function (val) {\n                newValues.push(Boolean(val) && Boolean(other));\n            });\n        }\n        else if (Array.isArray(other)) {\n            this.values.forEach(function (val, i) {\n                newValues.push(Boolean(val) && Boolean(other[i]));\n            });\n        }\n        else {\n            throw new Error(\"Param Error: other must be a Series, Scalar, or Array of Scalars\");\n        }\n        return new Series(newValues, {\n            index: this.index,\n            config: __assign({}, this.config)\n        });\n    };\n    /**\n     * Returns the logical OR between Series and other. Supports element wise operations and broadcasting.\n     * @param other Series, Scalar, Array of Scalars\n     * @example\n     * ```\n     * const sf = new Series([true, true, false, false, true]);\n     * const sf2 = new Series([true, false, true, false, true]);\n     * const sf3 = sf.or(sf2);\n     * console.log(sf3.values);\n     * //output [ true, true, true, false, true ]\n     * ```\n     *\n    */\n    Series.prototype.or = function (other) {\n        if (other === undefined) {\n            throw new Error(\"Param Error: other cannot be undefined\");\n        }\n        var newValues = [];\n        if (other instanceof Series) {\n            if (this.dtypes[0] !== other.dtypes[0]) {\n                throw new Error(\"Param Error: Series must be of same dtype\");\n            }\n            if (this.shape[0] !== other.shape[0]) {\n                throw new Error(\"Param Error: Series must be of same shape\");\n            }\n            this.values.forEach(function (val, i) {\n                newValues.push(Boolean(val) || Boolean(other.values[i]));\n            });\n        }\n        else if (typeof other === \"boolean\") {\n            this.values.forEach(function (val) {\n                newValues.push(Boolean(val) || Boolean(other));\n            });\n        }\n        else if (Array.isArray(other)) {\n            this.values.forEach(function (val, i) {\n                newValues.push(Boolean(val) || Boolean(other[i]));\n            });\n        }\n        else {\n            throw new Error(\"Param Error: other must be a Series, Scalar, or Array of Scalars\");\n        }\n        return new Series(newValues, {\n            index: this.index,\n            config: __assign({}, this.config)\n        });\n    };\n    /**\n     * One-hot encode values in the Series.\n     * @param options Options for the operation. The following options are available:\n     * - `prefix`: Prefix to add to the new column. Defaults to unique labels.\n     * - `prefixSeparator`: Separator to use for the prefix. Defaults to '_'.\n     * @example\n     * ```\n     * const sf = new Series([\"a\", \"b\", \"c\", \"a\"]);\n     * const sf2 = sf.getDummies({ prefix: \"category\" });\n     * console.log(sf2.values);\n     * //output [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ]\n     * ```\n     *\n     * @example\n     * ```\n     * const sf = new Series([\"a\", \"b\", \"c\", \"a\"]);\n     * const sf2 = sf.getDummies({ prefix: \"category\", prefixSeparator: \"-\" });\n     * console.log(sf2.values);\n     * //output [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ] ]\n     * ```\n     */\n    Series.prototype.getDummies = function (options) {\n        return (0, dummy_encoder_1.default)(this, options);\n    };\n    /**\n     * Access a single value for a row index.\n     * Similar to iloc, in that both provide index-based lookups.\n     * Use iat if you only need to get or set a single value in a Series.\n     * @param row Row index of the value to access.\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5])\n     * sf.iat(0) //returns 1\n     * sf.iat(1) //returns 2\n     * sf.iat(2) //returns 3\n     * ```\n    */\n    Series.prototype.iat = function (row) {\n        if (typeof row === 'string') {\n            throw new Error('ParamError: row index must be an integer. Use .at to get a row by label.');\n        }\n        return this.values[row];\n    };\n    /**\n     * Access a single value for a row label.\n     * Similar to loc, in that both provide label-based lookups.\n     * Use at if you only need to get or set a single value in a Series.\n     * @param row Row label of the value to access.\n     * @example\n     * ```\n     * const sf = new Series([1, 2, 3, 4, 5, 6], { index: ['A', 'B', 'C', 'D', 'E', 'F'] })\n     * sf.at('A') //returns 1\n     * sf.at('B') //returns 2\n     * sf.at('C') //returns 3\n     * ```\n    */\n    Series.prototype.at = function (row) {\n        if (typeof row !== 'string') {\n            throw new Error('ParamError: row index must be a string. Use .iat to get a row by index.');\n        }\n        return this.values[this.index.indexOf(row)];\n    };\n    /**\n     * Exposes functions for creating charts from a DataFrame.\n     * Charts are created using the Plotly.js library, so all Plotly's configuration parameters are available.\n     * @param divId name of the HTML Div to render the chart in.\n    */\n    Series.prototype.plot = function (divId) {\n        //TODO: Add support for check plot library to use. So we can support other plot library like d3, vega, etc\n        if (utils.isBrowserEnv()) {\n            var plt = new plotting_1.PlotlyLib(this, divId);\n            return plt;\n        }\n        else {\n            throw new Error(\"Not supported in NodeJS\");\n        }\n    };\n    return Series;\n}(generic_1.default));\nexports.default = Series;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../../core/frame\"));\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Generate one-hot encoding for categorical columns in an Array, Series or Dataframe.\n * @param data Series or Dataframe\n * @param columns Columns to encode\n * @param prefix Prefix for the new columns\n * @param prefixSeparator Separator for the prefix and the column name\n * @returns Encoded Dataframe\n * @example\n * import { DataFrame, DummyEncoder }from 'danfojs';\n * const df = new DataFrame([[1,2,3], [4,5,6]], { columns: ['a', 'b', 'c'] });\n * const df2 = new DummyEncoder({data: df, columns: ['a', 'b'], prefix: 'enc', prefixSeparator: '#'}).encode();\n * df2.print();\n */\nfunction dummyEncode(data, options) {\n    var _a = __assign({ columns: null, prefix: null, prefixSeparator: \"_\" }, options), columns = _a.columns, prefix = _a.prefix, prefixSeparator = _a.prefixSeparator;\n    if (!data) {\n        throw new Error('ParamError: data must be one of Array, Series or DataFrame');\n    }\n    if (data instanceof series_1.default || data instanceof frame_1.default) {\n        if (!columns) {\n            var colsWithStringDtype_1 = [];\n            data.dtypes.forEach(function (dtype, index) {\n                if (dtype === \"string\") {\n                    colsWithStringDtype_1.push(data.columns[index]);\n                }\n            });\n            columns = colsWithStringDtype_1;\n        }\n    }\n    else {\n        throw new Error('ParamError: data must be one of Array, Series or DataFrame');\n    }\n    if (typeof columns === \"string\") {\n        columns = [columns];\n        if (Array.isArray(prefix) && prefix.length === 1) {\n            prefix = prefix;\n        }\n        else if (typeof prefix === \"string\") {\n            prefix = [prefix];\n        }\n        else {\n            throw new Error('ParamError: prefix must be a string, or an array of same length as columns');\n        }\n        if (Array.isArray(prefixSeparator) && prefixSeparator.length === 1) {\n            prefixSeparator = prefixSeparator;\n        }\n        else if (typeof prefixSeparator === \"string\") {\n            prefixSeparator = [prefixSeparator];\n        }\n        else {\n            throw new Error('ParamError: prefix must be a string, or an array of same length as columns');\n        }\n    }\n    else if (Array.isArray(columns)) {\n        if (prefix) {\n            if (Array.isArray(prefix) && prefix.length !== columns.length) {\n                throw new Error(\"ParamError: prefix and data array must be of the same length. If you need to use the same prefix, then pass a string param instead. e.g {prefix: \\\"\" + prefix + \"\\\"}\");\n            }\n            if (typeof prefix === \"string\") {\n                prefix = columns.map(function (_) { return prefix; });\n            }\n        }\n        if (prefixSeparator) {\n            if (Array.isArray(prefixSeparator) && prefixSeparator.length !== columns.length) {\n                throw new Error(\"ParamError: prefixSeparator and data array must be of the same length. If you need to use the same prefix separator, then pass a string param instead. e.g {prefixSeparator: \\\"\" + prefixSeparator + \"\\\"}\");\n            }\n            if (typeof prefixSeparator === \"string\") {\n                prefixSeparator = columns.map(function (_) { return prefixSeparator; });\n            }\n        }\n    }\n    else {\n        throw new Error('ParamError: columns must be a string or an array of strings');\n    }\n    if (data instanceof series_1.default) {\n        var colData = data.values;\n        var newColumnNames = [];\n        var uniqueValues = Array.from(new Set(colData));\n        var oneHotArr = utils.zeros(colData.length, uniqueValues.length);\n        for (var i = 0; i < colData.length; i++) {\n            var index = uniqueValues.indexOf(colData[i]);\n            oneHotArr[i][index] = 1;\n        }\n        for (var i = 0; i < uniqueValues.length; i++) {\n            var prefixToAdd = prefix ? prefix[0] : i;\n            newColumnNames.push(\"\" + prefixToAdd + prefixSeparator[0] + uniqueValues[i]);\n        }\n        return new frame_1.default(oneHotArr, { columns: newColumnNames });\n    }\n    else {\n        var dfWithSelectedColumnsDropped = data.drop({ columns: columns });\n        var newData = dfWithSelectedColumnsDropped === null || dfWithSelectedColumnsDropped === void 0 ? void 0 : dfWithSelectedColumnsDropped.values;\n        var newColumnNames = dfWithSelectedColumnsDropped === null || dfWithSelectedColumnsDropped === void 0 ? void 0 : dfWithSelectedColumnsDropped.columns;\n        for (var i = 0; i < columns.length; i++) {\n            var column = columns[i];\n            var colData = data.column(column).values;\n            var uniqueValues = Array.from(new Set(colData));\n            var oneHotArr = utils.zeros(colData.length, uniqueValues.length);\n            for (var j = 0; j < colData.length; j++) {\n                var index = uniqueValues.indexOf(colData[j]);\n                oneHotArr[j][index] = 1;\n                var prefixToAdd = prefix ? prefix[i] : column;\n                var newColName = \"\" + prefixToAdd + prefixSeparator[i] + colData[j];\n                if (!newColumnNames.includes(newColName)) {\n                    newColumnNames.push(newColName);\n                }\n            }\n            for (var k = 0; k < newData.length; k++) {\n                newData[k] = __spreadArray(__spreadArray([], newData[k], true), oneHotArr[k], true);\n            }\n        }\n        return new frame_1.default(newData, { columns: newColumnNames });\n    }\n}\nexports.default = dummyEncode;\n","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar dummy_encoder_1 = __importDefault(require(\"../transformers/encoders/dummy.encoder\"));\nvar mathjs_1 = require(\"mathjs\");\nvar tensorflowlib_1 = __importDefault(require(\"../shared/tensorflowlib\"));\nvar defaults_1 = require(\"../shared/defaults\");\nvar groupby_1 = __importDefault(require(\"../aggregators/groupby\"));\nvar errors_1 = __importDefault(require(\"../shared/errors\"));\nvar indexing_1 = require(\"./indexing\");\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar generic_1 = __importDefault(require(\"./generic\"));\nvar table_1 = require(\"table\");\nvar series_1 = __importDefault(require(\"./series\"));\nvar plotting_1 = require(\"../../danfojs-base/plotting\");\nvar utils = new utils_1.default();\n/**\n * Two-dimensional ndarray with axis labels.\n * The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index.\n * Operations between DataFrame (+, -, /, , *) align values based on their associated index values they need not be the same length.\n * @param data 2D Array, JSON, Tensor, Block of data.\n * @param options.index Array of numeric or string names for subseting array. If not specified, indexes are auto generated.\n * @param options.columns Array of column names. If not specified, column names are auto generated.\n * @param options.dtypes Array of data types for each the column. If not specified, dtypes are/is inferred.\n * @param options.config General configuration object for extending or setting NDframe behavior.\n */\nvar DataFrame = /** @class */ (function (_super) {\n    __extends(DataFrame, _super);\n    function DataFrame(data, options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        var index = options.index, columns = options.columns, dtypes = options.dtypes, config = options.config;\n        _this = _super.call(this, { data: data, index: index, columns: columns, dtypes: dtypes, config: config, isSeries: false }) || this;\n        _this.$setInternalColumnDataProperty();\n        return _this;\n    }\n    /**\n     * Maps all column names to their corresponding data, and return them as Series objects.\n     * This makes column subsetting works. E.g this can work ==> `df[\"col1\"]`\n     * @param column Optional, a single column name to map\n     */\n    DataFrame.prototype.$setInternalColumnDataProperty = function (column) {\n        var self = this;\n        if (column && typeof column === \"string\") {\n            Object.defineProperty(self, column, {\n                get: function () {\n                    return self.$getColumnData(column);\n                },\n                set: function (arr) {\n                    self.$setColumnData(column, arr);\n                }\n            });\n        }\n        else {\n            var columns = this.columns;\n            var _loop_1 = function (i) {\n                var column_1 = columns[i];\n                Object.defineProperty(this_1, column_1, {\n                    get: function () {\n                        return self.$getColumnData(column_1);\n                    },\n                    set: function (arr) {\n                        self.$setColumnData(column_1, arr);\n                    }\n                });\n            };\n            var this_1 = this;\n            for (var i = 0; i < columns.length; i++) {\n                _loop_1(i);\n            }\n        }\n    };\n    /**\n     * Returns the column data from the DataFrame by column name.\n     * @param column column name to get the column data\n     * @param returnSeries Whether to return the data in series format or not. Defaults to true\n     */\n    DataFrame.prototype.$getColumnData = function (column, returnSeries) {\n        if (returnSeries === void 0) { returnSeries = true; }\n        var columnIndex = this.columns.indexOf(column);\n        if (columnIndex == -1) {\n            errors_1.default.throwColumnNotFoundError(this);\n        }\n        var dtypes = [this.$dtypes[columnIndex]];\n        var index = __spreadArray([], this.$index, true);\n        var columns = [column];\n        var config = __assign({}, this.$config);\n        if (this.$config.isLowMemoryMode) {\n            var data = [];\n            for (var i = 0; i < this.values.length; i++) {\n                var row = this.values[i];\n                data.push(row[columnIndex]);\n            }\n            if (returnSeries) {\n                return new series_1.default(data, {\n                    dtypes: dtypes,\n                    index: index,\n                    columns: columns,\n                    config: config\n                });\n            }\n            else {\n                return data;\n            }\n        }\n        else {\n            var data = this.$dataIncolumnFormat[columnIndex];\n            if (returnSeries) {\n                return new series_1.default(data, {\n                    dtypes: dtypes,\n                    index: index,\n                    columns: columns,\n                    config: config\n                });\n            }\n            else {\n                return data;\n            }\n        }\n    };\n    /**\n     * Updates the internal column data via column name.\n     * @param column The name of the column to update.\n     * @param arr The new column data\n     */\n    DataFrame.prototype.$setColumnData = function (column, arr) {\n        var columnIndex = this.$columns.indexOf(column);\n        if (columnIndex == -1) {\n            throw new Error(\"ParamError: column \" + column + \" not found in \" + this.$columns + \". If you need to add a new column, use the df.addColumn method. \");\n        }\n        var colunmValuesToAdd;\n        if (arr instanceof series_1.default) {\n            colunmValuesToAdd = arr.values;\n        }\n        else if (Array.isArray(arr)) {\n            colunmValuesToAdd = arr;\n        }\n        else {\n            throw new Error(\"ParamError: specified value not supported. It must either be an Array or a Series of the same length\");\n        }\n        if (colunmValuesToAdd.length !== this.shape[0]) {\n            errors_1.default.throwColumnLengthError(this, colunmValuesToAdd.length);\n        }\n        if (this.$config.isLowMemoryMode) {\n            //Update row ($data) array\n            for (var i = 0; i < this.$data.length; i++) {\n                this.$data[i][columnIndex] = colunmValuesToAdd[i];\n            }\n            //Update the dtypes\n            this.$dtypes[columnIndex] = utils.inferDtype(colunmValuesToAdd)[0];\n        }\n        else {\n            //Update row ($data) array\n            for (var i = 0; i < this.values.length; i++) {\n                this.$data[i][columnIndex] = colunmValuesToAdd[i];\n            }\n            //Update column ($dataIncolumnFormat) array since it's available in object\n            this.$dataIncolumnFormat[columnIndex] = arr;\n            //Update the dtypes\n            this.$dtypes[columnIndex] = utils.inferDtype(colunmValuesToAdd)[0];\n        }\n    };\n    /**\n     * Return data with missing values removed from a specified axis\n     * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n    */\n    DataFrame.prototype.$getDataByAxisWithMissingValuesRemoved = function (axis) {\n        var oldValues = this.$getDataArraysByAxis(axis);\n        var cleanValues = [];\n        for (var i = 0; i < oldValues.length; i++) {\n            var values = oldValues[i];\n            cleanValues.push(utils.removeMissingValuesFromArray(values));\n        }\n        return cleanValues;\n    };\n    /**\n     * Return data aligned to the specified axis. Transposes the array if needed.\n     * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n    */\n    DataFrame.prototype.$getDataArraysByAxis = function (axis) {\n        if (axis === 1) {\n            return this.values;\n        }\n        else {\n            var dfValues = void 0;\n            if (this.config.isLowMemoryMode) {\n                dfValues = utils.transposeArray(this.values);\n            }\n            else {\n                dfValues = this.$dataIncolumnFormat;\n            }\n            return dfValues;\n        }\n    };\n    /*\n    * checks if DataFrame is compactible for arithmetic operation\n    * compatible Dataframe must have only numerical dtypes\n    **/\n    DataFrame.prototype.$frameIsNotCompactibleForArithmeticOperation = function () {\n        var dtypes = this.dtypes;\n        var str = function (element) { return element == \"string\"; };\n        return dtypes.some(str);\n    };\n    /**\n     * Return Tensors in the right axis for math operations.\n     * @param other DataFrame or Series or number or array\n     * @param axis 0 or 1. If 0, column-wise, if 1, row-wise\n     * */\n    DataFrame.prototype.$getTensorsForArithmeticOperationByAxis = function (other, axis) {\n        if (typeof other === \"number\") {\n            return [this.tensor, tensorflowlib_1.default.scalar(other)];\n        }\n        else if (other instanceof DataFrame) {\n            return [this.tensor, other.tensor];\n        }\n        else if (other instanceof series_1.default) {\n            if (axis === 0) {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other.values, [other.shape[0], 1])];\n            }\n            else {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other.values, [other.shape[0], 1]).transpose()];\n            }\n        }\n        else if (Array.isArray(other)) {\n            if (axis === 0) {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other, [other.length, 1])];\n            }\n            else {\n                return [this.tensor, tensorflowlib_1.default.tensor2d(other, [other.length, 1]).transpose()];\n            }\n        }\n        else {\n            throw new Error(\"ParamError: Invalid type for other parameter. other must be one of Series, DataFrame or number.\");\n        }\n    };\n    /**\n     * Returns the dtype for a given column name\n     * @param column\n     */\n    DataFrame.prototype.$getColumnDtype = function (column) {\n        var columnIndex = this.columns.indexOf(column);\n        if (columnIndex === -1) {\n            throw Error(\"ColumnNameError: Column \\\"\" + column + \"\\\" does not exist\");\n        }\n        return this.dtypes[columnIndex];\n    };\n    DataFrame.prototype.$logicalOps = function (tensors, operation) {\n        var newValues = [];\n        switch (operation) {\n            case 'gt':\n                newValues = tensors[0].greater(tensors[1]).arraySync();\n                break;\n            case 'lt':\n                newValues = tensors[0].less(tensors[1]).arraySync();\n                break;\n            case 'ge':\n                newValues = tensors[0].greaterEqual(tensors[1]).arraySync();\n                break;\n            case 'le':\n                newValues = tensors[0].lessEqual(tensors[1]).arraySync();\n                break;\n            case 'eq':\n                newValues = tensors[0].equal(tensors[1]).arraySync();\n                break;\n            case 'ne':\n                newValues = tensors[0].notEqual(tensors[1]).arraySync();\n                break;\n        }\n        var newData = utils.mapIntegersToBooleans(newValues, 2);\n        return new DataFrame(newData, {\n            index: __spreadArray([], this.index, true),\n            columns: __spreadArray([], this.columns, true),\n            dtypes: __spreadArray([], this.dtypes, true),\n            config: __assign({}, this.config)\n        });\n    };\n    DataFrame.prototype.$MathOps = function (tensors, operation, inplace) {\n        var tensorResult;\n        switch (operation) {\n            case 'add':\n                tensorResult = tensors[0].add(tensors[1]);\n                break;\n            case 'sub':\n                tensorResult = tensors[0].sub(tensors[1]);\n                break;\n            case 'pow':\n                tensorResult = tensors[0].pow(tensors[1]);\n                break;\n            case 'div':\n                tensorResult = tensors[0].div(tensors[1]);\n                break;\n            case 'divNoNan':\n                tensorResult = tensors[0].divNoNan(tensors[1]);\n                break;\n            case 'mul':\n                tensorResult = tensors[0].mul(tensors[1]);\n                break;\n            case 'mod':\n                tensorResult = tensors[0].mod(tensors[1]);\n                break;\n        }\n        if (inplace) {\n            var newData = tensorResult === null || tensorResult === void 0 ? void 0 : tensorResult.arraySync();\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(tensorResult, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n    * Purely integer-location based indexing for selection by position.\n    * ``.iloc`` is primarily integer position based (from ``0`` to\n    * ``length-1`` of the axis), but may also be used with a boolean array.\n    *\n    * @param rows Array of row indexes\n    * @param columns Array of column indexes\n    *\n    * Allowed inputs are in rows and columns params are:\n    *\n    * - An array of single integer, e.g. ``[5]``.\n    * - A list or array of integers, e.g. ``[4, 3, 0]``.\n    * - A slice array string with ints, e.g. ``[\"1:7\"]``.\n    * - A boolean array.\n    * - A ``callable`` function with one argument (the calling Series or\n    * DataFrame) and that returns valid output for indexing (one of the above).\n    * This is useful in method chains, when you don't have a reference to the\n    * calling object, but would like to base your selection on some value.\n    *\n    * ``.iloc`` will raise ``IndexError`` if a requested indexer is\n    * out-of-bounds.\n    *\n    * @example\n    * ```\n    * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n    * const df2 = df.iloc({ rows: [1], columns: [\"A\"] })\n    * ```\n    */\n    DataFrame.prototype.iloc = function (_a) {\n        var rows = _a.rows, columns = _a.columns;\n        return (0, indexing_1._iloc)({ ndFrame: this, rows: rows, columns: columns });\n    };\n    /**\n     * Access a group of rows and columns by label(s) or a boolean array.\n     * ``loc`` is primarily label based, but may also be used with a boolean array.\n     *\n     * @param rows Array of row indexes\n     * @param columns Array of column indexes\n     *\n     * Allowed inputs are:\n     *\n     * - A single label, e.g. ``[\"5\"]`` or ``['a']``, (note that ``5`` is interpreted as a\n     *   *label* of the index, and **never** as an integer position along the index).\n     *\n     * - A list or array of labels, e.g. ``['a', 'b', 'c']``.\n     *\n     * - A slice object with labels, e.g. ``[\"a:f\"]``. Note that start and the stop are included\n     *\n     * - A boolean array of the same length as the axis being sliced,\n     * e.g. ``[True, False, True]``.\n     *\n     * - A ``callable`` function with one argument (the calling Series or\n     * DataFrame) and that returns valid output for indexing (one of the above)\n    * @example\n    * ```\n    * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n    * const df2 = df.loc({ rows: [1], columns: [\"A\"] })\n    * ```\n    */\n    DataFrame.prototype.loc = function (_a) {\n        var rows = _a.rows, columns = _a.columns;\n        return (0, indexing_1._loc)({ ndFrame: this, rows: rows, columns: columns });\n    };\n    /**\n     * Prints DataFrame to console as a formatted grid of row and columns.\n    */\n    DataFrame.prototype.toString = function () {\n        var maxRow = this.config.getMaxRow;\n        var maxColToDisplayInConsole = this.config.getTableMaxColInConsole;\n        // let data;\n        var dataArr = [];\n        var colLen = this.columns.length;\n        var header = [];\n        if (colLen > maxColToDisplayInConsole) {\n            //truncate displayed columns to fit in the console\n            var firstFourcolNames = this.columns.slice(0, 4);\n            var lastThreecolNames = this.columns.slice(colLen - 3);\n            //join columns with truncate ellipse in the middle\n            header = __spreadArray(__spreadArray(__spreadArray([\"\"], firstFourcolNames, true), [\"...\"], false), lastThreecolNames, true);\n            var subIdx = void 0;\n            var firstHalfValues = void 0;\n            var lastHalfValueS = void 0;\n            if (this.values.length > maxRow) {\n                //slice Object to show [max_rows]\n                var dfSubset1 = this.iloc({\n                    rows: [\"0:\" + maxRow],\n                    columns: [\"0:4\"]\n                });\n                var dfSubset2 = this.iloc({\n                    rows: [\"0:\" + maxRow],\n                    columns: [colLen - 3 + \":\"]\n                });\n                subIdx = this.index.slice(0, maxRow);\n                firstHalfValues = dfSubset1.values;\n                lastHalfValueS = dfSubset2.values;\n            }\n            else {\n                var dfSubset1 = this.iloc({ columns: [\"0:4\"] });\n                var dfSubset2 = this.iloc({ columns: [colLen - 3 + \":\"] });\n                subIdx = this.index.slice(0, maxRow);\n                firstHalfValues = dfSubset1.values;\n                lastHalfValueS = dfSubset2.values;\n            }\n            // merge subset \n            for (var i = 0; i < subIdx.length; i++) {\n                var idx = subIdx[i];\n                var row = __spreadArray(__spreadArray(__spreadArray([idx], firstHalfValues[i], true), [\"...\"], false), lastHalfValueS[i], true);\n                dataArr.push(row);\n            }\n        }\n        else {\n            //display all columns\n            header = __spreadArray([\"\"], this.columns, true);\n            var subIdx = void 0;\n            var values = void 0;\n            if (this.values.length > maxRow) {\n                //slice Object to show a max of [max_rows]\n                var data = this.iloc({ rows: [\"0:\" + maxRow] });\n                subIdx = data.index;\n                values = data.values;\n            }\n            else {\n                values = this.values;\n                subIdx = this.index;\n            }\n            // merge subset \n            for (var i = 0; i < subIdx.length; i++) {\n                var idx = subIdx[i];\n                var row = __spreadArray([idx], values[i], true);\n                dataArr.push(row);\n            }\n        }\n        var columnsConfig = {};\n        columnsConfig[0] = { width: 10 }; //set column width for index column\n        for (var index = 1; index < header.length; index++) {\n            columnsConfig[index] = { width: 17, truncate: 16 };\n        }\n        var tableData = __spreadArray([header], dataArr, true); //Adds the column names to values before printing\n        return (0, table_1.table)(tableData, __assign({ columns: columnsConfig }, this.config.getTableDisplayConfig));\n    };\n    /**\n      * Returns the first n values in a DataFrame\n      * @param rows The number of rows to return\n      * @example\n      * ```\n      * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n      * const df2 = df.head(1)\n      * ```\n    */\n    DataFrame.prototype.head = function (rows) {\n        if (rows === void 0) { rows = 5; }\n        if (rows <= 0) {\n            throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n        }\n        if (this.shape[0] <= rows) {\n            return this.copy();\n        }\n        if (this.shape[0] - rows < 0) {\n            throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n        }\n        return this.iloc({ rows: [\"0:\" + rows] });\n    };\n    /**\n      * Returns the last n values in a DataFrame\n      * @param rows The number of rows to return\n      * @example\n      * ```\n      * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n      * const df2 = df.tail(1)\n      * ```\n    */\n    DataFrame.prototype.tail = function (rows) {\n        if (rows === void 0) { rows = 5; }\n        if (rows <= 0) {\n            throw new Error(\"ParamError: Number of rows cannot be less than 1\");\n        }\n        if (this.shape[0] <= rows) {\n            return this.copy();\n        }\n        if (this.shape[0] - rows < 0) {\n            throw new Error(\"ParamError: Number of rows cannot be greater than available rows in data\");\n        }\n        rows = this.shape[0] - rows;\n        return this.iloc({ rows: [rows + \":\"] });\n    };\n    /**\n     * Gets n number of random rows in a dataframe. Sample is reproducible if seed is provided.\n     * @param num The number of rows to return. Default to 5.\n     * @param options.seed An integer specifying the random seed that will be used to create the distribution.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * const df2 = await df.sample(1)\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * const df2 = await df.sample(1, { seed: 1 })\n     * ```\n    */\n    DataFrame.prototype.sample = function (num, options) {\n        if (num === void 0) { num = 5; }\n        return __awaiter(this, void 0, void 0, function () {\n            var seed, shuffledIndex, df;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        seed = __assign({ seed: 1 }, options).seed;\n                        if (num > this.shape[0]) {\n                            throw new Error(\"ParamError: Sample size cannot be bigger than number of rows\");\n                        }\n                        if (num <= 0) {\n                            throw new Error(\"ParamError: Sample size cannot be less than 1\");\n                        }\n                        return [4 /*yield*/, tensorflowlib_1.default.data.array(this.index).shuffle(num, \"\" + seed).take(num).toArray()];\n                    case 1:\n                        shuffledIndex = _a.sent();\n                        df = this.iloc({ rows: shuffledIndex });\n                        return [2 /*return*/, df];\n                }\n            });\n        });\n    };\n    DataFrame.prototype.add = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: add operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"add\", inplace);\n    };\n    DataFrame.prototype.sub = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: sub operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"sub\", inplace);\n    };\n    DataFrame.prototype.mul = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mul operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"mul\", inplace);\n    };\n    DataFrame.prototype.div = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: div operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"div\", inplace);\n    };\n    DataFrame.prototype.divNoNan = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: div operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"divNoNan\", inplace);\n    };\n    DataFrame.prototype.pow = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: pow operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"pow\", inplace);\n    };\n    DataFrame.prototype.mod = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mod operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$MathOps(tensors, \"mod\", inplace);\n    };\n    /**\n     * Return mean of DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the mean column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * df.mean().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B'] })\n     * df.mean({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.mean = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mean operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return arr.reduce(function (a, b) { return a + b; }, 0) / arr.length; });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return median of DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the median column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n     * df.median().print()\n     * ```\n    */\n    DataFrame.prototype.median = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: median operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return (0, mathjs_1.median)(arr); });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return mode of DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the mode column-wise, if 1, row-wise. Defaults to 1\n     * @param options.keep If there are more than one modes, returns the mode at position [keep]. Defaults to 0\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n     * df.mode().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2, 4], [3, 4, 5], [6, 7, 8]], { columns: ['A', 'B', 'C'] });\n     * df.mode({ keep: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.mode = function (options) {\n        var _a = __assign({ axis: 1, keep: 0 }, options), axis = _a.axis, keep = _a.keep;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: mode operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) {\n            var tempMode = (0, mathjs_1.mode)(arr);\n            if (tempMode.length === 1) {\n                return tempMode[0];\n            }\n            else {\n                return tempMode[keep];\n            }\n        });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return minimum of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the minimum value column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.min().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.min({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.min = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: min operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) {\n            var smallestValue = arr[0];\n            for (var i = 0; i < arr.length; i++) {\n                smallestValue = smallestValue < arr[i] ? smallestValue : arr[i];\n            }\n            return smallestValue;\n        });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return maximum of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the maximum column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.max().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.max({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.max = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: max operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) {\n            var biggestValue = arr[0];\n            for (var i = 0; i < arr.length; i++) {\n                biggestValue = biggestValue > arr[i] ? biggestValue : arr[i];\n            }\n            return biggestValue;\n        });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return standard deviation of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the standard deviation column-wise, if 1, row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.std().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.std({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.std = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: std operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return (0, mathjs_1.std)(arr); });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return variance of values in a DataFrame across specified axis.\n     * @param options.axis 0 or 1. If 0, compute the variance column-wise, if 1, add row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.var().print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.var({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.var = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: var operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return (0, mathjs_1.variance)(arr); });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Get Less than of dataframe and other, element-wise (binary operator lt).\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.lt(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.lt([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.lt(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.lt = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: lt operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"lt\");\n    };\n    /**\n     * Returns \"greater than\" of dataframe and other.\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.gt(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.gt([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.gt(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.gt = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: gt operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"gt\");\n    };\n    /**\n     * Returns \"equals to\" of dataframe and other.\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.eq(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.eq([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.eq(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.eq = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: eq operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"eq\");\n    };\n    /**\n     * Returns \"not equal to\" of dataframe and other.\n     * @param other DataFrame, Series, Array or Scalar number to compare with\n     * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ne(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ne([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.ne(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.ne = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: ne operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"ne\");\n    };\n    /**\n    * Returns \"less than or equal to\" of dataframe and other.\n    * @param other DataFrame, Series, Array or Scalar number to compare with\n    * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.le(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.le([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.le(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.le = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: le operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"le\");\n    };\n    /**\n    * Returns \"greater than or equal to\" between dataframe and other.\n    * @param other DataFrame, Series, Array or Scalar number to compare with\n    * @param options.axis 0 or 1. If 0, add column-wise, if 1, add row-wise\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ge(2).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.ge([2, 3], { axis: 0 }).print()\n     * ```\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = new Series([2, 3])\n     * df.ge(sf, { axis: 1 }).print()\n     * ```\n    */\n    DataFrame.prototype.ge = function (other, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: ge operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n        return this.$logicalOps(tensors, \"ge\");\n    };\n    /**\n     * Return number of non-null elements in a Series\n     * @param options.axis 0 or 1. If 0, count column-wise, if 1, add row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.count().print()\n     * ```\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.count({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.count = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newData = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var resultArr = newData.map(function (arr) { return arr.length; });\n        if (axis === 0) {\n            return new series_1.default(resultArr, { index: this.columns });\n        }\n        else {\n            return new series_1.default(resultArr, { index: this.index });\n        }\n    };\n    /**\n     * Return the sum of values across an axis.\n     * @param options.axis 0 or 1. If 0, count column-wise, if 1, add row-wise. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.sum().print()\n     * ```\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.sum({ axis: 0 }).print()\n     * ```\n    */\n    DataFrame.prototype.sum = function (options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var result = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var sumArr = result.map(function (innerArr) {\n            return innerArr.reduce(function (a, b) { return Number(a) + Number(b); }, 0);\n        });\n        if (axis === 0) {\n            return new series_1.default(sumArr, {\n                index: __spreadArray([], this.columns, true)\n            });\n        }\n        else {\n            return new series_1.default(sumArr, {\n                index: __spreadArray([], this.index, true)\n            });\n        }\n    };\n    DataFrame.prototype.pctChange = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: pctChange operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        if (other === 0) {\n            return this;\n        }\n        if (typeof other === \"number\") {\n            var origDF = this.copy();\n            if (axis === 0) {\n                origDF = origDF.T;\n            }\n            var originalTensor = origDF.tensor.clone();\n            var unit = new Array(originalTensor.shape[originalTensor.rank - 1]).fill(NaN);\n            var pctArray = originalTensor.arraySync();\n            if (other > 0) {\n                for (var i = 0; i < other; i++) {\n                    pctArray.unshift(unit);\n                    pctArray.pop();\n                }\n            }\n            else if (other < 0) {\n                for (var i = 0; i > other; i--) {\n                    pctArray.push(unit);\n                    pctArray.shift();\n                }\n            }\n            var pctTensor = tensorflowlib_1.default.tensor2d(pctArray, originalTensor.shape);\n            var pctDF = this.$MathOps([originalTensor, pctTensor], \"divNoNan\", inplace).sub(1);\n            if (axis === 0) {\n                return pctDF.T;\n            }\n            return pctDF;\n        }\n        if (other instanceof DataFrame || other instanceof series_1.default) {\n            var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n            var pctDF = this.$MathOps(tensors, \"divNoNan\", inplace).sub(1);\n            return pctDF;\n        }\n    };\n    DataFrame.prototype.diff = function (other, options) {\n        var _a = __assign({ inplace: false, axis: 1 }, options), inplace = _a.inplace, axis = _a.axis;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: diff operation is not supported for string dtypes\");\n        }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        if (other === 0) {\n            return this;\n        }\n        if (typeof other === \"number\") {\n            var origDF = this.copy();\n            if (axis === 0) {\n                origDF = origDF.T;\n            }\n            var originalTensor = origDF.tensor.clone();\n            var unit = new Array(originalTensor.shape[originalTensor.rank - 1]).fill(NaN);\n            var diffArray = originalTensor.arraySync();\n            if (other > 0) {\n                for (var i = 0; i < other; i++) {\n                    diffArray.unshift(unit);\n                    diffArray.pop();\n                }\n            }\n            else if (other < 0) {\n                for (var i = 0; i > other; i--) {\n                    diffArray.push(unit);\n                    diffArray.shift();\n                }\n            }\n            var diffTensor = tensorflowlib_1.default.tensor2d(diffArray, originalTensor.shape);\n            var diffDF = this.$MathOps([originalTensor, diffTensor], \"sub\", inplace);\n            if (axis === 0) {\n                return diffDF.T;\n            }\n            return diffDF;\n        }\n        if (other instanceof DataFrame || other instanceof series_1.default) {\n            var tensors = this.$getTensorsForArithmeticOperationByAxis(other, axis);\n            return this.$MathOps(tensors, \"sub\", inplace);\n        }\n    };\n    DataFrame.prototype.abs = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newData = this.values.map(function (arr) { return arr.map(function (val) { return Math.abs(val); }); });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.round = function (dp, options) {\n        if (dp === void 0) { dp = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (this.$frameIsNotCompactibleForArithmeticOperation()) {\n            throw Error(\"TypeError: round operation is not supported for string dtypes\");\n        }\n        if (typeof dp !== \"number\") {\n            throw Error(\"ParamError: dp must be a number\");\n        }\n        var newData = utils.round(this.values, dp, false);\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.cumProd = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"prod\", axis, inplace);\n    };\n    DataFrame.prototype.cumSum = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"sum\", axis, inplace);\n    };\n    DataFrame.prototype.cumMin = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"min\", axis, inplace);\n    };\n    DataFrame.prototype.cumMax = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        return this.cumOps(\"max\", axis, inplace);\n    };\n    DataFrame.prototype.cumOps = function (ops, axis, inplace) {\n        if (this.dtypes.includes(\"string\"))\n            errors_1.default.throwStringDtypeOperationError(ops);\n        var result = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var newData = result.map(function (sData) {\n            var tempval = sData[0];\n            var data = [tempval];\n            for (var i = 1; i < sData.length; i++) {\n                var currVal = sData[i];\n                switch (ops) {\n                    case \"max\":\n                        if (currVal > tempval) {\n                            data.push(currVal);\n                            tempval = currVal;\n                        }\n                        else {\n                            data.push(tempval);\n                        }\n                        break;\n                    case \"min\":\n                        if (currVal < tempval) {\n                            data.push(currVal);\n                            tempval = currVal;\n                        }\n                        else {\n                            data.push(tempval);\n                        }\n                        break;\n                    case \"sum\":\n                        tempval = tempval + currVal;\n                        data.push(tempval);\n                        break;\n                    case \"prod\":\n                        tempval = tempval * currVal;\n                        data.push(tempval);\n                        break;\n                }\n            }\n            return data;\n        });\n        if (axis === 0) {\n            newData = utils.transposeArray(newData);\n        }\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n     * Generate descriptive statistics for all numeric columns.\n     * Descriptive statistics include those that summarize the central tendency,\n     * dispersion and shape of a datasets distribution, excluding NaN values.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.describe().print()\n     * ```\n     */\n    DataFrame.prototype.describe = function () {\n        var _this = this;\n        var numericColumnNames = this.columns.filter(function (name) { return _this.$getColumnDtype(name) !== \"string\"; });\n        var index = [\"count\", \"mean\", \"std\", \"min\", \"median\", \"max\", \"variance\"];\n        var statsObject = {};\n        for (var i = 0; i < numericColumnNames.length; i++) {\n            var colName = numericColumnNames[i];\n            var $count = this.$getColumnData(colName).count();\n            var $mean = (0, mathjs_1.mean)(this.$getColumnData(colName, false));\n            var $std = (0, mathjs_1.std)(this.$getColumnData(colName, false));\n            var $min = this.$getColumnData(colName).min();\n            var $median = (0, mathjs_1.median)(this.$getColumnData(colName, false));\n            var $max = this.$getColumnData(colName).max();\n            var $variance = (0, mathjs_1.variance)(this.$getColumnData(colName, false));\n            var stats = [$count, $mean, $std, $min, $median, $max, $variance];\n            statsObject[colName] = stats;\n        }\n        var df = new DataFrame(statsObject, { index: index });\n        return df;\n    };\n    DataFrame.prototype.dropNa = function (options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: Axis must be 0 or 1\");\n        }\n        var newIndex = [];\n        if (axis == 1) {\n            var newData = [];\n            var dfValues = this.values;\n            for (var i = 0; i < dfValues.length; i++) {\n                var values = dfValues[i];\n                //@ts-ignore\n                if (!values.includes(NaN) && !values.includes(undefined) && !values.includes(null)) {\n                    newData.push(values);\n                    newIndex.push(this.index[i]);\n                }\n            }\n            if (inplace) {\n                this.$setValues(newData, false);\n                this.$setIndex(newIndex);\n            }\n            else {\n                return new DataFrame(newData, {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n        else {\n            var newColumnNames = [];\n            var newDtypes = [];\n            var dfValues = [];\n            if (this.config.isLowMemoryMode) {\n                dfValues = utils.transposeArray(this.values);\n            }\n            else {\n                dfValues = this.$dataIncolumnFormat;\n            }\n            var tempColArr = [];\n            for (var i = 0; i < dfValues.length; i++) {\n                var values = dfValues[i];\n                if (!values.includes(NaN)) {\n                    tempColArr.push(values);\n                    newColumnNames.push(this.columns[i]);\n                    newDtypes.push(this.dtypes[i]);\n                }\n            }\n            var newData = utils.transposeArray(tempColArr);\n            if (inplace) {\n                this.$setValues(newData, false, false);\n                this.$setColumnNames(newColumnNames);\n                this.$setDtypes(newDtypes);\n            }\n            else {\n                return new DataFrame(newData, {\n                    index: __spreadArray([], this.index, true),\n                    columns: newColumnNames,\n                    dtypes: newDtypes,\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n    };\n    DataFrame.prototype.addColumn = function (column, values, options) {\n        var _a = __assign({ inplace: false, atIndex: this.columns.length }, options), inplace = _a.inplace, atIndex = _a.atIndex;\n        if (typeof atIndex === \"string\") {\n            if (!(this.columns.includes(atIndex))) {\n                throw new Error(atIndex + \" not a column\");\n            }\n            atIndex = this.columns.indexOf(atIndex);\n        }\n        if (!column) {\n            throw new Error(\"ParamError: column must be specified\");\n        }\n        if (!values) {\n            throw new Error(\"ParamError: values must be specified\");\n        }\n        var columnIndex = this.$columns.indexOf(column);\n        if (columnIndex === -1) {\n            var colunmValuesToAdd = void 0;\n            if (values instanceof series_1.default) {\n                colunmValuesToAdd = values.values;\n            }\n            else if (Array.isArray(values)) {\n                colunmValuesToAdd = values;\n            }\n            else {\n                throw new Error(\"ParamError: specified value not supported. It must either be an Array or a Series of the same length\");\n            }\n            if (colunmValuesToAdd.length !== this.shape[0]) {\n                errors_1.default.throwColumnLengthError(this, colunmValuesToAdd.length);\n            }\n            var newData = [];\n            var oldValues = this.$data;\n            for (var i = 0; i < oldValues.length; i++) {\n                var innerArr = __spreadArray([], oldValues[i], true);\n                innerArr.splice(atIndex, 0, colunmValuesToAdd[i]);\n                newData.push(innerArr);\n            }\n            if (inplace) {\n                this.$setValues(newData, true, false);\n                var columns = __spreadArray([], this.columns, true);\n                columns.splice(atIndex, 0, column);\n                this.$setColumnNames(columns);\n                this.$setInternalColumnDataProperty(column);\n            }\n            else {\n                var columns = __spreadArray([], this.columns, true);\n                columns.splice(atIndex, 0, column);\n                var df = new DataFrame(newData, {\n                    index: __spreadArray([], this.index, true),\n                    columns: columns,\n                    dtypes: __spreadArray(__spreadArray([], this.dtypes, true), [utils.inferDtype(colunmValuesToAdd)[0]], false),\n                    config: __assign({}, this.$config)\n                });\n                return df;\n            }\n        }\n        else {\n            this.$setColumnData(column, values);\n        }\n    };\n    /**\n     * Makes a deep copy of a DataFrame.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const df2 = df.copy()\n     * df2.print()\n     * ```\n     */\n    DataFrame.prototype.copy = function () {\n        var df = new DataFrame(__spreadArray([], this.$data, true), {\n            columns: __spreadArray([], this.columns, true),\n            index: __spreadArray([], this.index, true),\n            dtypes: __spreadArray([], this.dtypes, true),\n            config: __assign({}, this.$config)\n        });\n        return df;\n    };\n    /**\n     * Return a boolean, same-sized object indicating where elements are empty (NaN, undefined, null).\n     * NaN, undefined and null values gets mapped to true, and everything else gets mapped to false.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.isNa().print()\n     * ```\n    */\n    DataFrame.prototype.isNa = function () {\n        var newData = [];\n        for (var i = 0; i < this.values.length; i++) {\n            var valueArr = this.values[i];\n            var tempData = valueArr.map(function (value) {\n                if (utils.isEmpty(value)) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            });\n            newData.push(tempData);\n        }\n        var df = new DataFrame(newData, {\n            index: __spreadArray([], this.index, true),\n            columns: __spreadArray([], this.columns, true),\n            config: __assign({}, this.config)\n        });\n        return df;\n    };\n    DataFrame.prototype.fillNa = function (values, options) {\n        var _this = this;\n        var _a = __assign({ inplace: false }, options), columns = _a.columns, inplace = _a.inplace;\n        if (!values && typeof values !== \"boolean\" && typeof values !== \"number\" && typeof values !== \"string\") {\n            throw Error('ParamError: value must be specified');\n        }\n        if (Array.isArray(values)) {\n            if (!Array.isArray(columns)) {\n                throw Error('ParamError: value is an array, hence columns must also be an array of same length');\n            }\n            if (values.length !== columns.length) {\n                throw Error('ParamError: specified column and values must have the same length');\n            }\n            columns.forEach(function (col) {\n                if (!_this.columns.includes(col)) {\n                    throw Error(\"ValueError: Specified column \\\"\" + col + \"\\\" must be one of \" + _this.columns);\n                }\n            });\n        }\n        var newData = [];\n        var oldValues = __spreadArray([], this.values, true);\n        if (!columns) {\n            var _loop_2 = function (i) {\n                var valueArr = __spreadArray([], oldValues[i], true);\n                var tempArr = valueArr.map(function (innerVal) {\n                    if (utils.isEmpty(innerVal)) {\n                        var replaceWith = Array.isArray(values) ? values[i] : values;\n                        return replaceWith;\n                    }\n                    else {\n                        return innerVal;\n                    }\n                });\n                newData.push(tempArr);\n            };\n            //Fill all columns\n            for (var i = 0; i < oldValues.length; i++) {\n                _loop_2(i);\n            }\n        }\n        else {\n            //Fill specific columns\n            var tempData = __spreadArray([], this.values, true);\n            for (var i = 0; i < tempData.length; i++) {\n                var valueArr = tempData[i];\n                for (var i_1 = 0; i_1 < columns.length; i_1++) { //B\n                    var columnIndex = this.columns.indexOf(columns[i_1]);\n                    var replaceWith = Array.isArray(values) ? values[i_1] : values;\n                    valueArr[columnIndex] = utils.isEmpty(valueArr[columnIndex]) ? replaceWith : valueArr[columnIndex];\n                }\n                newData.push(valueArr);\n            }\n        }\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            var df = new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n            return df;\n        }\n    };\n    DataFrame.prototype.drop = function (options) {\n        var _a = __assign({ inplace: false }, options), columns = _a.columns, index = _a.index, inplace = _a.inplace;\n        if (!columns && !index) {\n            throw Error('ParamError: Must specify one of columns or index');\n        }\n        if (columns && index) {\n            throw Error('ParamError: Can only specify one of columns or index');\n        }\n        if (columns) {\n            var columnIndices = [];\n            if (typeof columns === \"string\") {\n                columnIndices.push(this.columns.indexOf(columns));\n            }\n            else if (Array.isArray(columns)) {\n                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                    var column = columns_1[_i];\n                    if (this.columns.indexOf(column) === -1) {\n                        throw Error(\"ParamError: specified column \\\"\" + column + \"\\\" not found in columns\");\n                    }\n                    columnIndices.push(this.columns.indexOf(column));\n                }\n            }\n            else {\n                throw Error('ParamError: columns must be an array of column names or a string of column name');\n            }\n            var newRowData = [];\n            var newColumnNames = [];\n            var newDtypes = [];\n            for (var i = 0; i < this.values.length; i++) {\n                var tempInnerArr = [];\n                var innerArr = this.values[i];\n                for (var j = 0; j < innerArr.length; j++) {\n                    if (!(columnIndices.includes(j))) {\n                        tempInnerArr.push(innerArr[j]);\n                    }\n                }\n                newRowData.push(tempInnerArr);\n            }\n            for (var i = 0; i < this.columns.length; i++) {\n                var element = this.columns[i];\n                if (!(columns.includes(element))) {\n                    newColumnNames.push(element);\n                    newDtypes.push(this.dtypes[i]);\n                }\n            }\n            if (inplace) {\n                this.$setValues(newRowData, true, false);\n                this.$setColumnNames(newColumnNames);\n            }\n            else {\n                var df = new DataFrame(newRowData, {\n                    index: __spreadArray([], this.index, true),\n                    columns: newColumnNames,\n                    dtypes: newDtypes,\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n        if (index) {\n            var rowIndices = [];\n            if (typeof index === \"string\" || typeof index === \"number\" || typeof index === \"boolean\") {\n                rowIndices.push(this.index.indexOf(index));\n            }\n            else if (Array.isArray(index)) {\n                for (var _b = 0, index_1 = index; _b < index_1.length; _b++) {\n                    var indx = index_1[_b];\n                    if (this.index.indexOf(indx) === -1) {\n                        throw Error(\"ParamError: specified index \\\"\" + indx + \"\\\" not found in indices\");\n                    }\n                    rowIndices.push(this.index.indexOf(indx));\n                }\n            }\n            else {\n                throw Error('ParamError: index must be an array of indices or a scalar index');\n            }\n            var newRowData = [];\n            var newIndex = [];\n            for (var i = 0; i < this.values.length; i++) {\n                var innerArr = this.values[i];\n                if (!(rowIndices.includes(i))) {\n                    newRowData.push(innerArr);\n                }\n            }\n            for (var i = 0; i < this.index.length; i++) {\n                var indx = this.index[i];\n                if (!(index.includes(indx))) {\n                    newIndex.push(indx);\n                }\n            }\n            if (inplace) {\n                this.$setValues(newRowData, false);\n                this.$setIndex(newIndex);\n            }\n            else {\n                var df = new DataFrame(newRowData, {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n    };\n    DataFrame.prototype.sortValues = function (column, options) {\n        var _a = __assign({ ascending: true, inplace: false }, options), ascending = _a.ascending, inplace = _a.inplace;\n        if (!column) {\n            throw Error(\"ParamError: must specify a column to sort by\");\n        }\n        if (this.columns.indexOf(column) === -1) {\n            throw Error(\"ParamError: specified column \\\"\" + column + \"\\\" not found in columns\");\n        }\n        var columnValues = this.$getColumnData(column, false);\n        var index = __spreadArray([], this.index, true);\n        var objToSort = columnValues.map(function (value, i) {\n            return { index: index[i], value: value };\n        });\n        var sortedObjectArr = utils.sortObj(objToSort, ascending);\n        var sortedIndex = sortedObjectArr.map(function (obj) { return obj.index; });\n        var newDf = (0, indexing_1._loc)({ ndFrame: this, rows: sortedIndex });\n        if (inplace) {\n            this.$setValues(newDf.values);\n            this.$setIndex(newDf.index);\n        }\n        else {\n            return newDf;\n        }\n    };\n    DataFrame.prototype.setIndex = function (options) {\n        var _a = __assign({ drop: false, inplace: false }, options), index = _a.index, column = _a.column, drop = _a.drop, inplace = _a.inplace;\n        if (!index && !column) {\n            throw new Error(\"ParamError: must specify either index or column\");\n        }\n        var newIndex = [];\n        if (index) {\n            if (!Array.isArray(index)) {\n                throw Error(\"ParamError: index must be an array\");\n            }\n            if (index.length !== this.values.length) {\n                throw Error(\"ParamError: index must be the same length as the number of rows\");\n            }\n            newIndex = index;\n        }\n        if (column) {\n            if (this.columns.indexOf(column) === -1) {\n                throw Error(\"ParamError: column not found in column names\");\n            }\n            newIndex = this.$getColumnData(column, false);\n        }\n        if (drop) {\n            var dfDropped = this.drop({ columns: [column] });\n            var newData = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.values;\n            var newColumns = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.columns;\n            var newDtypes = dfDropped === null || dfDropped === void 0 ? void 0 : dfDropped.dtypes;\n            if (inplace) {\n                this.$setValues(newData, true, false);\n                this.$setIndex(newIndex);\n                this.$setColumnNames(newColumns);\n            }\n            else {\n                var df = new DataFrame(newData, {\n                    index: newIndex,\n                    columns: newColumns,\n                    dtypes: newDtypes,\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n        else {\n            if (inplace) {\n                this.$setIndex(newIndex);\n            }\n            else {\n                var df = new DataFrame(this.values, {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n                return df;\n            }\n        }\n    };\n    DataFrame.prototype.resetIndex = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (inplace) {\n            this.$resetIndex();\n        }\n        else {\n            var df = new DataFrame(this.values, {\n                index: this.index.map(function (_, i) { return i; }),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n            return df;\n        }\n    };\n    /**\n     * Apply a function along an axis of the DataFrame. To apply a function element-wise, use `applyMap`.\n     * Objects passed to the function are Series values whose\n     * index is either the DataFrames index (axis=0) or the DataFrames columns (axis=1)\n     * @param callable Function to apply to each column or row.\n     * @param options.axis 0 or 1. If 0, apply \"callable\" column-wise, else apply row-wise\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const df2 = df.apply(Math.sqrt, { axis: 0 })\n     * df2.print()\n     * ```\n    */\n    DataFrame.prototype.apply = function (callable, options) {\n        var axis = __assign({ axis: 1 }, options).axis;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: axis must be 0 or 1\");\n        }\n        var valuesForFunc = this.$getDataByAxisWithMissingValuesRemoved(axis);\n        var result = valuesForFunc.map(function (row) {\n            return callable(row);\n        });\n        if (axis === 0) {\n            if (utils.is1DArray(result)) {\n                return new series_1.default(result, {\n                    index: __spreadArray([], this.columns, true)\n                });\n            }\n            else {\n                return new DataFrame(result, {\n                    index: __spreadArray([], this.columns, true),\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n        else {\n            if (utils.is1DArray(result)) {\n                return new series_1.default(result, {\n                    index: __spreadArray([], this.index, true)\n                });\n            }\n            else {\n                return new DataFrame(result, {\n                    index: __spreadArray([], this.index, true),\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n    };\n    DataFrame.prototype.applyMap = function (callable, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newData = this.values.map(function (row) {\n            var tempData = row.map(function (val) {\n                return callable(val);\n            });\n            return tempData;\n        });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n     * Returns the specified column data as a Series object.\n     * @param column The name of the column to return\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * const sf = df.column('A')\n     * sf.print()\n     * ```\n     *\n    */\n    DataFrame.prototype.column = function (column) {\n        return this.$getColumnData(column);\n    };\n    /**\n     * Return a subset of the DataFrame based on the column dtypes.\n     * @param include An array of dtypes or strings to be included.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C']})\n     * const df2 = df.selectDtypes(['float32'])\n     * df2.print()\n     * ```\n     *\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C']})\n     * const df2 = df.selectDtypes(['float32', 'int32'])\n     * df2.print()\n     * ```\n     *\n    */\n    DataFrame.prototype.selectDtypes = function (include) {\n        var supportedDtypes = [\"float32\", \"int32\", \"string\", \"boolean\", 'undefined'];\n        if (Array.isArray(include) === false) {\n            throw Error(\"ParamError: include must be an array\");\n        }\n        include.forEach(function (dtype) {\n            if (supportedDtypes.indexOf(dtype) === -1) {\n                throw Error(\"ParamError: include must be an array of valid dtypes\");\n            }\n        });\n        var newColumnNames = [];\n        for (var i = 0; i < this.dtypes.length; i++) {\n            if (include.includes(this.dtypes[i])) {\n                newColumnNames.push(this.columns[i]);\n            }\n        }\n        return this.loc({ columns: newColumnNames });\n    };\n    DataFrame.prototype.transpose = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newData = utils.transposeArray(this.values);\n        var newColNames = __spreadArray([], this.index.map(function (i) { return i.toString(); }), true);\n        if (inplace) {\n            this.$setValues(newData, false, false);\n            this.$setIndex(__spreadArray([], this.columns, true));\n            this.$setColumnNames(newColNames);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.columns, true),\n                columns: newColNames,\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    Object.defineProperty(DataFrame.prototype, \"T\", {\n        /**\n         * Returns the Transpose of the DataFrame. Similar to `transpose`.\n         * @example\n         * ```\n         * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n         * const df2 = df.T()\n         * df2.print()\n         * ```\n        **/\n        get: function () {\n            var newData = utils.transposeArray(this.values);\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.columns, true),\n                columns: __spreadArray([], this.index.map(function (i) { return i.toString(); }), true),\n                config: __assign({}, this.config)\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DataFrame.prototype.replace = function (oldValue, newValue, options) {\n        var _this = this;\n        var _a = __assign({ inplace: false }, options), columns = _a.columns, inplace = _a.inplace;\n        if (!oldValue && typeof oldValue !== 'boolean') {\n            throw Error(\"Params Error: Must specify param 'oldValue' to replace\");\n        }\n        if (!newValue && typeof newValue !== 'boolean') {\n            throw Error(\"Params Error: Must specify param 'newValue' to replace with\");\n        }\n        var newData = [];\n        if (columns) {\n            if (!Array.isArray(columns)) {\n                throw Error(\"Params Error: column must be an array of column(s)\");\n            }\n            var columnIndex_1 = [];\n            columns.forEach(function (column) {\n                var _indx = _this.columns.indexOf(column);\n                if (_indx === -1) {\n                    throw Error(\"Params Error: column not found in columns\");\n                }\n                columnIndex_1.push(_indx);\n            });\n            newData = this.values.map(function (_a) {\n                var row = _a.slice(0);\n                for (var _i = 0, columnIndex_2 = columnIndex_1; _i < columnIndex_2.length; _i++) {\n                    var colIndx = columnIndex_2[_i];\n                    if (row[colIndx] === oldValue) {\n                        row[colIndx] = newValue;\n                    }\n                }\n                return row;\n            });\n        }\n        else {\n            newData = this.values.map(function (_a) {\n                var row = _a.slice(0);\n                return row.map((function (cell) {\n                    if (cell === oldValue) {\n                        return newValue;\n                    }\n                    else {\n                        return cell;\n                    }\n                }));\n            });\n        }\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.asType = function (column, dtype, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var columnIndex = this.columns.indexOf(column);\n        if (columnIndex === -1) {\n            throw Error(\"Params Error: column not found in columns\");\n        }\n        if (!(defaults_1.DATA_TYPES.includes(dtype))) {\n            throw Error(\"dtype \" + dtype + \" not supported. dtype must be one of \" + defaults_1.DATA_TYPES);\n        }\n        var data = this.values;\n        var newData = data.map(function (row) {\n            if (dtype === \"float32\") {\n                row[columnIndex] = Number(row[columnIndex]);\n                return row;\n            }\n            else if (dtype === \"int32\") {\n                row[columnIndex] = parseInt(row[columnIndex]);\n                return row;\n            }\n            else if (dtype === \"string\") {\n                row[columnIndex] = row[columnIndex].toString();\n                return row;\n            }\n            else if (dtype === \"boolean\") {\n                row[columnIndex] = Boolean(row[columnIndex]);\n                return row;\n            }\n        });\n        if (inplace) {\n            this.$setValues(newData);\n        }\n        else {\n            var newDtypes = __spreadArray([], this.dtypes, true);\n            newDtypes[columnIndex] = dtype;\n            return new DataFrame(newData, {\n                index: __spreadArray([], this.index, true),\n                columns: __spreadArray([], this.columns, true),\n                dtypes: newDtypes,\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    /**\n     * Return the number of unique elements in a column, across the specified axis.\n     * To get the values use `.unique()` instead.\n     * @param axis The axis to count unique elements across. Defaults to 1\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4], [1, 2], [5, 6]], { columns: ['A', 'B'] })\n     * df.nunique().print()\n     * ```\n     *\n    */\n    DataFrame.prototype.nUnique = function (axis) {\n        if (axis === void 0) { axis = 1; }\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: axis must be 0 or 1\");\n        }\n        var data = this.$getDataArraysByAxis(axis);\n        var newData = data.map(function (row) { return new Set(row).size; });\n        if (axis === 0) {\n            return new series_1.default(newData, {\n                index: __spreadArray([], this.columns, true),\n                dtypes: [\"int32\"]\n            });\n        }\n        else {\n            return new series_1.default(newData, {\n                index: __spreadArray([], this.index, true),\n                dtypes: [\"int32\"]\n            });\n        }\n    };\n    DataFrame.prototype.rename = function (mapper, options) {\n        var _a = __assign({ axis: 1, inplace: false }, options), axis = _a.axis, inplace = _a.inplace;\n        if ([0, 1].indexOf(axis) === -1) {\n            throw Error(\"ParamError: axis must be 0 or 1\");\n        }\n        if (axis === 1) {\n            var colsAdded_2 = [];\n            var newColumns = this.columns.map(function (col) {\n                if (mapper[col] !== undefined) {\n                    var newCol = \"\" + mapper[col];\n                    colsAdded_2.push(newCol);\n                    return newCol;\n                }\n                else {\n                    return col;\n                }\n            });\n            if (inplace) {\n                this.$setColumnNames(newColumns);\n                for (var _i = 0, colsAdded_1 = colsAdded_2; _i < colsAdded_1.length; _i++) {\n                    var col = colsAdded_1[_i];\n                    this.$setInternalColumnDataProperty(col);\n                }\n            }\n            else {\n                return new DataFrame(__spreadArray([], this.values, true), {\n                    index: __spreadArray([], this.index, true),\n                    columns: newColumns,\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n        else {\n            var newIndex = this.index.map(function (col) {\n                if (mapper[col] !== undefined) {\n                    return mapper[col];\n                }\n                else {\n                    return col;\n                }\n            });\n            if (inplace) {\n                this.$setIndex(newIndex);\n            }\n            else {\n                return new DataFrame(__spreadArray([], this.values, true), {\n                    index: newIndex,\n                    columns: __spreadArray([], this.columns, true),\n                    dtypes: __spreadArray([], this.dtypes, true),\n                    config: __assign({}, this.config)\n                });\n            }\n        }\n    };\n    DataFrame.prototype.sortIndex = function (options) {\n        var _this = this;\n        var _a = __assign({ ascending: true, inplace: false }, options), ascending = _a.ascending, inplace = _a.inplace;\n        var indexPosition = utils.range(0, this.index.length - 1);\n        var index = __spreadArray([], this.index, true);\n        var objToSort = index.map(function (idx, i) {\n            return { index: indexPosition[i], value: idx };\n        });\n        var sortedObjectArr = utils.sortObj(objToSort, ascending);\n        var sortedIndex = sortedObjectArr.map(function (obj) { return obj.index; });\n        var newData = sortedIndex.map(function (i) { return _this.values[i]; });\n        sortedIndex = sortedIndex.map(function (i) { return index[i]; });\n        if (inplace) {\n            this.$setValues(newData);\n            this.$setIndex(sortedIndex);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: sortedIndex,\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.append = function (newValues, index, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!newValues) {\n            throw Error(\"ParamError: newValues must be a Series, DataFrame or Array\");\n        }\n        if (!index) {\n            throw Error(\"ParamError: index must be specified\");\n        }\n        var rowsToAdd = [];\n        if (newValues instanceof series_1.default) {\n            if (newValues.values.length !== this.shape[1]) {\n                throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n            }\n            rowsToAdd = [newValues.values];\n        }\n        else if (newValues instanceof DataFrame) {\n            if (newValues.shape[1] !== this.shape[1]) {\n                throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n            }\n            rowsToAdd = newValues.values;\n        }\n        else if (Array.isArray(newValues)) {\n            if (utils.is1DArray(newValues)) {\n                rowsToAdd = [newValues];\n            }\n            else {\n                rowsToAdd = newValues;\n            }\n            if (rowsToAdd[0].length !== this.shape[1]) {\n                throw Error(\"ValueError: length of newValues must be the same as the number of columns.\");\n            }\n        }\n        else {\n            throw Error(\"ValueError: newValues must be a Series, DataFrame or Array\");\n        }\n        var indexInArrFormat = [];\n        if (!Array.isArray(index)) {\n            indexInArrFormat = [index];\n        }\n        else {\n            indexInArrFormat = index;\n        }\n        if (rowsToAdd.length !== indexInArrFormat.length) {\n            throw Error(\"ParamError: index must contain the same number of values as newValues\");\n        }\n        var newData = __spreadArray([], this.values, true);\n        var newIndex = __spreadArray([], this.index, true);\n        rowsToAdd.forEach(function (row, i) {\n            newData.push(row);\n            newIndex.push(indexInArrFormat[i]);\n        });\n        if (inplace) {\n            this.$setValues(newData);\n            this.$setIndex(newIndex);\n        }\n        else {\n            return new DataFrame(newData, {\n                index: newIndex,\n                columns: __spreadArray([], this.columns, true),\n                dtypes: __spreadArray([], this.dtypes, true),\n                config: __assign({}, this.config)\n            });\n        }\n    };\n    DataFrame.prototype.query = function (condition, options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        if (!condition) {\n            throw new Error(\"ParamError: condition must be specified\");\n        }\n        var result = (0, indexing_1._iloc)({\n            ndFrame: this,\n            rows: condition,\n        });\n        if (inplace) {\n            this.$setValues(result.values, false, false);\n            this.$setIndex(result.index);\n        }\n        else {\n            return result;\n        }\n    };\n    Object.defineProperty(DataFrame.prototype, \"ctypes\", {\n        /**\n         * Returns the data types for each column as a Series.\n         * @example\n         * ```\n         * const df = new DataFrame([[1, 2.1, \"Dog\"], [3, 4.3, \"Cat\"]], { columns: ['A', 'B', 'C'] })\n         * df.ctypes().print()\n         * ```\n         */\n        get: function () {\n            return new series_1.default(this.dtypes, { index: this.columns });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DataFrame.prototype.getDummies = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var encodedDF = (0, dummy_encoder_1.default)(this, options);\n        if (inplace) {\n            this.$setValues(encodedDF.values, false, false);\n            this.$setColumnNames(encodedDF.columns);\n        }\n        else {\n            return encodedDF;\n        }\n    };\n    /**\n     * Groupby\n     * @params col a list of column\n     * @returns Groupby\n     * @example\n     * let data = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 20, 30, 40 ], [ 39, 89, 78 ] ];\n     * let cols = [ \"A\", \"B\", \"C\" ];\n     * let df = new dfd.DataFrame(data, { columns: cols });\n     * let groupDf = df.groupby([ \"A\" ]);\n     */\n    DataFrame.prototype.groupby = function (col) {\n        var columns = this.columns;\n        var colIndex = col.map(function (val) { return columns.indexOf(val); });\n        var colDtype = this.dtypes;\n        return new groupby_1.default(col, this.values, columns, colDtype, colIndex).group();\n    };\n    /**\n     * Access a single value for a row/column pair by integer position.\n     * Similar to {@link iloc}, in that both provide integer-based lookups.\n     * Use iat if you only need to get or set a single value in a DataFrame.\n     * @param row Row index of the value to access.\n     * @param column Column index of the value to access.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.iat(0, 0) // 1\n     * df.iat(0, 1) // 2\n     * df.iat(1, 0) // 3\n     * ```\n    */\n    DataFrame.prototype.iat = function (row, column) {\n        if (typeof row === 'string' || typeof column === 'string') {\n            throw new Error('ParamError: row and column index must be an integer. Use .at to get a row or column by label.');\n        }\n        return this.values[row][column];\n    };\n    /**\n     * Access a single value for a row/column label pair.\n     * Similar to {@link loc}, in that both provide label-based lookups.\n     * Use at if you only need to get or set a single value in a DataFrame.\n     * @param row Row index of the value to access.\n     * @param column Column label of the value to access.\n     * @example\n     * ```\n     * const df = new DataFrame([[1, 2], [3, 4]], { columns: ['A', 'B']})\n     * df.at(0,'A') // 1\n     * df.at(1, 'A') // 3\n     * df.at(1, 'B') // 4\n     * ```\n    */\n    DataFrame.prototype.at = function (row, column) {\n        if (typeof column !== 'string') {\n            throw new Error('ParamError: column index must be a string. Use .iat to get a row or column by index.');\n        }\n        return this.values[this.index.indexOf(row)][this.columns.indexOf(column)];\n    };\n    /**\n     * Exposes functions for creating charts from a DataFrame.\n     * Charts are created using the Plotly.js library, so all Plotly's configuration parameters are available.\n     * @param divId name of the HTML Div to render the chart in.\n    */\n    DataFrame.prototype.plot = function (divId) {\n        //TODO: Add support for check plot library to use. So we can support other plot library like d3, vega, etc\n        if (utils.isBrowserEnv()) {\n            var plt = new plotting_1.PlotlyLib(this, divId);\n            return plt;\n        }\n        else {\n            throw new Error(\"Not supported in NodeJS\");\n        }\n    };\n    return DataFrame;\n}(generic_1.default));\nexports.default = DataFrame;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../core/frame\"));\nvar mathjs_1 = require(\"mathjs\");\nvar concat_1 = __importDefault(require(\"../transformers/concat\"));\nvar series_1 = __importDefault(require(\"../core/series\"));\n/**\n * The class performs all groupby operation on a dataframe\n * involving all aggregate funciton\n * @param {colDict} colDict Object of unique keys in the group by column\n * @param {keyCol} keyCol Array contains the column names\n * @param {data} Array the dataframe data\n * @param {columnName} Array of all column name in the dataframe.\n * @param {colDtype} Array columns dtype\n */\nvar Groupby = /** @class */ (function () {\n    function Groupby(keyCol, data, columnName, colDtype, colIndex) {\n        this.colDict = {};\n        this.keyToValue = {};\n        this.keyCol = keyCol;\n        this.data = data;\n        this.columnName = columnName;\n        //this.dataTensors = {}; //store the tensor version of the groupby data\n        this.colDtype = colDtype;\n        this.colIndex = colIndex;\n    }\n    /**\n     * Generate group object data needed for group operations\n     * let data = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 20, 30, 40 ], [ 39, 89, 78 ] ];\n     * let cols = [ \"A\", \"B\", \"C\" ];\n     * let df = new dfd.DataFrame(data, { columns: cols });\n     * let groupDf = df.groupby([ \"A\" ]);\n     * The following internal object is generated and save to this.colDict\n     * {\n     *  '1': { A: [ 1 ], B: [ 2 ], C: [ 3 ] },\n     *  '4': { A: [ 4 ], B: [ 5 ], C: [ 6 ] },\n     *  '20': { A: [ 20 ], B: [ 30 ], C: [ 40 ] },\n     *  '39': { A: [ 39 ], B: [ 89 ], C: [ 78 ] }\n     * }\n     * Since for groupby using more than one columns is index via '-'\n     * e.g for df.groupby(['A','B'])\n     * the result will look like this\n     * {\n     *  '1-2': {A: [ 1 ], B: [ 2 ], C: [ 3 ]},\n     *  '4-5': {A: [ 4 ], B: [ 5 ], C: [ 6 ]}\n     * }\n     * but in doing analysis on a specific column like this\n     * df.groupby(['A','B']).col(['C'])\n     * will have the following set of internal result\n     * {\n     *  '1-2': { C: [ 3 ]},\n     *  '4-5': {C: [ 6 ]}\n     * }\n     * In building our multindex type of DataFrame for this data,\n     * we've somehow loose track of value for column A and B.\n     * This could actually be generated by using split('-') on the object keys\n     * e.g '1-2'.split('-') will give us the value for A and B.\n     * But we might have weird case scenerio where A and B value has '-`\n     * e.g\n     * {\n     *  '1--2-': { C: [ 3 ]},\n     *  '4--5-': {C: [ 6 ]}\n     * }\n     * using `.split('-') might not work well\n     * Hence we create a key-value `keyToValue` object to store index and their\n     * associated value\n     * NOTE: In the previous implementation we made use of Graph representation\n     * for the group by data and Depth First search (DFS). But we decided to use key-value\n     * object in javascript as an hashmap to reduce search time compared to using Grpah and DFS\n     */\n    Groupby.prototype.group = function () {\n        var _a;\n        var self = this;\n        var keyToValue = {};\n        var group = (_a = this.data) === null || _a === void 0 ? void 0 : _a.reduce(function (prev, current) {\n            var indexes = [];\n            for (var i in self.colIndex) {\n                var index_1 = self.colIndex[i];\n                indexes.push(current[index_1]);\n            }\n            var index = indexes.join('-');\n            if (!keyToValue[index]) {\n                keyToValue[index] = indexes;\n            }\n            if (prev[index]) {\n                var data = prev[index];\n                for (var i in self.columnName) {\n                    var colName = self.columnName[i];\n                    data[colName].push(current[i]);\n                }\n            }\n            else {\n                prev[index] = {};\n                for (var i in self.columnName) {\n                    var colName = self.columnName[i];\n                    prev[index][colName] = [current[i]];\n                }\n            }\n            return prev;\n        }, {});\n        this.colDict = group;\n        this.keyToValue = keyToValue;\n        return this;\n    };\n    /**\n     * Generate new internal groupby data\n     * group = df.groupby(['A', 'B']).col('C')\n     * This filter the colDict property as generated by `.group()`\n     * it filter each group to contain only column `C` in their internal object\n     * e.g\n     * {\n     *  '1-2': {A: [ 1 ], B: [ 2 ], C: [ 3 ]},\n     *  '4-5': {A: [ 4 ], B: [ 5 ], C: [ 6 ]}\n     * }\n     * to\n     * {\n     *  '1-2': { C: [ 3 ]},\n     *  '4-5': {C: [ 6 ]}\n     * }\n     * @param colNames column names\n     * @return Groupby\n     */\n    Groupby.prototype.col = function (colNames) {\n        var _this = this;\n        if (typeof colNames === \"undefined\") {\n            colNames = this.columnName.filter(function (_, index) {\n                return !_this.colIndex.includes(index);\n            });\n        }\n        var self = this;\n        colNames.forEach(function (val) {\n            if (!self.columnName.includes(val))\n                throw new Error(\"Column \" + val + \" does not exist in groups\");\n        });\n        var colDict = __assign({}, this.colDict);\n        for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], values = _b[1];\n            var c = {};\n            var keyVal = __assign({}, values);\n            for (var colKey in colNames) {\n                var colName = colNames[colKey];\n                c[colName] = keyVal[colName];\n            }\n            colDict[key] = c;\n        }\n        var gp = new Groupby(this.keyCol, null, this.columnName, this.colDtype, this.colIndex);\n        gp.colDict = colDict;\n        gp.groupColNames = colNames;\n        gp.keyToValue = this.keyToValue;\n        return gp;\n    };\n    /**\n     * Perform all groupby arithmetic operations\n     * In the previous implementation all groups data are\n     * stord as DataFrame, which involve lot of memory usage\n     * Hence each groups are just pure javascrit object\n     * and all arithmetic operation is done directly on javascript\n     * arrays.\n     * e.g\n     * using this internal data\n     * {\n     *  '1-2': {A: [ 1,3 ], B: [ 2,5 ], C: [ 3, 5 ]},\n     *  '4-5': {A: [ 4,1 ], B: [ 5,0 ], C: [ 6, 12 ]}\n     * }\n     * 1) using groupby(['A', 'B']).arithmetic(\"mean\")\n     * result: * {\n     *  '1-2': {A_mean: [ 2 ], B_mean: [ 3.5 ], C_mean: [ 4 ]},\n     *  '4-5': {A_mean: [ 2.5 ], B: [ 2.5 ], C_mean: [ 9 ]}\n     * }\n     * 2) .arithmetic({\n     *    A: 'mean',\n     *    B: 'sum',\n     *    C: 'min'\n     * })\n     * result:\n     * {\n     *  '1-2': {A_mean: [ 2 ], B_sum: [ 7 ], C_min: [ 3 ]},\n     *  '4-5': {A_mean: [ 2.5 ], B_sum: [ 5 ], C_min: [ 6 ]}\n     * }\n     * 3) .arithmetic({\n     *    A: 'mean',\n     *    B: 'sum',\n     *    C: ['min', 'max']\n     * })\n     * result:\n     * {\n     *  '1-2': {A_mean: [ 2 ], B_sum: [ 7 ], C_min: [ 3 ], C_max: [5]},\n     *  '4-5': {A_mean: [ 2.5 ], B_sum: [ 5 ], C_min: [ 6 ], C_max: [12]}\n     * }\n     * @param operation\n     */\n    Groupby.prototype.arithemetic = function (operation) {\n        var opsName = [\"mean\", \"sum\", \"count\", \"mode\", \"std\", \"var\", \"cumsum\", \"cumprod\",\n            \"cummax\", \"cummin\", \"median\", \"min\", \"max\"];\n        if (typeof operation === \"string\") {\n            if (!opsName.includes(operation)) {\n                throw new Error(\"group operation: \" + operation + \" is not valid\");\n            }\n        }\n        else {\n            Object.keys(operation).forEach(function (key) {\n                var ops = operation[key];\n                if (Array.isArray(ops)) {\n                    for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n                        var op = ops_1[_i];\n                        if (!opsName.includes(op)) {\n                            throw new Error(\"group operation: \" + op + \" for column \" + key + \" is not valid\");\n                        }\n                    }\n                }\n                else {\n                    if (!opsName.includes(ops)) {\n                        throw new Error(\"group operation: \" + ops + \" for column \" + key + \" is not valid\");\n                    }\n                }\n            });\n        }\n        var colDict = __assign({}, this.colDict);\n        for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], values = _b[1];\n            var colVal = {};\n            var keyVal = __assign({}, values);\n            var groupColNames = this.groupColNames;\n            for (var colKey = 0; colKey < groupColNames.length; colKey++) {\n                var colName = groupColNames[colKey];\n                var colIndex = this.columnName.indexOf(colName);\n                var colDtype = this.colDtype[colIndex];\n                var operationVal = (typeof operation === \"string\") ? operation : operation[colName];\n                if (colDtype === \"string\" && operationVal !== \"count\")\n                    throw new Error(\"Can't perform math operation on column \" + colName);\n                if (typeof operation === \"string\") {\n                    var colName2 = colName + \"_\" + operation;\n                    colVal[colName2] = this.groupMathLog(keyVal[colName], operation);\n                }\n                else {\n                    if (Array.isArray(operation[colName])) {\n                        for (var _c = 0, _d = operation[colName]; _c < _d.length; _c++) {\n                            var ops = _d[_c];\n                            var colName2 = colName + \"_\" + ops;\n                            colVal[colName2] = this.groupMathLog(keyVal[colName], ops);\n                        }\n                    }\n                    else {\n                        var ops = operation[colName];\n                        var colName2 = colName + \"_\" + ops;\n                        colVal[colName2] = this.groupMathLog(keyVal[colName], ops);\n                    }\n                }\n            }\n            colDict[key] = colVal;\n        }\n        return colDict;\n    };\n    /**\n     * Peform all arithmetic logic\n     * @param colVal\n     * @param ops\n     */\n    Groupby.prototype.groupMathLog = function (colVal, ops) {\n        var data = [];\n        switch (ops) {\n            case \"max\":\n                var max = colVal.reduce(function (prev, curr) {\n                    if (prev > curr) {\n                        return prev;\n                    }\n                    return curr;\n                });\n                data.push(max);\n                break;\n            case \"min\":\n                var min = colVal.reduce(function (prev, curr) {\n                    if (prev < curr) {\n                        return prev;\n                    }\n                    return curr;\n                });\n                data.push(min);\n                break;\n            case \"sum\":\n                var sum = colVal.reduce(function (prev, curr) {\n                    return prev + curr;\n                });\n                data.push(sum);\n                break;\n            case \"count\":\n                data.push(colVal.length);\n                break;\n            case \"mean\":\n                var sumMean = colVal.reduce(function (prev, curr) {\n                    return prev + curr;\n                });\n                data.push(sumMean / colVal.length);\n                break;\n            case \"std\":\n                data.push((0, mathjs_1.std)(colVal));\n                break;\n            case \"var\":\n                data.push((0, mathjs_1.variance)(colVal));\n                break;\n            case \"median\":\n                data.push((0, mathjs_1.median)(colVal));\n                break;\n            case \"mode\":\n                data.push((0, mathjs_1.mode)(colVal));\n                break;\n            case \"cumsum\":\n                colVal.reduce(function (prev, curr) {\n                    var sum = prev + curr;\n                    data.push(sum);\n                    return sum;\n                }, 0);\n                break;\n            case \"cummin\":\n                data = [colVal[0]];\n                colVal.slice(1).reduce(function (prev, curr) {\n                    if (prev < curr) {\n                        data.push(prev);\n                        return prev;\n                    }\n                    data.push(curr);\n                    return curr;\n                }, data[0]);\n                break;\n            case \"cummax\":\n                data = [colVal[0]];\n                colVal.slice(1).reduce(function (prev, curr) {\n                    if (prev > curr) {\n                        data.push(prev);\n                        return prev;\n                    }\n                    data.push(curr);\n                    return curr;\n                }, data[0]);\n                break;\n            case \"cumprod\":\n                colVal.reduce(function (prev, curr) {\n                    var sum = prev * curr;\n                    data.push(sum);\n                    return sum;\n                }, 1);\n                break;\n        }\n        return data;\n    };\n    /**\n     * Takes in internal groupby internal data and convert\n     * them to a single data frame.\n     * @param colDict\n     */\n    Groupby.prototype.toDataFrame = function (colDict) {\n        var data = {};\n        for (var _i = 0, _a = this.colKeyDict(colDict); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var value = colDict[key];\n            var keyDict = {};\n            var oneValue = Object.values(value)[0];\n            var valueLen = oneValue.length;\n            for (var key1 in this.keyCol) {\n                var keyName = this.keyCol[key1];\n                var keyValue = this.keyToValue[key][key1];\n                keyDict[keyName] = Array(valueLen).fill(keyValue);\n            }\n            var combine = __assign(__assign({}, keyDict), value);\n            if (Object.keys(data).length < 1) {\n                data = combine;\n            }\n            else {\n                for (var _b = 0, _c = Object.keys(data); _b < _c.length; _b++) {\n                    var dataKey = _c[_b];\n                    var dataValue = combine[dataKey];\n                    data[dataKey] = __spreadArray(__spreadArray([], data[dataKey], true), dataValue, true);\n                }\n            }\n        }\n        return new frame_1.default(data);\n    };\n    Groupby.prototype.operations = function (ops) {\n        if (!this.groupColNames) {\n            var colGroup = this.col(undefined);\n            var colDict_1 = colGroup.arithemetic(ops);\n            var df_1 = colGroup.toDataFrame(colDict_1);\n            return df_1;\n        }\n        var colDict = this.arithemetic(ops);\n        var df = this.toDataFrame(colDict);\n        return df;\n    };\n    /**\n     * Obtain the count for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.count = function () {\n        return this.operations(\"count\");\n    };\n    /**\n     * Obtain the sum of columns for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.sum = function () {\n        return this.operations(\"sum\");\n    };\n    /**\n     * Obtain the standard deviation of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.std = function () {\n        return this.operations(\"std\");\n    };\n    /**\n     * Obtain the variance of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.var = function () {\n        return this.operations(\"var\");\n    };\n    /**\n     * Obtain the mean of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.mean = function () {\n        return this.operations(\"mean\");\n    };\n    /**\n     * Obtain the cumsum of columns for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.cumSum = function () {\n        return this.operations(\"cumsum\");\n    };\n    /**\n     * Obtain the cummax of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.cumMax = function () {\n        return this.operations(\"cummax\");\n    };\n    /**\n     * Obtain the cumprod of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.cumProd = function () {\n        return this.operations(\"cumprod\");\n    };\n    /**\n     * Obtain the cummin of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.cumMin = function () {\n        return this.operations(\"cummin\");\n    };\n    /**\n     * Obtain the max value of columns for each group\n     * @returns DataFrame\n     *\n     */\n    Groupby.prototype.max = function () {\n        return this.operations(\"max\");\n    };\n    /**\n     * Obtain the min of columns for each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.min = function () {\n        return this.operations(\"min\");\n    };\n    /**\n     * Obtain a specific group\n     * @param keys Array<string | number>\n     * @returns DataFrame\n     */\n    Groupby.prototype.getGroup = function (keys) {\n        var dictKey = keys.join(\"-\");\n        var colDict = {};\n        colDict[dictKey] = __assign({}, this.colDict[dictKey]);\n        return this.toDataFrame(colDict);\n    };\n    /**\n     * Perform aggregation on all groups\n     * @param ops\n     * @returns DataFrame\n     */\n    Groupby.prototype.agg = function (ops) {\n        var columns = Object.keys(ops);\n        var col_gp = this.col(columns);\n        var data = col_gp.arithemetic(ops);\n        var df = col_gp.toDataFrame(data);\n        return df;\n    };\n    /**\n     * Apply custom aggregator function\n     * to each group\n     * @param callable\n     * @returns DataFrame\n     * @example\n     * let grp = df.groupby(['A'])\n     * grp.apply((x) => x.count())\n     */\n    Groupby.prototype.apply = function (callable) {\n        var colDict = {};\n        for (var _i = 0, _a = this.colKeyDict(this.colDict); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var valDataframe = new frame_1.default(this.colDict[key]);\n            colDict[key] = callable(valDataframe);\n        }\n        return this.concatGroups(colDict);\n    };\n    Groupby.prototype.concatGroups = function (colDict) {\n        var data = [];\n        for (var _i = 0, _a = Object.entries(colDict); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], values = _b[1];\n            var copyDf = void 0;\n            if (values instanceof frame_1.default) {\n                copyDf = values.copy();\n            }\n            else {\n                var columns = values.index;\n                columns = columns.length > 1 ? columns : ['applyOps'];\n                copyDf = new frame_1.default([values.values], { columns: columns });\n            }\n            var len = copyDf.shape[0];\n            var key1 = void 0;\n            for (key1 in this.keyCol) {\n                var keyName = this.keyCol[key1];\n                var keyValue = this.keyToValue[key][key1];\n                var dfValue = Array(len).fill(keyValue);\n                var atIndex = parseInt(key1);\n                if (this.groupColNames) {\n                    copyDf.addColumn(keyName, dfValue, { inplace: true, atIndex: atIndex });\n                }\n                else {\n                    copyDf.addColumn(keyName + \"_Group\", dfValue, { inplace: true, atIndex: atIndex });\n                }\n            }\n            data.push(copyDf);\n        }\n        return (0, concat_1.default)({ dfList: data, axis: 0 });\n    };\n    Object.defineProperty(Groupby.prototype, \"ngroups\", {\n        /**\n         * obtain the total number of groups\n         * @returns number\n         */\n        get: function () {\n            var keys = Object.keys(this.colDict);\n            return keys.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Groupby.prototype, \"groups\", {\n        /**\n         * obtaind the internal group data\n         * @returns  {[keys: string]: {}}\n         */\n        get: function () {\n            return this.colDict;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Obtain the first row of each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.first = function () {\n        return this.apply(function (x) {\n            return x.head(1);\n        });\n    };\n    /**\n     * Obtain the last row of each group\n     * @returns DataFrame\n     */\n    Groupby.prototype.last = function () {\n        return this.apply(function (x) {\n            return x.tail(1);\n        });\n    };\n    /**\n     * Obtains the dataframe se of each groups\n     * @returns DataFrame\n     */\n    Groupby.prototype.size = function () {\n        return this.apply(function (x) {\n            return new series_1.default([x.shape[0]]);\n        });\n    };\n    Groupby.prototype.colKeyDict = function (colDict) {\n        var keyDict = {};\n        for (var _i = 0, _a = Object.keys(colDict); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var firstKey = key.split(\"-\")[0];\n            if (firstKey in keyDict) {\n                keyDict[firstKey].push(key);\n            }\n            else {\n                keyDict[firstKey] = [key];\n            }\n        }\n        var keys = [];\n        for (var _b = 0, _c = Object.keys(keyDict); _b < _c.length; _b++) {\n            var key = _c[_b];\n            keys.push.apply(keys, keyDict[key]);\n        }\n        return keys;\n    };\n    return Groupby;\n}());\nexports.default = Groupby;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar series_1 = __importDefault(require(\"../core/series\"));\nvar frame_1 = __importDefault(require(\"../core/frame\"));\n/**\n *\n * @param dfList Array<DataFrame | Series>\n * @param axis number\n * @returns DataFrame\n */\nfunction processColumn(dfList, axis) {\n    var allDf = {};\n    var dublicateColumns = {};\n    var maxLen = 0;\n    for (var i = 0; i < dfList.length; i++) {\n        var df = dfList[i];\n        var columnData = void 0;\n        if (df instanceof frame_1.default) {\n            columnData = df.getColumnData;\n        }\n        else {\n            columnData = [df.values];\n        }\n        var columns = df.columns;\n        for (var j = 0; j < columns.length; j++) {\n            var column = columns[j];\n            var colData = columnData[j];\n            if (colData.length > maxLen) {\n                maxLen = colData.length;\n            }\n            if (!(column in allDf)) {\n                allDf[column] = colData;\n                dublicateColumns[column] = 0;\n            }\n            else {\n                dublicateColumns[column] += 1;\n                column += dublicateColumns[column];\n                allDf[column] = colData;\n            }\n        }\n    }\n    Object.keys(allDf).forEach(function (value) {\n        var _a;\n        var colLength = allDf[value].length;\n        if (colLength < maxLen) {\n            var residualLen = maxLen - colLength;\n            var nanList = new Array(residualLen).fill(NaN);\n            (_a = allDf[value]).push.apply(_a, nanList);\n        }\n    });\n    return new frame_1.default(allDf);\n}\n/**\n * Concat data along rows\n * @param dfList Array<DataFrame | Series>\n * @param axis  Array<DataFrame | Series>\n * @returns DataFrame\n */\nfunction processRow(dfList, axis) {\n    var allDf = {};\n    var maxLen = 0;\n    var _loop_1 = function (i) {\n        var _a, _b;\n        var df = dfList[i];\n        var columns = df.columns;\n        var columnData = void 0;\n        if (df instanceof frame_1.default) {\n            columnData = df.getColumnData;\n        }\n        else {\n            columnData = [df.values];\n        }\n        if (i === 0) {\n            for (var j = 0; j < columns.length; j++) {\n                var column = columns[j];\n                var colData = columnData[j];\n                allDf[column] = colData;\n            }\n        }\n        else {\n            var nonColumn = Object.keys(allDf).filter(function (key) {\n                return !columns.includes(key);\n            });\n            for (var j = 0; j < columns.length; j++) {\n                var column = columns[j];\n                var colData = columnData[j];\n                if (Object.keys(allDf).includes(column)) {\n                    (_a = allDf[column]).push.apply(_a, colData);\n                }\n                else {\n                    var residualArray = new Array(maxLen).fill(NaN);\n                    residualArray.push.apply(residualArray, colData);\n                    allDf[column] = residualArray;\n                }\n            }\n            if (nonColumn.length > 0) {\n                var currentDfLen = columnData[0].length;\n                for (var j = 0; j < nonColumn.length; j++) {\n                    var column = nonColumn[j];\n                    var residualArray = new Array(currentDfLen).fill(NaN);\n                    (_b = allDf[column]).push.apply(_b, residualArray);\n                }\n            }\n        }\n        maxLen += columnData[0].length;\n    };\n    for (var i = 0; i < dfList.length; i++) {\n        _loop_1(i);\n    }\n    if (Object.keys(allDf).length === 1) {\n        return new series_1.default(Object.values(allDf)[0]);\n    }\n    return new frame_1.default(allDf);\n}\n/**\n* Concatenate pandas objects along a particular axis.\n* @param object\n* dfList: Array of DataFrame or Series\n* axis: axis of concatenation 1 or 0\n* @returns {DataFrame}\n* @example\n* concat({dfList: [df1, df2, df3], axis: 1})\n*/\nfunction concat(_a) {\n    var dfList = _a.dfList, axis = _a.axis;\n    if (axis === 1) {\n        return processColumn(dfList, axis);\n    }\n    return processRow(dfList, 0);\n}\nexports.default = concat;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._loc = exports._iloc = void 0;\nvar series_1 = __importDefault(require(\"./series\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar frame_1 = __importDefault(require(\"./frame\"));\nvar utils = new utils_1.default();\n/**\n* Internal function to slice a Series/DataFrame by index based labels\n* @param Object\n*/\nfunction _iloc(_a) {\n    var ndFrame = _a.ndFrame, rows = _a.rows, columns = _a.columns;\n    var _rowIndexes;\n    var _columnIndexes;\n    var _data = ndFrame.values;\n    var _index = ndFrame.index;\n    if (rows instanceof series_1.default) {\n        rows = rows.values;\n    }\n    if (rows !== undefined && !Array.isArray(rows)) {\n        throw new Error(\"rows parameter must be an Array. For example: rows: [1,2] or rows: [\\\"0:10\\\"]\");\n    }\n    if (columns !== undefined && !Array.isArray(columns)) {\n        throw new Error(\"columns parameter must be an Array. For example: columns: [1,2] or columns: [\\\"0:10\\\"]\");\n    }\n    if (!rows) {\n        _rowIndexes = utils.range(0, ndFrame.shape[0] - 1);\n    }\n    else if (rows.length == 1 && typeof rows[0] == \"string\") {\n        var rowSplit = rows[0].split(\":\");\n        if (rowSplit.length != 2) {\n            throw new Error(\"Invalid row split parameter: If using row split string, it must be of the form; rows: [\\\"start:end\\\"]\");\n        }\n        if (isNaN(parseInt(rowSplit[0])) && rowSplit[0] != \"\") {\n            throw new Error(\"Invalid row split parameter. Split parameter must be a number\");\n        }\n        if (isNaN(parseInt(rowSplit[1])) && rowSplit[1] != \"\") {\n            throw new Error(\"Invalid row split parameter. Split parameter must be a number\");\n        }\n        var start = rowSplit[0] == \"\" ? 0 : parseInt(rowSplit[0]);\n        var end = rowSplit[1] == \"\" ? ndFrame.shape[0] : parseInt(rowSplit[1]);\n        if (start < 0) {\n            throw new Error(\"row slice [start] index cannot be less than 0\");\n        }\n        if (end > ndFrame.shape[0]) {\n            throw new Error(\"row slice [end] index cannot be bigger than \" + ndFrame.shape[0]);\n        }\n        _rowIndexes = utils.range(start, end - 1);\n    }\n    else {\n        var _formatedRows = [];\n        for (var i = 0; i < rows.length; i++) {\n            var _indexToUse = rows[i];\n            if (_indexToUse > ndFrame.shape[0]) {\n                throw new Error(\"Invalid row parameter: Specified index \" + _indexToUse + \" cannot be bigger than index length \" + ndFrame.shape[0]);\n            }\n            if (typeof _indexToUse !== \"number\" && typeof _indexToUse !== \"boolean\") {\n                throw new Error(\"Invalid row parameter: row index \" + _indexToUse + \" must be a number or boolean\");\n            }\n            if (typeof _indexToUse === \"boolean\" && _indexToUse === true) {\n                _formatedRows.push(_index[i]);\n            }\n            if (typeof _indexToUse === \"number\") {\n                _formatedRows.push(_indexToUse);\n            }\n        }\n        _rowIndexes = _formatedRows;\n    }\n    if (!columns) {\n        _columnIndexes = utils.range(0, ndFrame.shape[1] - 1);\n    }\n    else if (columns.length == 1 && typeof columns[0] == \"string\") {\n        var columnSplit = columns[0].split(\":\");\n        if (columnSplit.length != 2) {\n            throw new Error(\"Invalid column split parameter: If using column split string, it must be of the form; columns: [\\\"start:end\\\"]\");\n        }\n        if (isNaN(parseInt(columnSplit[0])) && columnSplit[0] != \"\") {\n            throw new Error(\"Invalid column split parameter. Split parameter must be a number\");\n        }\n        if (isNaN(parseInt(columnSplit[1])) && columnSplit[1] != \"\") {\n            throw new Error(\"Invalid column split parameter. Split parameter must be a number\");\n        }\n        var start = columnSplit[0] == \"\" ? 0 : parseInt(columnSplit[0]);\n        var end = columnSplit[1] == \"\" ? ndFrame.shape[1] : parseInt(columnSplit[1]);\n        if (start < 0) {\n            throw new Error(\"column slice [start] index cannot be less than 0\");\n        }\n        if (end > ndFrame.shape[1]) {\n            throw new Error(\"column slice [end] index cannot be bigger than \" + ndFrame.shape[1]);\n        }\n        _columnIndexes = utils.range(start, end - 1);\n    }\n    else {\n        for (var i = 0; i < columns.length; i++) {\n            var _indexToUse = columns[i];\n            if (_indexToUse > ndFrame.shape[1]) {\n                throw new Error(\"Invalid column parameter: Specified index \" + _indexToUse + \" cannot be bigger than index length \" + ndFrame.shape[1]);\n            }\n            if (typeof _indexToUse != \"number\") {\n                throw new Error(\"Invalid column parameter: column index \" + _indexToUse + \" must be a number\");\n            }\n        }\n        _columnIndexes = columns;\n    }\n    if (ndFrame instanceof series_1.default) {\n        var newData = [];\n        var newIndex = [];\n        for (var i = 0; i < _rowIndexes.length; i++) {\n            var rowIndx = _rowIndexes[i];\n            newData.push(_data[rowIndx]);\n            newIndex.push(_index[rowIndx]);\n        }\n        var sf = new series_1.default(newData, {\n            index: newIndex,\n            columns: ndFrame.columns,\n            dtypes: ndFrame.dtypes,\n            config: ndFrame.config\n        });\n        return sf;\n    }\n    else {\n        var newData = [];\n        var newIndex = [];\n        var newColumnNames = [];\n        var newDtypes = [];\n        for (var i = 0; i < _rowIndexes.length; i++) {\n            var rowIndx = _rowIndexes[i];\n            var rowData = _data[rowIndx];\n            var newRowDataWithRequiredCols = [];\n            for (var j = 0; j < _columnIndexes.length; j++) {\n                var colIndx = _columnIndexes[j];\n                newRowDataWithRequiredCols.push(rowData[colIndx]);\n            }\n            newData.push(newRowDataWithRequiredCols);\n            newIndex.push(_index[rowIndx]);\n        }\n        for (var i = 0; i < _columnIndexes.length; i++) {\n            var colIndx = _columnIndexes[i];\n            newColumnNames.push(ndFrame.columns[colIndx]);\n            newDtypes.push(ndFrame.dtypes[colIndx]);\n        }\n        var df = new frame_1.default(newData, {\n            index: newIndex,\n            columns: newColumnNames,\n            dtypes: newDtypes,\n            config: ndFrame.config\n        });\n        return df;\n    }\n}\nexports._iloc = _iloc;\n/**\n* Internal function to slice a Series/DataFrame by specified string location based labels\n* @param Object\n*/\nfunction _loc(_a) {\n    var ndFrame = _a.ndFrame, rows = _a.rows, columns = _a.columns;\n    var _rowIndexes;\n    var _columnIndexes;\n    var _data = ndFrame.values;\n    var _index = ndFrame.index;\n    if (rows instanceof series_1.default) {\n        rows = rows.values;\n    }\n    if (rows !== undefined && !Array.isArray(rows)) {\n        throw new Error(\"rows parameter must be an Array. For example: rows: [1,2] or rows: [\\\"0:10\\\"]\");\n    }\n    if (columns !== undefined && !Array.isArray(columns)) {\n        throw new Error(\"columns parameter must be an Array. For example: columns: [\\\"a\\\",\\\"b\\\"] or columns: [\\\"a:c\\\"]\");\n    }\n    if (!rows) {\n        _rowIndexes = _index.map(function (indexValue) { return _index.indexOf(indexValue); }); // Return all row index\n    }\n    else if (rows.length == 1 && typeof rows[0] == \"string\") {\n        if (rows[0].indexOf(\":\") === -1) { // Input type ==> [\"1\"] or [`\"1\"`]\n            var temp = void 0;\n            if (rows[0].startsWith(\"\\\"\") || rows[0].startsWith(\"'\") || rows[0].startsWith(\"`\")) {\n                temp = _index.indexOf(rows[0].replace(/['\"`]/g, ''));\n            }\n            else {\n                temp = _index.indexOf(Number(rows[0]));\n            }\n            if (temp === -1) {\n                throw new Error(\"IndexError: Specified index (\" + rows[0] + \") not found\");\n            }\n            _rowIndexes = [temp];\n        }\n        else {\n            // Input type ==> [\"1:2\"] or [`\"1\":\"4\"`]\n            var rowSplit = rows[0].split(\":\");\n            if (rowSplit.length != 2) {\n                throw new Error(\"Invalid row split parameter: If using row split string, it must be of the form; rows: [\\\"start:end\\\"]\");\n            }\n            var start = void 0;\n            var end = void 0;\n            if (rowSplit[0] === \"\") {\n                start = _index.indexOf(_index[0]);\n            }\n            else {\n                if (rowSplit[0].startsWith(\"\\\"\") || rowSplit[0].startsWith(\"'\") || rowSplit[0].startsWith(\"`\")) {\n                    start = _index.indexOf(rowSplit[0].replace(/['\"`]/g, ''));\n                }\n                else {\n                    start = _index.indexOf(Number(rowSplit[0]));\n                }\n            }\n            if (rowSplit[1] === \"\") {\n                end = _index.indexOf(_index[_index.length - 1]) + 1;\n            }\n            else {\n                if (rowSplit[0].startsWith(\"\\\"\") || rowSplit[0].startsWith(\"'\") || rowSplit[0].startsWith(\"`\")) {\n                    end = _index.indexOf(rowSplit[1].replace(/['\"`]/g, ''));\n                }\n                else {\n                    end = _index.indexOf(Number(rowSplit[1]));\n                }\n            }\n            if (start === -1) {\n                throw new Error(\"IndexError: Specified start index not found\");\n            }\n            if (end === -1) {\n                throw new Error(\"IndexError: Specified end index not found\");\n            }\n            _rowIndexes = _index.slice(start, end).map(function (indexValue) { return _index.indexOf(indexValue); });\n        }\n    }\n    else {\n        // Input type ==> [\"1\", \"2\"] or [1, 5] or [true, false]\n        var rowsIndexToUse = [];\n        for (var i = 0; i < rows.length; i++) {\n            var isBoolean = typeof rows[i] === \"boolean\";\n            if (isBoolean && rows[i]) {\n                rowsIndexToUse.push(_index.indexOf(_index[i]));\n            }\n            if (!isBoolean) {\n                var rowIndex = _index.indexOf(rows[i]);\n                if (rowIndex === -1) {\n                    throw new Error(\"IndexError: Specified index (\" + rows[i] + \") not found\");\n                }\n                rowsIndexToUse.push(rowIndex);\n            }\n        }\n        _rowIndexes = rowsIndexToUse;\n    }\n    var _columnNames = ndFrame.columns;\n    if (!columns) {\n        _columnIndexes = _columnNames.map(function (columnName) { return _columnNames.indexOf(columnName); }); // Return all column index\n    }\n    else if (columns.length == 1) {\n        if (typeof columns[0] !== \"string\") {\n            throw new Error(\"ColumnIndexError: columns parameter must be an array of a string name. For example: columns: [\\\"b\\\"]\");\n        }\n        if (columns[0].indexOf(\":\") == -1) { // Input type ==> [\"A\"] \n            _columnIndexes = [_columnNames.indexOf(columns[0])];\n        }\n        else { // Input type ==> [\"a:b\"] or [`\"col1\":\"col5\"`]\n            var columnSplit = columns[0].split(\":\");\n            if (columnSplit.length != 2) {\n                throw new Error(\"ColumnIndexError: Invalid row split parameter. If using row split string, it must be of the form; rows: [\\\"start:end\\\"]\");\n            }\n            var start = columnSplit[0] == \"\" ? _columnNames.indexOf(_columnNames[0]) : _columnNames.indexOf(columnSplit[0]);\n            var end = columnSplit[1] == \"\" ? _columnNames.indexOf(_columnNames[_columnNames.length - 1]) : _columnNames.indexOf(columnSplit[1]);\n            if (start === -1) {\n                throw new Error(\"ColumnIndexError: Specified start index not found\");\n            }\n            if (end === -1) {\n                throw new Error(\"ColumnIndexError: Specified end index not found\");\n            }\n            _columnIndexes = _columnNames.slice(start, end + 1).map(function (columnName) { return _columnNames.indexOf(columnName); });\n            _columnIndexes.pop(); //Remove the last element\n        }\n    }\n    else { // Input type ==> [\"A\", \"B\"] or [\"col1\", \"col2\"]\n        for (var i = 0; i < columns.length; i++) {\n            if (_columnNames.indexOf(columns[i]) === -1) {\n                throw new Error(\"ColumnIndexError: Specified column (\" + columns[i] + \") not found\");\n            }\n        }\n        _columnIndexes = columns.map(function (columnName) { return _columnNames.indexOf(columnName); });\n    }\n    if (ndFrame instanceof series_1.default) {\n        var newData = [];\n        var newIndex = [];\n        for (var i = 0; i < _rowIndexes.length; i++) {\n            var rowIndx = _rowIndexes[i];\n            newData.push(_data[rowIndx]);\n            newIndex.push(_index[rowIndx]);\n        }\n        var sf = new series_1.default(newData, {\n            index: newIndex,\n            columns: ndFrame.columns,\n            dtypes: ndFrame.dtypes,\n            config: ndFrame.config\n        });\n        return sf;\n    }\n    else {\n        var newData = [];\n        var newIndex = [];\n        var newColumnNames = [];\n        var newDtypes = [];\n        for (var i = 0; i < _rowIndexes.length; i++) {\n            var rowIndx = _rowIndexes[i];\n            var rowData = _data[rowIndx];\n            var newRowDataWithRequiredCols = [];\n            for (var j = 0; j < _columnIndexes.length; j++) {\n                var colIndx = _columnIndexes[j];\n                newRowDataWithRequiredCols.push(rowData[colIndx]);\n            }\n            newData.push(newRowDataWithRequiredCols);\n            newIndex.push(_index[rowIndx]);\n        }\n        for (var i = 0; i < _columnIndexes.length; i++) {\n            var colIndx = _columnIndexes[i];\n            newColumnNames.push(ndFrame.columns[colIndx]);\n            newDtypes.push(ndFrame.dtypes[colIndx]);\n        }\n        var df = new frame_1.default(newData, {\n            index: newIndex,\n            columns: newColumnNames,\n            dtypes: newDtypes,\n            config: ndFrame.config\n        });\n        return df;\n    }\n}\nexports._loc = _loc;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PlotlyLib = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar index_1 = require(\"./plotly/index\");\nvar Plotly;\nif (typeof window !== \"undefined\") {\n    //check if in browser environment and require \"plotly.js-dist-min\" module\n    Plotly = require(\"plotly.js-dist-min\");\n}\nvar PlotlyLib = /** @class */ (function () {\n    function PlotlyLib(ndframe, divId) {\n        this.ndframe = ndframe;\n        this.divId = divId;\n    }\n    PlotlyLib.prototype.getPlotConfig = function (plotConfig) {\n        var _plotConfig = {\n            config: plotConfig && plotConfig.config ? plotConfig.config : {},\n            layout: plotConfig && plotConfig.layout ? plotConfig.layout : {}\n        };\n        return _plotConfig;\n    };\n    /**\n     * Plot Series or DataFrame as lines.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n    */\n    PlotlyLib.prototype.line = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.linePlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as bars.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n    */\n    PlotlyLib.prototype.bar = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.barPlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as scatter.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n    */\n    PlotlyLib.prototype.scatter = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.scatterPlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as histogram.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n    */\n    PlotlyLib.prototype.hist = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.histPlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as pie.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n    */\n    PlotlyLib.prototype.pie = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.piePlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as boxplot.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n    */\n    PlotlyLib.prototype.box = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.boxPlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as violinplot.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n     */\n    PlotlyLib.prototype.violin = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.violinPlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    /**\n     * Plot Series or DataFrame as table.\n     * Uses Plotly library as backend, so supports Plotly's configuration parameters\n     * @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n     */\n    PlotlyLib.prototype.table = function (plotConfig) {\n        var _plotConfig = this.getPlotConfig(plotConfig);\n        (0, index_1.tablePlot)(this.ndframe, this.divId, _plotConfig, Plotly);\n    };\n    return PlotlyLib;\n}());\nexports.PlotlyLib = PlotlyLib;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tablePlot = exports.violinPlot = exports.boxPlot = exports.piePlot = exports.histPlot = exports.scatterPlot = exports.barPlot = exports.linePlot = void 0;\nvar line_1 = require(\"./line\");\nObject.defineProperty(exports, \"linePlot\", { enumerable: true, get: function () { return line_1.linePlot; } });\nvar bar_1 = require(\"./bar\");\nObject.defineProperty(exports, \"barPlot\", { enumerable: true, get: function () { return bar_1.barPlot; } });\nvar scatter_1 = require(\"./scatter\");\nObject.defineProperty(exports, \"scatterPlot\", { enumerable: true, get: function () { return scatter_1.scatterPlot; } });\nvar hist_1 = require(\"./hist\");\nObject.defineProperty(exports, \"histPlot\", { enumerable: true, get: function () { return hist_1.histPlot; } });\nvar pie_1 = require(\"./pie\");\nObject.defineProperty(exports, \"piePlot\", { enumerable: true, get: function () { return pie_1.piePlot; } });\nvar box_1 = require(\"./box\");\nObject.defineProperty(exports, \"boxPlot\", { enumerable: true, get: function () { return box_1.boxPlot; } });\nvar violin_1 = require(\"./violin\");\nObject.defineProperty(exports, \"violinPlot\", { enumerable: true, get: function () { return violin_1.violinPlot; } });\nvar table_1 = require(\"./table\");\nObject.defineProperty(exports, \"tablePlot\", { enumerable: true, get: function () { return table_1.tablePlot; } });\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.linePlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as lines.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* The precedence of columns to plot is: (x and y => x => y => columns).\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n* @param Plotly Plotly package passed from the class.\n*/\nvar linePlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var y = ndframe.values;\n        var trace = {\n            x: ndframe.index,\n            y: y,\n            type: 'scatter',\n            mode: 'lines',\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"x\"] && config[\"y\"]) {\n            //Plotting two columns against each other, when user specifies x and y column names in configuration\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"x\"]);\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"y\"]);\n            var x = ndframe[config.x].values;\n            var y = ndframe[config.y].values;\n            var trace = { x: x, y: y };\n            var _layout = __assign({ xaxis: {\n                    title: config.x,\n                }, yaxis: {\n                    title: config.y,\n                } }, layout);\n            Plotly.newPlot(divId, [trace], _layout, config);\n        }\n        else if (config[\"x\"] || config[\"y\"]) {\n            //plot single column specified in either of param [x | y] against index\n            if (config[\"x\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.x);\n                var x = ndframe[config.x].values;\n                var y = ndframe.index;\n                var trace = { x: x, y: y };\n                var _layout = __assign({ xaxis: {\n                        title: config.x,\n                    }, yaxis: {\n                        title: \"Index\",\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n            if (config[\"y\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.y);\n                var x = ndframe.index;\n                var y = ndframe[config.y].values;\n                var trace = { x: x, y: y };\n                var _layout = __assign({ xaxis: {\n                        title: \"Index\",\n                    }, yaxis: {\n                        title: config.y,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n        }\n        else {\n            //plot specified columns in config param against index\n            // if columns is not specified in config, then plot all columns\n            var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n            var traces_1 = [];\n            cols.forEach(function (col) {\n                var x = ndframe.index;\n                var y = ndframe[col].values;\n                var trace = { x: x, y: y, name: col };\n                traces_1.push(trace);\n            });\n            Plotly.newPlot(divId, traces_1, layout, config);\n        }\n    }\n};\nexports.linePlot = linePlot;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.throwErrorOnWrongColName = exports.checkIfColsExist = void 0;\nvar checkIfColsExist = function (ndframe, cols) {\n    cols.forEach(function (col) {\n        if (!ndframe.columns.includes(col)) {\n            throw Error(\"Column Error: \" + col + \" not found in columns. Columns should be one of [ \" + ndframe.columns + \" ]\");\n        }\n    });\n    return cols;\n};\nexports.checkIfColsExist = checkIfColsExist;\nvar throwErrorOnWrongColName = function (ndframe, colName) {\n    if (!ndframe.columns.includes(colName)) {\n        throw Error(\"ParamError: specified column \" + colName + \" not found in columns\");\n    }\n};\nexports.throwErrorOnWrongColName = throwErrorOnWrongColName;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.barPlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as bar.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* The precedence of columns to plot is: (x and y => x => y => columns).\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar barPlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var trace = {\n            x: ndframe.index,\n            y: ndframe.values,\n            type: 'bar',\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"x\"] && config[\"y\"]) {\n            //Plotting two columns against each other, when user specifies x and y column names in configuration\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"x\"]);\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"y\"]);\n            var x = ndframe[config.x].values;\n            var y = ndframe[config.y].values;\n            var trace = {\n                x: x,\n                y: y,\n                type: 'bar',\n            };\n            var _layout = __assign({ xaxis: {\n                    title: config.x,\n                }, yaxis: {\n                    title: config.y,\n                } }, layout);\n            Plotly.newPlot(divId, [trace], _layout, config);\n        }\n        else if (config[\"x\"] || config[\"y\"]) {\n            //plot single column specified in either of param [x | y] against index\n            if (config[\"x\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.x);\n                var x = ndframe[config.x].values;\n                var y = ndframe.index;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'bar',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: config.x,\n                    }, yaxis: {\n                        title: \"Index\",\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n            if (config[\"y\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.y);\n                var x = ndframe.index;\n                var y = ndframe[config.y].values;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'bar',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: \"Index\",\n                    }, yaxis: {\n                        title: config.y,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n        }\n        else {\n            //plot specified columns in config param against index\n            // if columns is not specified in config, then plot all columns\n            var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n            var traces_1 = [];\n            cols.forEach(function (col) {\n                var x = ndframe.index;\n                var y = ndframe[col].values;\n                var trace = { x: x, y: y, name: col, type: 'bar' };\n                traces_1.push(trace);\n            });\n            Plotly.newPlot(divId, traces_1, layout, config);\n        }\n    }\n};\nexports.barPlot = barPlot;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scatterPlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as scatter points.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* The precedence of columns to plot is: (x and y => x => y => columns).\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar scatterPlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var y = ndframe.values;\n        var trace = {\n            x: ndframe.index,\n            y: y,\n            type: 'scatter',\n            mode: 'markers',\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"x\"] && config[\"y\"]) {\n            //Plotting two columns against each other, when user specifies x and y column names in configuration\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"x\"]);\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"y\"]);\n            var x = ndframe[config.x].values;\n            var y = ndframe[config.y].values;\n            var trace = {\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'markers',\n            };\n            var _layout = __assign({ xaxis: {\n                    title: config.x,\n                }, yaxis: {\n                    title: config.y,\n                } }, layout);\n            Plotly.newPlot(divId, [trace], _layout, config);\n        }\n        else if (config[\"x\"] || config[\"y\"]) {\n            //plot single column specified in either of param [x | y] against index\n            if (config[\"x\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.x);\n                var x = ndframe[config.x].values;\n                var y = ndframe.index;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'scatter',\n                    mode: 'markers',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: config.x,\n                    }, yaxis: {\n                        title: \"Index\",\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n            if (config[\"y\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.y);\n                var x = ndframe.index;\n                var y = ndframe[config.y].values;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'scatter',\n                    mode: 'markers',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: \"Index\",\n                    }, yaxis: {\n                        title: config.y,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n        }\n        else {\n            //plot specified columns in config param against index\n            // if columns is not specified in config, then plot all columns\n            var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n            var traces_1 = [];\n            cols.forEach(function (col) {\n                var y = ndframe.index;\n                var x = ndframe[col].values;\n                var trace = {\n                    x: x,\n                    y: y,\n                    name: col,\n                    type: 'scatter',\n                    mode: 'markers',\n                };\n                traces_1.push(trace);\n            });\n            Plotly.newPlot(divId, traces_1, layout, config);\n        }\n    }\n};\nexports.scatterPlot = scatterPlot;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.histPlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as histogram.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* The precedence of columns to plot is: (x and y => x => y => columns).\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar histPlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var trace = {\n            x: ndframe.values,\n            type: 'histogram',\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"x\"] || config[\"y\"]) {\n            //plot single column specified in either of param [x | y] against index\n            if (config[\"x\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.x);\n                var x = ndframe[config.x].values;\n                var trace = {\n                    x: x,\n                    type: 'histogram',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: config.x,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n            if (config[\"y\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.y);\n                var y = ndframe[config.y].values;\n                var trace = {\n                    y: y,\n                    type: 'histogram',\n                };\n                var _layout = __assign({ yaxis: {\n                        title: config.y,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n        }\n        else {\n            //plot specified columns in config param against index\n            // if columns is not specified in config, then plot all columns\n            var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n            var traces_1 = [];\n            cols.forEach(function (col) {\n                var y = ndframe.index;\n                var x = ndframe[col].values;\n                var trace = { x: x, y: y, name: col, type: 'histogram' };\n                traces_1.push(trace);\n            });\n            Plotly.newPlot(divId, traces_1, layout, config);\n        }\n    }\n};\nexports.histPlot = histPlot;\n","\n// @ts-nocheck\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.piePlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as pie chart.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar piePlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var trace = {\n            values: ndframe.values,\n            labels: config[\"labels\"] || ndframe.index,\n            type: 'pie',\n            name: config.labels,\n            hoverinfo: 'label+percent+name',\n            automargin: true\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"labels\"]) {\n            if (!ndframe.columns.includes(config['labels'])) {\n                throw Error(\"Column Error: \" + config['labels'] + \" not found in columns. Param \\\"labels\\\" name must be one of [ \" + ndframe.columns + \"]\");\n            }\n            if (config[\"values\"]) {\n                if (!ndframe.columns.includes(config['values'])) {\n                    throw Error(\"Column Error: \" + config['values'] + \" not found in columns. Param \\\"values\\\" name must be one of [ \" + ndframe.columns + \"]\");\n                }\n                var trace = {\n                    values: ndframe[config['values']].values,\n                    labels: ndframe[config[\"labels\"]].values,\n                    type: 'pie',\n                    name: config.labels,\n                    hoverinfo: 'label+percent+name',\n                    automargin: true\n                };\n                Plotly.newPlot(divId, [trace], layout, config);\n            }\n            else {\n                // if columns is not specified in config, then plot all columns\n                var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n                if (config['rowPositions']) {\n                    if (config['rowPositions'].length != cols.length) {\n                        throw Error(\"length of rowPositions array must be equal to number of columns. Got \" + config['rowPositions'].length + \", expected \" + (cols.length - 1));\n                    }\n                }\n                else {\n                    var tempArr = [];\n                    for (var i = 0; i < cols.length - 1; i++) {\n                        tempArr.push(0);\n                    }\n                    config['rowPositions'] = tempArr;\n                }\n                if (config['columnPositions']) {\n                    if (config['columnPositions'].length != cols.length) {\n                        throw Error(\"length of columnPositions array must be equal to number of columns. Got \" + config['columnPositions'].length + \", expected \" + (cols.length - 1));\n                    }\n                }\n                else {\n                    var tempArr = [];\n                    for (var i = 0; i < cols.length - 1; i++) {\n                        tempArr.push(i);\n                    }\n                    config['columnPositions'] = tempArr;\n                }\n                var traces_1 = [];\n                cols.forEach(function (col, i) {\n                    var labels = ndframe[config[\"labels\"]].values;\n                    var values = ndframe[col].values;\n                    var trace = {\n                        labels: labels,\n                        values: values,\n                        name: col,\n                        type: 'pie',\n                        domain: {\n                            row: config['rowPositions'][i],\n                            column: config['columnPositions'][i]\n                        },\n                        hoverinfo: 'label+percent+name',\n                        automargin: true,\n                        textposition: 'outside'\n                    };\n                    traces_1.push(trace);\n                });\n                var _layout = __assign({}, layout);\n                if (!config[\"grid\"]) {\n                    //set default grid\n                    var size = Number((ndframe.shape[1] / 2).toFixed()) + 1;\n                    _layout[\"grid\"] = { rows: size, columns: size };\n                }\n                else {\n                    _layout[\"grid\"] = config[\"grid\"];\n                }\n                Plotly.newPlot(divId, traces_1, _layout, config);\n            }\n        }\n        else {\n            throw new Error(\"Param Error: Please provide a column name for \\\"labels\\\" param\");\n        }\n    }\n};\nexports.piePlot = piePlot;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boxPlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as box chart.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* The precedence of columns to plot is: (x and y => x => y => columns).\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar boxPlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var trace = {\n            y: ndframe.values,\n            type: 'box',\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"x\"] && config[\"y\"]) {\n            //Plotting two columns against each other, when user specifies x and y column names in configuration\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"x\"]);\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"y\"]);\n            var x = ndframe[config.x].values;\n            var y = ndframe[config.y].values;\n            var trace = {\n                x: x,\n                y: y,\n                type: 'box',\n            };\n            var _layout = __assign({ xaxis: {\n                    title: config.x,\n                }, yaxis: {\n                    title: config.y,\n                } }, layout);\n            Plotly.newPlot(divId, [trace], _layout, config);\n        }\n        else if (config[\"x\"] || config[\"y\"]) {\n            //plot single column specified in either of param [x | y] against index\n            if (config[\"x\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.x);\n                var x = ndframe[config.x].values;\n                var y = ndframe.index;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'box',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: config.x,\n                    }, yaxis: {\n                        title: \"Index\",\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n            if (config[\"y\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.y);\n                var x = ndframe.index;\n                var y = ndframe[config.y].values;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'box',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: \"Index\",\n                    }, yaxis: {\n                        title: config.y,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n        }\n        else {\n            //plot specified columns in config param against index\n            // if columns is not specified in config, then plot all columns\n            var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n            var traces_1 = [];\n            cols.forEach(function (col) {\n                var y = ndframe[col].values;\n                var trace = {\n                    y: y,\n                    name: col,\n                    type: 'box',\n                };\n                traces_1.push(trace);\n            });\n            Plotly.newPlot(divId, traces_1, layout, config);\n        }\n    }\n};\nexports.boxPlot = boxPlot;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.violinPlot = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = require(\"./utils\");\n/**\n* Plot Series or DataFrame as violin chart.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* Line plot supports different types of parameters, and the behavior will depend on data specified.\n* The precedence of columns to plot is: (x and y => x => y => columns).\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar violinPlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    if (ndframe instanceof series_1.default) {\n        var trace = {\n            y: ndframe.values,\n            type: 'violin',\n        };\n        Plotly.newPlot(divId, [trace], layout, config);\n    }\n    else {\n        if (config[\"x\"] && config[\"y\"]) {\n            //Plotting two columns against each other, when user specifies x and y column names in configuration\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"x\"]);\n            (0, utils_1.throwErrorOnWrongColName)(ndframe, config[\"y\"]);\n            var x = ndframe[config.x].values;\n            var y = ndframe[config.y].values;\n            var trace = {\n                x: x,\n                y: y,\n                type: 'violin',\n            };\n            var _layout = __assign({ xaxis: {\n                    title: config.x,\n                }, yaxis: {\n                    title: config.y,\n                } }, layout);\n            Plotly.newPlot(divId, [trace], _layout, config);\n        }\n        else if (config[\"x\"] || config[\"y\"]) {\n            //plot single column specified in either of param [x | y] against index\n            if (config[\"x\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.x);\n                var x = ndframe[config.x].values;\n                var y = ndframe.index;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'violin',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: config.x,\n                    }, yaxis: {\n                        title: \"Index\",\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n            if (config[\"y\"]) {\n                (0, utils_1.throwErrorOnWrongColName)(ndframe, config.y);\n                var x = ndframe.index;\n                var y = ndframe[config.y].values;\n                var trace = {\n                    x: x,\n                    y: y,\n                    type: 'violin',\n                };\n                var _layout = __assign({ xaxis: {\n                        title: \"Index\",\n                    }, yaxis: {\n                        title: config.y,\n                    } }, layout);\n                Plotly.newPlot(divId, [trace], _layout, config);\n            }\n        }\n        else {\n            //plot specified columns in config param against index\n            // if columns is not specified in config, then plot all columns\n            var cols = config[\"columns\"] ? (0, utils_1.checkIfColsExist)(ndframe, config['columns']) : ndframe.columns;\n            var traces_1 = [];\n            cols.forEach(function (col) {\n                var y = ndframe[col].values;\n                var trace = {\n                    y: y,\n                    name: col,\n                    type: 'violin',\n                };\n                traces_1.push(trace);\n            });\n            Plotly.newPlot(divId, traces_1, layout, config);\n        }\n    }\n};\nexports.violinPlot = violinPlot;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tablePlot = void 0;\n/**\n* Display Series or DataFrame as table.\n* Uses the Plotly as backend, so supoorts Plotly's configuration parameters,\n* @param ndframe Series or DataFrame to plot\n* @param divId HTML div id to plot in.\n* @param plotConfig configuration options for making Plots, supports Plotly.js Config and Layout parameters.\n*/\nvar tablePlot = function (ndframe, divId, plotConfig, Plotly) {\n    var config = plotConfig[\"config\"];\n    var layout = plotConfig[\"layout\"];\n    var header = {};\n    var cells = {};\n    var colsData = [];\n    var cols2Show = [];\n    if (config['columns']) {\n        config['columns'].forEach(function (cname) {\n            if (!ndframe.columns.includes(cname)) {\n                throw Error(\"Column Error: \" + cname + \" not found in columns. Columns should be one of [ \" + ndframe.columns + \" ]\");\n            }\n            var idx = ndframe.columns.indexOf(cname);\n            colsData.push(ndframe.getColumnData[idx]);\n        });\n        cols2Show = config['columns'];\n    }\n    else {\n        cols2Show = ndframe.columns;\n        colsData = ndframe.getColumnData;\n    }\n    header['values'] = cols2Show.map(function (col) { return [col]; });\n    cells['values'] = colsData;\n    if (config['tableHeaderStyle']) {\n        Object.keys(config['tableHeaderStyle']).forEach(function (param) {\n            header[param] = config['tableHeaderStyle'][param];\n        });\n    }\n    if (config['tableCellStyle']) {\n        Object.keys(config['tableCellStyle']).forEach(function (param) {\n            cells[param] = config['tableCellStyle'][param];\n        });\n    }\n    var trace = {\n        type: 'table',\n        header: header,\n        cells: cells\n    };\n    /* @ts-ignore */\n    Plotly.newPlot(divId, [trace], layout, config);\n};\nexports.tablePlot = tablePlot;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._genericMathOp = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"./series\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Generic function for performing math operations on a series\n * @param object\n *\n * ndframe ==> The current Series\n *\n * other ==> The Series or number to perform math operation with\n *\n * operation ==> The type of operation to perform\n*/\nfunction _genericMathOp(_a) {\n    var ndFrame = _a.ndFrame, other = _a.other, operation = _a.operation;\n    if (typeof other === 'number') {\n        //broadcast operation\n        var newData = void 0;\n        switch (operation) {\n            case 'add':\n                newData = ndFrame.values.map((function (ele) { return ele + other; }));\n                return newData;\n            case 'sub':\n                newData = ndFrame.values.map((function (ele) { return ele - other; }));\n                return newData;\n            case 'mul':\n                newData = ndFrame.values.map((function (ele) { return ele * other; }));\n                return newData;\n            case 'div':\n                newData = ndFrame.values.map((function (ele) { return ele / other; }));\n                return newData;\n            case 'mod':\n                newData = ndFrame.values.map((function (ele) { return ele % other; }));\n                return newData;\n            case 'pow':\n                newData = ndFrame.values.map((function (ele) { return Math.pow(ele, other); }));\n                return newData;\n            case 'minimum':\n                newData = ndFrame.values.map((function (ele) { return Math.min(ele, other); }));\n                return newData;\n            case 'maximum':\n                newData = ndFrame.values.map((function (ele) { return Math.max(ele, other); }));\n                return newData;\n            default:\n                throw new Error(operation + \" is not implemented\");\n        }\n    }\n    else if (other instanceof series_1.default) {\n        utils.checkSeriesOpCompactibility({ firstSeries: ndFrame, secondSeries: other, operation: operation });\n        var newData = void 0;\n        switch (operation) {\n            case 'add':\n                newData = ndFrame.values.map(function (ele, index) { return ele + other.values[index]; });\n                return newData;\n            case 'sub':\n                newData = ndFrame.values.map(function (ele, index) { return ele - other.values[index]; });\n                return newData;\n            case 'mul':\n                newData = ndFrame.values.map(function (ele, index) { return ele * other.values[index]; });\n                return newData;\n            case 'div':\n                newData = ndFrame.values.map(function (ele, index) { return ele / other.values[index]; });\n                return newData;\n            case 'mod':\n                newData = ndFrame.values.map(function (ele, index) { return ele % other.values[index]; });\n                return newData;\n            case 'pow':\n                newData = ndFrame.values.map(function (ele, index) { return Math.pow(ele, other.values[index]); });\n                return newData;\n            case 'minimum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.min(ele, other.values[index]); });\n                return newData;\n            case 'maximum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.max(ele, other.values[index]); });\n                return newData;\n            default:\n                throw new Error(operation + \" is not implemented\");\n        }\n    }\n    else if (Array.isArray(other)) {\n        if (other.length !== ndFrame.values.length) {\n            throw new Error(\"ParamError: Length of array must be equal to length of Series\");\n        }\n        var newData = void 0;\n        switch (operation) {\n            case 'add':\n                newData = ndFrame.values.map(function (ele, index) { return ele + other[index]; });\n                return newData;\n            case 'sub':\n                newData = ndFrame.values.map(function (ele, index) { return ele - other[index]; });\n                return newData;\n            case 'mul':\n                newData = ndFrame.values.map(function (ele, index) { return ele * other[index]; });\n                return newData;\n            case 'div':\n                newData = ndFrame.values.map(function (ele, index) { return ele / other[index]; });\n                return newData;\n            case 'mod':\n                newData = ndFrame.values.map(function (ele, index) { return ele % other[index]; });\n                return newData;\n            case 'pow':\n                newData = ndFrame.values.map(function (ele, index) { return Math.pow(ele, other[index]); });\n                return newData;\n            case 'minimum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.min(ele, other[index]); });\n                return newData;\n            case 'maximum':\n                newData = ndFrame.values.map(function (ele, index) { return Math.max(ele, other[index]); });\n                return newData;\n        }\n    }\n    else {\n        throw new Error(\"ParamError: value for other not supported. It must be either a scalar, Array or Series\");\n    }\n}\nexports._genericMathOp = _genericMathOp;\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Exposes numerous String methods. All methods are applied Element-wise\n */\nvar Str = /** @class */ (function () {\n    function Str(series) {\n        this.series = series;\n        this.values = series.values;\n    }\n    Str.prototype.toLowerCase = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).toLowerCase());\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.toUpperCase = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).toUpperCase());\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.capitalize = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                var firstChar = (\"\" + val).slice(0, 1);\n                var leftChar = (\"\" + val).slice(1);\n                var newStr = \"\" + firstChar.toUpperCase() + leftChar.toLowerCase();\n                newArr.push(newStr);\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.charAt = function (index, options) {\n        if (index === void 0) { index = 0; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).charAt(index));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.concat = function (other, position, options) {\n        if (position === void 0) { position = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        if (Array.isArray(other)) {\n            for (var i = 0; i < other.length; i++) {\n                var leftStr = \"\" + this.values[i];\n                var rightStr = \"\" + other[i];\n                if (position == 1) {\n                    newArr.push(leftStr.concat(rightStr));\n                }\n                else {\n                    newArr.push(rightStr.concat(leftStr));\n                }\n            }\n        }\n        else {\n            this.values.map(function (val) {\n                if (position == 1) {\n                    if (utils.isEmpty(val)) {\n                        newArr.push(NaN);\n                    }\n                    else {\n                        newArr.push((\"\" + val).concat(\"\" + other));\n                    }\n                }\n                else {\n                    if (utils.isEmpty(val)) {\n                        newArr.push(NaN);\n                    }\n                    else {\n                        newArr.push(other.concat(\"\" + val));\n                    }\n                }\n            });\n        }\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.startsWith = function (str, options) {\n        if (str === void 0) { str = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.forEach(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).startsWith(str));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.endsWith = function (str, options) {\n        if (str === void 0) { str = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).endsWith(str));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.includes = function (str, options) {\n        if (str === void 0) { str = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).includes(str));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.indexOf = function (str, options) {\n        if (str === void 0) { str = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).indexOf(str));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.lastIndexOf = function (str, options) {\n        if (str === void 0) { str = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).lastIndexOf(str));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.replace = function (searchValue, replaceValue, options) {\n        if (searchValue === void 0) { searchValue = \"\"; }\n        if (replaceValue === void 0) { replaceValue = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).replace(searchValue, replaceValue));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.repeat = function (num, options) {\n        if (num === void 0) { num = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).repeat(num));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.search = function (str, options) {\n        if (str === void 0) { str = \"\"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).search(str));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.slice = function (startIndex, endIndex, options) {\n        if (startIndex === void 0) { startIndex = 0; }\n        if (endIndex === void 0) { endIndex = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).slice(startIndex, endIndex));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.split = function (splitVal, options) {\n        if (splitVal === void 0) { splitVal = \" \"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push(\"\" + String(val).split(splitVal));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.substr = function (startIndex, num, options) {\n        if (startIndex === void 0) { startIndex = 0; }\n        if (num === void 0) { num = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push(\"\" + String(val).substr(startIndex, num));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.substring = function (startIndex, endIndex, options) {\n        if (startIndex === void 0) { startIndex = 0; }\n        if (endIndex === void 0) { endIndex = 1; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push(\"\" + String(val).substring(startIndex, endIndex));\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.trim = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).trim());\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.join = function (valToJoin, joinChar, options) {\n        if (valToJoin === void 0) { valToJoin = \"\"; }\n        if (joinChar === void 0) { joinChar = \" \"; }\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                var leftChar = val;\n                var rightChar = valToJoin;\n                var new_char = \"\" + leftChar + joinChar + rightChar;\n                newArr.push(new_char);\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    Str.prototype.len = function (options) {\n        var inplace = __assign({ inplace: false }, options).inplace;\n        var newArr = [];\n        this.values.map(function (val) {\n            if (utils.isEmpty(val)) {\n                newArr.push(NaN);\n            }\n            else {\n                newArr.push((\"\" + val).length);\n            }\n        });\n        if (inplace) {\n            this.series.$setValues(newArr);\n            this.series.print();\n        }\n        else {\n            var sf = this.series.copy();\n            sf.$setValues(newArr);\n            return sf;\n        }\n    };\n    return Str;\n}());\nexports.default = Str;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toDateTime = void 0;\nvar series_1 = __importDefault(require(\"./series\"));\nvar WEEK_NAME = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nvar MONTH_NAME = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n/**\n * Format and handle all datetime operations on Series or Array of date strings\n * @param data Series or Array of date strings\n */\nvar TimeSeries = /** @class */ (function () {\n    function TimeSeries(data) {\n        if (data instanceof series_1.default) {\n            this.$dateObjectArray = this.processData(data.values);\n        }\n        else {\n            this.$dateObjectArray = this.processData(data);\n        }\n    }\n    /**\n     * Processed the data values into internal structure for easy access\n     * @param dateArray An array of date strings\n    */\n    TimeSeries.prototype.processData = function (dateArray) {\n        var values = dateArray.map(function (dateString) { return new Date(\"\" + dateString); });\n        return values;\n    };\n    /**\n     *  Returns the month, in local time.\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-01\",\n     * \"2019-03-01\",\n     * \"2019-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const dfNew = df.dt.month()\n     * console.log(dfNew.values)\n     * // [1, 2, 3, 4]\n     * ```\n    */\n    TimeSeries.prototype.month = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getMonth(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the day of the week, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-01\",\n     * \"2019-03-01\",\n     * \"2019-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const dayOfWeek = df.dt.dayOfWeek()\n     * console.log(dayOfWeek.values)\n     * ```\n    */\n    TimeSeries.prototype.dayOfWeek = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getDay(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the year, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-01\",\n     * \"2021-03-01\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const year = df.dt.year()\n     * console.log(year.values)\n     * // [2019, 2019, 2021, 2020]\n     * ```\n    */\n    TimeSeries.prototype.year = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getFullYear(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     *  Returns the name of the month, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-01\",\n     * \"2021-03-01\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const monthName = df.dt.monthName().values\n     * console.log(monthName)\n     * // [\"January\", \"February\", \"March\", \"April\"]\n     * ```\n    */\n    TimeSeries.prototype.monthName = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return MONTH_NAME[date.getMonth()]; });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the name of the day, of the week, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-01\",\n     * \"2021-03-01\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const dayOfWeekName = df.dt.dayOfWeekName().values\n     * console.log(dayOfWeekName)\n     * ```\n    */\n    TimeSeries.prototype.dayOfWeekName = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return WEEK_NAME[date.getDay()]; });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the day of the month, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-05\",\n     * \"2021-03-02\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const dayOfMonth = df.dt.dayOfMonth().values\n     * console.log(dayOfMonth)\n     * // [1, 5, 2, 1]\n     * ```\n    */\n    TimeSeries.prototype.dayOfMonth = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getDate(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the hour of the day, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-05\",\n     * \"2021-03-02\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const hour = df.dt.hour().values\n     * console.log(hour)\n     * // [0, 0, 0, 0]\n     * ```\n    */\n    TimeSeries.prototype.hours = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getHours(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the second of the day, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-05\",\n     * \"2021-03-02\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const second = df.dt.second().values\n     * console.log(second)\n     * ```\n    */\n    TimeSeries.prototype.seconds = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getSeconds(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the minute of the day, in local time\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-05\",\n     * \"2021-03-02\",\n     * \"2020-04-01\",\n     * ]\n     * const df = new Series(data)\n     * const minute = df.dt.minute().values\n     * console.log(minute)\n     * ```\n    */\n    TimeSeries.prototype.minutes = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.getMinutes(); });\n        return new series_1.default(newValues);\n    };\n    /**\n     * Returns the Date as JavaScript standard Date object\n     * @example\n     * ```\n     * import { Series } from \"danfojs-node\"\n     * const data = [\n     * \"2019-01-01\",\n     * \"2019-02-05\",\n     * \"2021-03-02\",\n     * \"2020-04-01\",\n     * ]\n     *\n     * const df = new Series(data)\n     * const date = df.dt.toDate().values\n     * console.log(date)\n     * ```\n    */\n    TimeSeries.prototype.date = function () {\n        var newValues = this.$dateObjectArray.map(function (date) { return date.toLocaleString(); });\n        return new series_1.default(newValues);\n    };\n    return TimeSeries;\n}());\nexports.default = TimeSeries;\nvar toDateTime = function (data) {\n    return new TimeSeries(data);\n};\nexports.toDateTime = toDateTime;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar frame_1 = __importDefault(require(\"../../core/frame\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar tensorflowlib_1 = __importDefault(require(\"../../shared/tensorflowlib\"));\nvar utils = new utils_1.default();\n/**\n * Transform features by scaling each feature to a given range.\n * This estimator scales and translates each feature individually such\n * that it is in the given range on the training set, e.g. between the maximum and minimum value.\n*/\nvar MinMaxScaler = /** @class */ (function () {\n    function MinMaxScaler() {\n        this.$max = tensorflowlib_1.default.tensor1d([]);\n        this.$min = tensorflowlib_1.default.tensor1d([]);\n    }\n    MinMaxScaler.prototype.$getTensor = function (data) {\n        var $tensorArray;\n        if (data instanceof Array) {\n            if (utils.is1DArray(data)) {\n                $tensorArray = tensorflowlib_1.default.tensor1d(data);\n            }\n            else {\n                $tensorArray = tensorflowlib_1.default.tensor2d(data);\n            }\n        }\n        else if (data instanceof frame_1.default || data instanceof series_1.default) {\n            $tensorArray = data.tensor;\n        }\n        else if (data instanceof tensorflowlib_1.default.Tensor) {\n            $tensorArray = data;\n        }\n        else {\n            throw new Error(\"ParamError: data must be one of Array, Tensor, DataFrame or Series\");\n        }\n        return $tensorArray;\n    };\n    /**\n     * Fits a MinMaxScaler to the data\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns MinMaxScaler\n     * @example\n     * const scaler = new MinMaxScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     * // MinMaxScaler {\n     * //   $max: [5],\n     * //   $min: [1]\n     * // }\n     *\n     */\n    MinMaxScaler.prototype.fit = function (data) {\n        var tensorArray = this.$getTensor(data);\n        this.$max = tensorArray.max(0);\n        this.$min = tensorArray.min(0);\n        return this;\n    };\n    /**\n     * Transform the data using the fitted scaler\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns Array, Tensor, DataFrame or Series object\n     * @example\n     * const scaler = new MinMaxScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     * scaler.transform([1, 2, 3, 4, 5])\n     * // [0, 0.25, 0.5, 0.75, 1]\n     * */\n    MinMaxScaler.prototype.transform = function (data) {\n        var tensorArray = this.$getTensor(data);\n        var outputData = tensorArray\n            .sub(this.$min)\n            .div(this.$max.sub(this.$min));\n        if (Array.isArray(data)) {\n            return outputData.arraySync();\n        }\n        else if (data instanceof series_1.default) {\n            return new series_1.default(outputData, {\n                index: data.index,\n            });\n        }\n        else if (data instanceof frame_1.default) {\n            return new frame_1.default(outputData, {\n                index: data.index,\n                columns: data.columns,\n                config: __assign({}, data.config),\n            });\n        }\n        else {\n            return outputData;\n        }\n    };\n    /**\n     * Fit the data and transform it\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns Array, Tensor, DataFrame or Series object\n     * @example\n     * const scaler = new MinMaxScaler()\n     * scaler.fitTransform([1, 2, 3, 4, 5])\n     * // [0, 0.25, 0.5, 0.75, 1]\n     * */\n    MinMaxScaler.prototype.fitTransform = function (data) {\n        this.fit(data);\n        return this.transform(data);\n    };\n    /**\n     * Inverse transform the data using the fitted scaler\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns Array, Tensor, DataFrame or Series object\n     * @example\n     * const scaler = new MinMaxScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     * scaler.inverseTransform([0, 0.25, 0.5, 0.75, 1])\n     * // [1, 2, 3, 4, 5]\n     * */\n    MinMaxScaler.prototype.inverseTransform = function (data) {\n        var tensorArray = this.$getTensor(data);\n        var outputData = tensorArray\n            .mul(this.$max.sub(this.$min))\n            .add(this.$min);\n        if (Array.isArray(data)) {\n            return outputData.arraySync();\n        }\n        else if (data instanceof series_1.default) {\n            return new series_1.default(outputData, {\n                index: data.index,\n            });\n        }\n        else if (data instanceof frame_1.default) {\n            return new frame_1.default(outputData, {\n                index: data.index,\n                columns: data.columns,\n                config: __assign({}, data.config),\n            });\n        }\n        else {\n            return outputData;\n        }\n    };\n    return MinMaxScaler;\n}());\nexports.default = MinMaxScaler;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tensorflowlib_1 = __importDefault(require(\"../../shared/tensorflowlib\"));\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar frame_1 = __importDefault(require(\"../../core/frame\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Standardize features by removing the mean and scaling to unit variance.\n * The standard score of a sample x is calculated as: `z = (x - u) / s`,\n * where `u` is the mean of the training samples, and `s` is the standard deviation of the training samples.\n */\nvar StandardScaler = /** @class */ (function () {\n    function StandardScaler() {\n        this.$std = tensorflowlib_1.default.tensor1d([]);\n        this.$mean = tensorflowlib_1.default.tensor1d([]);\n    }\n    StandardScaler.prototype.$getTensor = function (data) {\n        var $tensorArray;\n        if (data instanceof Array) {\n            if (utils.is1DArray(data)) {\n                $tensorArray = tensorflowlib_1.default.tensor1d(data);\n            }\n            else {\n                $tensorArray = tensorflowlib_1.default.tensor2d(data);\n            }\n        }\n        else if (data instanceof frame_1.default || data instanceof series_1.default) {\n            $tensorArray = data.tensor;\n        }\n        else if (data instanceof tensorflowlib_1.default.Tensor) {\n            $tensorArray = data;\n        }\n        else {\n            throw new Error(\"ParamError: data must be one of Array, DataFrame or Series\");\n        }\n        return $tensorArray;\n    };\n    /**\n     * Fit a StandardScaler to the data.\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns StandardScaler\n     * @example\n     * const scaler = new StandardScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     */\n    StandardScaler.prototype.fit = function (data) {\n        var tensorArray = this.$getTensor(data);\n        this.$std = tensorflowlib_1.default.moments(tensorArray, 0).variance.sqrt();\n        this.$mean = tensorArray.mean(0);\n        return this;\n    };\n    /**\n     * Transform the data using the fitted scaler\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns Array, Tensor, DataFrame or Series object\n     * @example\n     * const scaler = new StandardScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     * scaler.transform([1, 2, 3, 4, 5])\n     * // [0.0, 0.0, 0.0, 0.0, 0.0]\n     * */\n    StandardScaler.prototype.transform = function (data) {\n        var tensorArray = this.$getTensor(data);\n        var outputData = tensorArray.sub(this.$mean).div(this.$std);\n        if (Array.isArray(data)) {\n            return outputData.arraySync();\n        }\n        else if (data instanceof series_1.default) {\n            return new series_1.default(outputData, {\n                index: data.index,\n            });\n        }\n        else if (data instanceof frame_1.default) {\n            return new frame_1.default(outputData, {\n                index: data.index,\n                columns: data.columns,\n                config: __assign({}, data.config),\n            });\n        }\n        else {\n            return outputData;\n        }\n    };\n    /**\n     * Fit and transform the data using the fitted scaler\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns Array, Tensor, DataFrame or Series object\n     * @example\n     * const scaler = new StandardScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     * scaler.fitTransform([1, 2, 3, 4, 5])\n     * // [0.0, 0.0, 0.0, 0.0, 0.0]\n     * */\n    StandardScaler.prototype.fitTransform = function (data) {\n        this.fit(data);\n        return this.transform(data);\n    };\n    /**\n     * Inverse transform the data using the fitted scaler\n     * @param data Array, Tensor, DataFrame or Series object\n     * @returns Array, Tensor, DataFrame or Series object\n     * @example\n     * const scaler = new StandardScaler()\n     * scaler.fit([1, 2, 3, 4, 5])\n     * scaler.transform([1, 2, 3, 4, 5])\n     * // [0.0, 0.0, 0.0, 0.0, 0.0]\n     * scaler.inverseTransform([0.0, 0.0, 0.0, 0.0, 0.0])\n     * // [1, 2, 3, 4, 5]\n     * */\n    StandardScaler.prototype.inverseTransform = function (data) {\n        var tensorArray = this.$getTensor(data);\n        var outputData = tensorArray.mul(this.$std).add(this.$mean);\n        if (Array.isArray(data)) {\n            return outputData.arraySync();\n        }\n        else if (data instanceof series_1.default) {\n            return new series_1.default(outputData, {\n                index: data.index,\n            });\n        }\n        else if (data instanceof frame_1.default) {\n            return new frame_1.default(outputData, {\n                index: data.index,\n                columns: data.columns,\n                config: __assign({}, data.config),\n            });\n        }\n        else {\n            return outputData;\n        }\n    };\n    return StandardScaler;\n}());\nexports.default = StandardScaler;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tensorflowlib_1 = __importDefault(require(\"../../shared/tensorflowlib\"));\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Encode target labels with value between 0 and n_classes-1.\n */\nvar LabelEncoder = /** @class */ (function () {\n    function LabelEncoder() {\n        this.$labels = {};\n    }\n    LabelEncoder.prototype.$getData = function (data) {\n        var $data;\n        if (data instanceof Array) {\n            if (utils.is1DArray(data)) {\n                $data = data;\n            }\n            else {\n                throw new Error(\"ValueError: data must be a 1D array.\");\n            }\n        }\n        else if (data instanceof series_1.default) {\n            $data = data.values;\n        }\n        else if (data instanceof tensorflowlib_1.default.Tensor) {\n            $data = data.arraySync();\n        }\n        else {\n            throw new Error(\"ParamError: data must be one of Array, 1d Tensor or Series.\");\n        }\n        return $data;\n    };\n    /**\n     * Maps values to unique integer labels between 0 and n_classes-1.\n     * @param data 1d array of labels, Tensor, or  Series to fit.\n     * @example\n     * ```\n     * const encoder = new LabelEncoder()\n     * encoder.fit([\"a\", \"b\", \"c\", \"d\"])\n     * ```\n    */\n    LabelEncoder.prototype.fit = function (data) {\n        var $data = this.$getData(data);\n        var dataSet = Array.from(new Set($data));\n        var tempObj = {};\n        dataSet.forEach(function (value, index) {\n            tempObj[value] = index;\n        });\n        this.$labels = tempObj;\n        return this;\n    };\n    /**\n     * Encode labels with value between 0 and n_classes-1.\n     * @param data 1d array of labels, Tensor, or  Series to be encoded.\n     * @example\n     * ```\n     * const encoder = new LabelEncoder()\n     * encoder.fit([\"a\", \"b\", \"c\", \"d\"])\n     * console.log(encoder.transform([\"a\", \"b\", \"c\", \"d\"]))\n     * // [0, 1, 2, 3]\n     * ```\n    */\n    LabelEncoder.prototype.transform = function (data) {\n        var _this = this;\n        var $data = this.$getData(data);\n        var encodedData = $data.map(function (value) {\n            var label = _this.$labels[value] !== undefined ? _this.$labels[value] : -1;\n            return label;\n        });\n        if (data instanceof Array) {\n            return encodedData;\n        }\n        else if (data instanceof series_1.default) {\n            return new series_1.default(encodedData);\n        }\n        else {\n            return tensorflowlib_1.default.tensor1d(encodedData);\n        }\n    };\n    /**\n     * Fit and transform data in one step.\n     * @param data 1d array of labels, Tensor, or  Series to be encoded.\n     * @example\n     * ```\n     * const encoder = new LabelEncoder()\n     * encoder.fitTransform([\"a\", \"b\", \"c\", \"d\"])\n     * // [0, 1, 2, 3]\n     * ```\n     */\n    LabelEncoder.prototype.fitTransform = function (data) {\n        this.fit(data);\n        return this.transform(data);\n    };\n    /**\n     * Inverse transform values back to original values.\n     * @param data 1d array of labels, Tensor, or  Series to be decoded.\n     * @example\n     * ```\n     * const encoder = new LabelEncoder()\n     * encoder.fit([\"a\", \"b\", \"c\", \"d\"])\n     * console.log(encoder.inverseTransform([0, 1, 2, 3]))\n     * // [\"a\", \"b\", \"c\", \"d\"]\n     * ```\n    */\n    LabelEncoder.prototype.inverseTransform = function (data) {\n        var _this = this;\n        var $data = this.$getData(data);\n        var tempData = $data.map(function (value) {\n            return Object.keys(_this.$labels).find(function (key) { return _this.$labels[key] === value; });\n        });\n        var decodedData = tempData.map(function (value) {\n            if (isNaN(parseInt(value))) {\n                return value;\n            }\n            else {\n                return Number(value);\n            }\n        });\n        if (data instanceof Array) {\n            return decodedData;\n        }\n        else if (data instanceof series_1.default) {\n            return new series_1.default(decodedData);\n        }\n        else {\n            return tensorflowlib_1.default.tensor1d(decodedData);\n        }\n    };\n    Object.defineProperty(LabelEncoder.prototype, \"nClasses\", {\n        /**\n         * Get the number of classes.\n         * @returns number of classes.\n         * @example\n         * ```\n         * const encoder = new LabelEncoder()\n         * encoder.fit([\"a\", \"b\", \"c\", \"d\"])\n         * console.log(encoder.nClasses)\n         * // 4\n         * ```\n         */\n        get: function () {\n            return Object.keys(this.$labels).length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(LabelEncoder.prototype, \"classes\", {\n        /**\n         * Get the mapping of classes to integers.\n         * @returns mapping of classes to integers.\n         * @example\n         * ```\n         * const encoder = new LabelEncoder()\n         * encoder.fit([\"a\", \"b\", \"c\", \"d\"])\n         * console.log(encoder.classes)\n         * // {a: 0, b: 1, c: 2, d: 3}\n         * ```\n        */\n        get: function () {\n            return this.$labels;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return LabelEncoder;\n}());\nexports.default = LabelEncoder;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar frame_1 = __importDefault(require(\"../../core/frame\"));\nvar tensorflowlib_1 = __importDefault(require(\"../../shared/tensorflowlib\"));\nvar series_1 = __importDefault(require(\"../../core/series\"));\nvar utils_1 = __importDefault(require(\"../../shared/utils\"));\nvar utils = new utils_1.default();\n/**\n * Fits a OneHotEncoder to the data.\n * @example\n * ```js\n * const encoder = new OneHotEncoder()\n * encoder.fit([\"a\", \"b\", \"c\"])\n * ```\n*/\nvar OneHotEncoder = /** @class */ (function () {\n    function OneHotEncoder() {\n        this.$labels = [];\n    }\n    OneHotEncoder.prototype.$getData = function (data) {\n        var $data;\n        if (data instanceof Array) {\n            if (utils.is1DArray(data)) {\n                $data = data;\n            }\n            else {\n                throw new Error(\"ValueError: data must be a 1D array.\");\n            }\n        }\n        else if (data instanceof series_1.default) {\n            $data = data.values;\n        }\n        else if (data instanceof tensorflowlib_1.default.Tensor) {\n            $data = data.arraySync();\n        }\n        else {\n            throw new Error(\"ParamError: data must be one of Array, 1d Tensor or Series.\");\n        }\n        return $data;\n    };\n    /**\n     * Fits a OneHotEncoder to the data.\n     * @param data 1d array of labels, Tensor, or  Series to be encoded.\n     * @returns OneHotEncoder\n     * @example\n     * ```js\n     * const encoder = new OneHotEncoder()\n     * encoder.fit([\"a\", \"b\", \"c\"])\n     * ```\n    */\n    OneHotEncoder.prototype.fit = function (data) {\n        var $data = this.$getData(data);\n        var dataSet = Array.from(new Set($data));\n        this.$labels = dataSet;\n        return this;\n    };\n    /**\n     * Encodes the data using the fitted OneHotEncoder.\n     * @param data 1d array of labels, Tensor, or  Series to be encoded.\n     * @example\n     * ```js\n     * const encoder = new OneHotEncoder()\n     * encoder.fit([\"a\", \"b\", \"c\"])\n     * encoder.transform([\"a\", \"b\", \"c\"])\n     * ```\n     */\n    OneHotEncoder.prototype.transform = function (data) {\n        var $data = this.$getData(data);\n        var oneHotArr = utils.zeros($data.length, this.$labels.length);\n        for (var i = 0; i < $data.length; i++) {\n            var index = this.$labels.indexOf($data[i]);\n            oneHotArr[i][index] = 1;\n        }\n        if (data instanceof Array) {\n            return oneHotArr;\n        }\n        else if (data instanceof series_1.default) {\n            return new frame_1.default(oneHotArr, {\n                index: data.index,\n            });\n        }\n        else {\n            return tensorflowlib_1.default.tensor1d(oneHotArr);\n        }\n    };\n    /**\n     * Fit and transform the data using the fitted OneHotEncoder.\n     * @param data 1d array of labels, Tensor, or  Series to be encoded.\n     * @example\n     * ```js\n     * const encoder = new OneHotEncoder()\n     * encoder.fitTransform([\"a\", \"b\", \"c\"])\n     * ```\n     */\n    OneHotEncoder.prototype.fitTransform = function (data) {\n        this.fit(data);\n        return this.transform(data);\n    };\n    return OneHotEncoder;\n}());\nexports.default = OneHotEncoder;\n","\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar frame_1 = __importDefault(require(\"../core/frame\"));\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\nvar Merge = /** @class */ (function () {\n    function Merge(_a) {\n        var left = _a.left, right = _a.right, on = _a.on, how = _a.how;\n        this.leftColIndex = [];\n        this.rightColIndex = [];\n        this.left = left;\n        this.right = right;\n        this.on = on;\n        this.how = how;\n        //Obtain the column index of the column will\n        //want to merge on for both left and right dataframe\n        for (var i = 0; i < this.on.length; i++) {\n            var key = this.on[i];\n            if (this.left.columns.includes(key) && this.right.columns.includes(key)) {\n                var leftIndex = this.left.columns.indexOf(key);\n                var rightIndex = this.right.columns.indexOf(key);\n                this.leftColIndex.push(leftIndex);\n                this.rightColIndex.push(rightIndex);\n            }\n        }\n    }\n    /**\n     * Generate key combination base on the columns we want to merge on\n     * e.g  df = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  B: [3,4,5,6]\n     * }\n     * keycomb = generateKeyCombination(df.values, [0,1])\n     * This should output\n     * {\n     *  'k0_k1': {\n     *      filters: [[1,3], [2,4]], # the value of other columns in thesame row with the combination keys\n     *      combValues: [\"KO\", \"k1\"] # the combination key from column Key1 (index 2) and key2 (index 1)\n     *  },\n     *  'K3_K3 : {\n     *      filters: [[3,5]],\n     *      combValues: ['K3', 'k3']\n     *  },\n     *  'k4_k5' : {\n     *      filters: [[4,6]]\n     *      combValues: ['K4', 'K5']\n     *  }\n     * }\n     * This key combination will be generated for both left and right dataframe\n     * @param values\n     * @param colIndex\n     */\n    Merge.prototype.generateKeyCombination = function (values, colIndex) {\n        var colKeyComb = {};\n        for (var i = 0; i < values.length; i++) {\n            var rowValues = values[i];\n            var rowKeyCombValues = [];\n            for (var j = 0; j < colIndex.length; j++) {\n                var index = colIndex[j];\n                rowKeyCombValues.push(rowValues[index]);\n            }\n            var rowKeyComb = rowKeyCombValues.join('_');\n            var otherValues = rowValues.filter(function (val, index) {\n                return !colIndex.includes(index);\n            });\n            if (utils.keyInObject(colKeyComb, rowKeyComb)) {\n                colKeyComb[rowKeyComb].filters.push(otherValues);\n            }\n            else {\n                colKeyComb[rowKeyComb] = {\n                    filters: [otherValues],\n                    combValues: rowKeyCombValues\n                };\n            }\n        }\n        return colKeyComb;\n    };\n    /**\n     * Generate columns for the newly generated merged DataFrame\n     * e.g df = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  B: [3,4,5,6]\n     * }\n     * df2 = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  c: [3,4,5,6]\n     * }\n     * And both dataframe are to be merged on `key1` and `key2`\n     * the newly generated column will be of the form\n     * columns = ['key1', 'Key2', 'A', 'A_1', 'B', 'C']\n     * Notice 'A_1' , this because both DataFrame as column A and 1 is the\n     * number of duplicate of that column\n     */\n    Merge.prototype.createColumns = function () {\n        var self = this;\n        this.leftCol = self.left.columns.filter(function (_, index) {\n            return !self.leftColIndex.includes(index);\n        });\n        this.rightCol = self.right.columns.filter(function (_, index) {\n            return !self.rightColIndex.includes(index);\n        });\n        this.columns = __spreadArray([], this.on, true);\n        var duplicateColumn = {};\n        var tempColumn = __spreadArray([], this.leftCol, true);\n        tempColumn.push.apply(tempColumn, this.rightCol);\n        for (var i = 0; i < tempColumn.length; i++) {\n            var col = tempColumn[i];\n            if (utils.keyInObject(duplicateColumn, col)) {\n                var columnName = col + \"_\" + duplicateColumn[col];\n                this.columns.push(columnName);\n                duplicateColumn[col] += 1;\n            }\n            else {\n                this.columns.push(col);\n                duplicateColumn[col] = 1;\n            }\n        }\n    };\n    /**\n     * The basic methos perform the underneath operation of generating\n     * the merge dataframe; using the combination keys generated from\n     * bothe left and right DataFrame\n     * e.g df = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K1\", \"K3\", \"K5\"],\n     *  A: [1,2,3,4]\n     *  B: [3,4,5,6]\n     * }\n     * df2 = {\n     *  key1: [\"KO\", \"K0\", \"K3\", \"K4\"],\n     *  Key2: [\"K1\", \"K2\", \"K4\", \"K5\"],\n     *  A: [3,6,8,9]\n     *  c: [2,4,6,8]\n     * }\n     * Running generatekeyCombination on both left and right data frame\n     * we should have\n     * leftKeyDict = {\n     *  'k0_k1': {\n     *      filters: [[1,3], [2,4]],\n     *      combValues: [\"KO\", \"k1\"]\n     *  },\n     *  'K3_K3' : {\n     *      filters: [[3,5]],\n     *      combValues: ['K3', 'k3']\n     *  },\n     *  'k4_k5' : {\n     *      filters: [[4,6]]\n     *      combValues: ['K4', 'K5']\n     *  }\n     * }\n     * rightKeyDict = {\n     *  'k0_k1': {\n     *      filters: [[3,2]],\n     *      combValues: [\"KO\", \"k1\"]\n     *  },\n     *  'K0_K2': {\n     *      filters: [[6,4]],\n     *      combValues: ['K0', 'K2']\n     *  },\n     *  'K3_K4' : {\n     *      filters: [[8,9]],\n     *      combValues: ['K3', 'k4']\n     *  },\n     *  'k4_k5' : {\n     *      filters: [[9,8]]\n     *      combValues: ['K4', 'K5']\n     *  }\n     * }\n     * The `keys` is generated base on the type of merge operation we want to\n     * perform. If we assume we are performing `outer` merge (which is a set of the\n     * key combination from both leftKeyDict and rightKeyDict) then Keys should be\n     * this\n     * keys = ['K0_K1', 'K3_K3', 'k4_k5', 'K0_K2', 'k3_k4']\n     * The Keys, leftKeyDict and rightKeyDict are used to generated DataFrame data,\n     * by looping through the Keys and checking if leftKeyDict and rightKeyDict as the\n     * key if one of them does not the column in that row will be NaN\n     * e.g Data for each row base on keys\n     * COLUMNS = ['key1', 'Key2', 'A', 'B', 'A_1', 'C']\n     * 'K0_K1':  ['K0',   'K1',   1,    3 ,   3,   2 ]\n     * 'K0_K1':  ['K0',   'K1',   2,    4,   NaN, NaN]\n     * 'K3_K3':  ['k3',   'K3',   3,    5,  NaN,  NaN]\n     * 'K4_K5':  ['K4',   'K5',   4,    6,  9,    8]\n     * 'k0_K2':  ['k0',   'K2'    NaN,  NaN, 6,   4]\n     * 'k3_k4':  ['K3',   'K4',   NaN,  NaN, 8, 6]\n     *\n     * @param keys\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.basic = function (keys, leftKeyDict, rightKeyDict) {\n        var _a, _b;\n        var data = [];\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (utils.keyInObject(leftKeyDict, key)) {\n                var leftRows = leftKeyDict[key].filters;\n                var leftCombValues = leftKeyDict[key].combValues;\n                for (var lIndex = 0; lIndex < leftRows.length; lIndex++) {\n                    var leftRow = leftRows[lIndex];\n                    if (utils.keyInObject(rightKeyDict, key)) {\n                        var rightRows = rightKeyDict[key].filters;\n                        for (var rIndex = 0; rIndex < rightRows.length; rIndex++) {\n                            var rightRow = rightRows[rIndex];\n                            var combineData = leftCombValues.slice(0);\n                            combineData.push.apply(combineData, leftRow);\n                            combineData.push.apply(combineData, rightRow);\n                            data.push(combineData);\n                        }\n                    }\n                    else {\n                        var nanArray = Array((_a = this.rightCol) === null || _a === void 0 ? void 0 : _a.length).fill(NaN);\n                        var combineData = leftCombValues.slice(0);\n                        combineData.push.apply(combineData, leftRow);\n                        combineData.push.apply(combineData, nanArray);\n                        data.push(combineData);\n                    }\n                }\n            }\n            else {\n                var rightRows = rightKeyDict[key].filters;\n                var rightCombValues = rightKeyDict[key].combValues;\n                for (var i_1 = 0; i_1 < rightRows.length; i_1++) {\n                    var rightRow = rightRows[i_1];\n                    var nanArray = Array((_b = this.leftCol) === null || _b === void 0 ? void 0 : _b.length).fill(NaN);\n                    var combineData = rightCombValues.slice(0);\n                    combineData.push.apply(combineData, nanArray);\n                    combineData.push.apply(combineData, rightRow);\n                    data.push(combineData);\n                }\n            }\n        }\n        return data;\n    };\n    /**\n     * Generate outer key from leftKeyDict and rightKeyDict\n     * The Key pass into basic method is the union of\n     * leftKeyDict and rightKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.outer = function (leftKeyDict, rightKeyDict) {\n        var keys = Object.keys(leftKeyDict);\n        keys.push.apply(keys, Object.keys(rightKeyDict));\n        var UniqueKeys = Array.from(new Set(keys));\n        var data = this.basic(UniqueKeys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * Generate Key for basic method,\n     * the key geneerated is the intersection of\n     * leftKeyDict and rightKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.inner = function (leftKeyDict, rightKeyDict) {\n        var leftKey = Object.keys(leftKeyDict);\n        var rightKey = Object.keys(rightKeyDict);\n        var keys = leftKey.filter(function (val) { return rightKey.includes(val); });\n        var data = this.basic(keys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * The key is the leftKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.leftMerge = function (leftKeyDict, rightKeyDict) {\n        var keys = Object.keys(leftKeyDict);\n        var data = this.basic(keys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * The key is the rightKeyDict\n     * @param leftKeyDict\n     * @param rightKeyDict\n     */\n    Merge.prototype.rightMerge = function (leftKeyDict, rightKeyDict) {\n        var keys = Object.keys(rightKeyDict);\n        var data = this.basic(keys, leftKeyDict, rightKeyDict);\n        return data;\n    };\n    /**\n     * Perform the merge operation\n     * 1) Obtain both left and right dataframe values\n     * 2) Generate the leftkeyDict and rightKeyDict\n     * 3) Generate new merge columns\n     * 4) check how merge is to be done and apply the\n     * right methods\n     */\n    Merge.prototype.operation = function () {\n        var leftValues = this.left.values;\n        var rightValues = this.right.values;\n        var leftKeyDict = this.generateKeyCombination(leftValues, this.leftColIndex);\n        var rightKeyDict = this.generateKeyCombination(rightValues, this.rightColIndex);\n        this.createColumns();\n        var data = [];\n        switch (this.how) {\n            case \"outer\":\n                data = this.outer(leftKeyDict, rightKeyDict);\n                break;\n            case \"inner\":\n                data = this.inner(leftKeyDict, rightKeyDict);\n                break;\n            case \"left\":\n                data = this.leftMerge(leftKeyDict, rightKeyDict);\n                break;\n            case \"right\":\n                data = this.rightMerge(leftKeyDict, rightKeyDict);\n                break;\n        }\n        var columns = this.columns;\n        return new frame_1.default(data, { columns: __spreadArray([], columns, true) });\n    };\n    return Merge;\n}());\n/**\n * Perform merge operation between two DataFrame\n * @param params : {\n * left: DataFrame\n * right: DataFrame\n * on: Array<string>\n * how: \"outer\" | \"inner\" | \"left\" | \"right\"\n * }\n */\nfunction merge(params) {\n    var mergeClass = new Merge(params);\n    return mergeClass.operation();\n}\nexports.default = merge;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar utils_1 = __importDefault(require(\"../shared/utils\"));\nvar utils = new utils_1.default();\nvar DateRange = /** @class */ (function () {\n    function DateRange(_a) {\n        var start = _a.start, end = _a.end, offset = _a.offset, freq = _a.freq, period = _a.period;\n        this.start = start;\n        this.end = end;\n        this.offset = offset;\n        this.freq = freq ? freq : \"D\";\n        this.period = period;\n        this.freqList = [\"M\", \"D\", \"s\", \"H\", \"m\", \"Y\"];\n        if (this.freq.length == 1) {\n            if (!this.freqList.includes(this.freq)) {\n                throw new Error(\"invalid freq \" + this.freq);\n            }\n        }\n        else {\n            this.offset = parseInt(this.freq.slice(0, -1));\n            if (!Number.isFinite(this.offset)) {\n                throw new Error(\"invalid freq offset \" + this.freq.slice(0, -1));\n            }\n            this.freq = this.freq.slice(-1);\n            if (!this.freqList.includes(this.freq)) {\n                throw new Error(\"invalid freq \" + this.freq);\n            }\n        }\n    }\n    DateRange.prototype.range = function () {\n        var _this = this;\n        var start = this.start;\n        var period = this.period;\n        var end = this.end;\n        var offset = this.offset;\n        var startDate;\n        var endDate;\n        var startRange;\n        var endRange;\n        if (start && end) {\n            startDate = new Date(start);\n            startRange = this.freqType(startDate, this.freq);\n            endDate = new Date(end);\n            endRange = this.freqType(endDate, this.freq);\n            var startYear = startDate.getFullYear();\n            var endYear = endDate.getFullYear();\n            if ((startYear <= endYear) && (startDate.getMonth() !== endDate.getMonth())) {\n                if (this.freq == \"M\") {\n                    endRange = this.monthEnd(startDate, endDate);\n                }\n                else if (this.freq === \"D\") {\n                    endRange = this.dayEnd(startDate, endDate) - startRange;\n                }\n            }\n            var rangeArray_1 = utils.range(startRange, endRange);\n            if (offset) {\n                rangeArray_1 = this.offsetCount(rangeArray_1, offset);\n            }\n            var dateRange_1 = rangeArray_1.map(function (x) {\n                return _this.setDateProps(startDate, _this.freq, x);\n            });\n            dateRange_1[dateRange_1.length - 1] = endDate;\n            var dateString_1 = this.toLocalString(dateRange_1);\n            return dateString_1;\n        }\n        else if (start && !(end)) {\n            startDate = new Date(start);\n            startRange = this.freqType(startDate, this.freq);\n            period = period;\n            endRange = offset ? ((period * offset) - 1) : period - 1;\n            if (startRange > endRange) {\n                endRange = endRange + startRange;\n            }\n            var rangeArray_2 = utils.range(startRange, endRange);\n            if (offset) {\n                rangeArray_2 = this.offsetCount(rangeArray_2, offset);\n            }\n            var dateRange_2 = rangeArray_2.map(function (x) {\n                return _this.setDateProps(startDate, _this.freq, x);\n            });\n            var dateString_2 = this.toLocalString(dateRange_2);\n            return dateString_2;\n        }\n        // if end and not start given\n        endDate = new Date(end);\n        endRange = this.freqType(endDate, this.freq);\n        period = period;\n        startRange = (endRange - period) + 1;\n        var rangeArray = utils.range(startRange, endRange);\n        if (offset) {\n            rangeArray = this.offsetCount(rangeArray, offset);\n        }\n        var dateRange = rangeArray.map(function (x) {\n            return _this.setDateProps(endDate, _this.freq, x);\n        });\n        var dateString = this.toLocalString(dateRange);\n        return dateString;\n    };\n    /**\n     * @param date Date\n     * @param ftype string:  frequency type, month, Year, day etc\n     * @param number\n     */\n    DateRange.prototype.freqType = function (date, ftype) {\n        var rslt = 0;\n        switch (ftype) {\n            case \"M\":\n                rslt = date.getMonth();\n                break;\n            case \"Y\":\n                rslt = date.getFullYear();\n                break;\n            case \"s\":\n                rslt = date.getSeconds();\n                break;\n            case \"D\":\n                rslt = date.getDate();\n                break;\n            case \"H\":\n                rslt = date.getHours();\n                break;\n            case \"m\":\n                rslt = date.getMinutes();\n                break;\n        }\n        return rslt;\n    };\n    DateRange.prototype.offsetCount = function (dArray, offset) {\n        var rArray = [];\n        for (var i = 0; i < dArray.length; i += offset) {\n            rArray.push(dArray[i]);\n        }\n        return rArray;\n    };\n    DateRange.prototype.setDateProps = function (date, ftype, val) {\n        var newDate = new Date(date.valueOf());\n        switch (ftype) {\n            case \"M\":\n                if (Array.isArray(val)) {\n                    newDate.setFullYear(newDate.getFullYear() + val[0]);\n                    newDate.setMonth(val[1]);\n                }\n                else {\n                    newDate.setMonth(val);\n                }\n                break;\n            case \"Y\":\n                newDate.setFullYear(val);\n                break;\n            case \"s\":\n                newDate.setSeconds(val);\n                break;\n            case \"D\":\n                newDate.setDate(val);\n                break;\n            case \"H\":\n                newDate.setHours(val);\n                break;\n            case \"m\":\n                newDate.setMinutes(val);\n                break;\n        }\n        return newDate;\n    };\n    DateRange.prototype.toLocalString = function (dArray) {\n        var r_array = dArray.map(function (x) {\n            return x.toLocaleString();\n        });\n        return r_array;\n    };\n    DateRange.prototype.monthEnd = function (startDate, endDate) {\n        var endMonth = endDate.getMonth();\n        var diffYear = endDate.getFullYear() - startDate.getFullYear();\n        var endRange = (12 * diffYear) + endMonth;\n        return endRange;\n    };\n    DateRange.prototype.monthRange = function (range) {\n        var minus;\n        var yVal = 0;\n        var dateRange = range.map(function (x) {\n            if (x > 11) {\n                if (x % 12 == 0) {\n                    minus = x;\n                    yVal = x / 12;\n                    return [yVal, (x - minus)];\n                }\n                else {\n                    return [yVal, (x - minus)];\n                }\n            }\n            return [yVal, x];\n        });\n        return dateRange;\n    };\n    DateRange.prototype.dayEnd = function (startDate, endDate) {\n        var monthEnd = this.monthEnd(startDate, endDate);\n        var range = utils.range(startDate.getMonth(), monthEnd);\n        var mRange = this.monthRange(range);\n        var sum = 0;\n        for (var i = 0; i < mRange.length; i++) {\n            var val = mRange[i];\n            var dDate = void 0;\n            if (i === mRange.length - 1) {\n                dDate = new Date(startDate.getUTCFullYear() + val[0], val[1], endDate.getDate()).getDate();\n            }\n            else {\n                dDate = new Date(startDate.getUTCFullYear() + val[0], val[1], 0).getDate();\n            }\n            sum += dDate;\n        }\n        return sum;\n    };\n    return DateRange;\n}());\n/**\n * Generate sequence of Dates\n * @param start : signify the date to start with\n * @param end : signify the date to end with\n * @param period :  the total number of date to generate\n * @param offset : set the date range offset\n * @param freq: set the date range frequency and offset\n * @return string[]\n */\nfunction dateRange(param) {\n    var dateRange = new DateRange(param);\n    return dateRange.range();\n}\nexports.default = dateRange;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toExcelBrowser = exports.readExcelBrowser = exports.toJSONBrowser = exports.readJSONBrowser = exports.toCSVBrowser = exports.streamCSVBrowser = exports.readCSVBrowser = void 0;\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar io_csv_1 = require(\"./io.csv\");\nObject.defineProperty(exports, \"readCSVBrowser\", { enumerable: true, get: function () { return io_csv_1.$readCSV; } });\nObject.defineProperty(exports, \"streamCSVBrowser\", { enumerable: true, get: function () { return io_csv_1.$streamCSV; } });\nObject.defineProperty(exports, \"toCSVBrowser\", { enumerable: true, get: function () { return io_csv_1.$toCSV; } });\nvar io_json_1 = require(\"./io.json\");\nObject.defineProperty(exports, \"readJSONBrowser\", { enumerable: true, get: function () { return io_json_1.$readJSON; } });\nObject.defineProperty(exports, \"toJSONBrowser\", { enumerable: true, get: function () { return io_json_1.$toJSON; } });\nvar io_excel_1 = require(\"./io.excel\");\nObject.defineProperty(exports, \"readExcelBrowser\", { enumerable: true, get: function () { return io_excel_1.$readExcel; } });\nObject.defineProperty(exports, \"toExcelBrowser\", { enumerable: true, get: function () { return io_excel_1.$toExcel; } });\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$toCSV = exports.$streamCSV = exports.$readCSV = void 0;\nvar __1 = require(\"../../\");\nvar papaparse_1 = __importDefault(require(\"papaparse\"));\n/**\n * Reads a CSV file from local or remote location into a DataFrame.\n * @param filePath URL or local file path to CSV file. `readCSV` uses PapaParse to parse the CSV file,\n * hence all PapaParse options are supported.\n * @param options Configuration object. Supports all Papaparse parse config options.\n * @returns DataFrame containing the parsed CSV file.\n * @example\n * ```\n * import { readCSV } from \"danfojs-node\"\n * const df = await readCSV(\"https://raw.githubusercontent.com/test.csv\")\n * ```\n * @example\n * ```\n * import { readCSV } from \"danfojs-node\"\n * const df = await readCSV(\"https://raw.githubusercontent.com/test.csv\", {\n *    delimiter: \",\",\n *    headers: {\n *      Accept: \"text/csv\",\n *      Authorization: \"Bearer YWRtaW46YWRtaW4=\"\n *    }\n * })\n * ```\n * @example\n * ```\n * import { readCSV } from \"danfojs-node\"\n * const df = await readCSV(\"./data/sample.csv\")\n * ```\n */\nvar $readCSV = function (file, options) { return __awaiter(void 0, void 0, void 0, function () {\n    var frameConfig;\n    return __generator(this, function (_a) {\n        frameConfig = (options === null || options === void 0 ? void 0 : options.frameConfig) || {};\n        return [2 /*return*/, new Promise(function (resolve) {\n                papaparse_1.default.parse(file, __assign(__assign({ header: true, dynamicTyping: true, skipEmptyLines: 'greedy' }, options), { download: true, complete: function (results) {\n                        var df = new __1.DataFrame(results.data, frameConfig);\n                        resolve(df);\n                    } }));\n            })];\n    });\n}); };\nexports.$readCSV = $readCSV;\n/**\n * Streams a CSV file from local or remote location in chunks. Intermediate chunks is passed as a DataFrame to the callback function.\n * @param filePath URL or local file path to CSV file. `readCSV` uses PapaParse to parse the CSV file,\n * hence all PapaParse options are supported.\n * @param options Configuration object. Supports all Papaparse parse config options.\n * @param callback Callback function to be called once the specifed rows are parsed into DataFrame.\n * @example\n * ```\n * import { streamCSV } from \"danfojs-node\"\n * streamCSV(\"https://raw.githubusercontent.com/test.csv\", (dfRow) => {\n *     const dfModified = dfRow[\"Names\"].map((name) => name.split(\",\")[0])\n *     return dfModified\n * })\n * ```\n */\nvar $streamCSV = function (file, callback, options) { return __awaiter(void 0, void 0, void 0, function () {\n    var frameConfig;\n    return __generator(this, function (_a) {\n        frameConfig = (options === null || options === void 0 ? void 0 : options.frameConfig) || {};\n        return [2 /*return*/, new Promise(function (resolve) {\n                var count = 0;\n                papaparse_1.default.parse(file, __assign(__assign({}, options), { dynamicTyping: true, header: true, download: true, step: function (results) {\n                        var df = new __1.DataFrame([results.data], __assign(__assign({}, frameConfig), { index: [count++] }));\n                        callback(df);\n                    }, complete: function () { return resolve(null); } }));\n            })];\n    });\n}); };\nexports.$streamCSV = $streamCSV;\n/**\n * Converts a DataFrame or Series to CSV.\n * @param df DataFrame or Series to be converted to CSV.\n * @param options Configuration object. Supports the following options:\n * - `filePath`: Local file path to write the CSV file. If not specified, the CSV will be returned as a string.\n * - `header`: Boolean indicating whether to include a header row in the CSV file.\n * - `sep`: Character to be used as a separator in the CSV file.\n * @example\n * ```\n * import { toCSV } from \"danfojs-node\"\n * const df = new DataFrame([[1, 2, 3], [4, 5, 6]])\n * const csv = toCSV(df)\n * ```\n * @example\n * ```\n * import { toCSV } from \"danfojs-node\"\n * const df = new DataFrame([[1, 2, 3], [4, 5, 6]])\n * toCSV(df, {\n *     filePath: \"./data/sample.csv\",\n *     header: true,\n *     sep: \"+\"\n *   })\n * ```\n */\nvar $toCSV = function (df, options) {\n    var _a = __assign({ fileName: \"output.csv\", sep: \",\", header: true, download: false }, options), fileName = _a.fileName, download = _a.download, sep = _a.sep, header = _a.header;\n    if (df.$isSeries) {\n        var csv = df.values.join(sep);\n        if (download) {\n            if (!(fileName.endsWith(\".csv\"))) {\n                fileName = fileName + \".csv\";\n            }\n            $downloadFileInBrowser(csv, fileName);\n        }\n        else {\n            return csv;\n        }\n    }\n    else {\n        var rows = df.values;\n        var csvStr = header === true ? df.columns.join(sep) + \"\\n\" : \"\";\n        for (var i = 0; i < rows.length; i++) {\n            var row = rows[i].join(sep) + \"\\n\";\n            csvStr += row;\n        }\n        if (download) {\n            if (!(fileName.endsWith(\".csv\"))) {\n                fileName = fileName + \".csv\";\n            }\n            $downloadFileInBrowser(csvStr, fileName);\n        }\n        else {\n            return csvStr;\n        }\n    }\n};\nexports.$toCSV = $toCSV;\n/**\n * Internal function to download a CSV file in the browser.\n * @param content A string of CSV file contents\n * @param fileName  The name of the file to be downloaded\n */\nvar $downloadFileInBrowser = function (content, fileName) {\n    var hiddenElement = document.createElement('a');\n    hiddenElement.href = 'data:text/csv;charset=utf-8,' + encodeURI(content);\n    hiddenElement.target = '_blank';\n    hiddenElement.download = fileName;\n    hiddenElement.click();\n};\n","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$toExcel = exports.$readExcel = void 0;\nvar __1 = require(\"../../\");\nvar xlsx_1 = require(\"xlsx\");\n/**\n * Reads a JSON file from local or remote location into a DataFrame.\n * @param file URL or local file path to JSON file.\n * @param options Configuration object. Supported options:\n * - `method`: The HTTP method to use. Defaults to `'GET'`.\n * - `headers`: Additional headers to send with the request. Supports the `node-fetch` [HeadersInit]\n * @example\n * ```\n * import { readExcel } from \"danfojs-node\"\n * const df = await readExcel(\"https://raw.githubusercontent.com/test.xlsx\")\n * ```\n * @example\n * ```\n * import { readExcel } from \"danfojs-node\"\n * const df = await readExcel(\"https://raw.githubusercontent.com/test.xlsx\", {\n *    method: \"GET\",\n *    headers: {\n *      Accept: \"text/csv\",\n *      Authorization: \"Bearer YWRtaW46YWRtaW4=\"\n *    }\n * })\n * ```\n */\nvar $readExcel = function (file, options) { return __awaiter(void 0, void 0, void 0, function () {\n    var _a, sheet, method, headers, frameConfig, parsingOptions, arrBuf, arrBufInt8, workbook, worksheet, data, df;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _a = __assign({ sheet: 0, method: \"GET\", headers: {}, frameConfig: {}, parsingOptions: {} }, options), sheet = _a.sheet, method = _a.method, headers = _a.headers, frameConfig = _a.frameConfig, parsingOptions = _a.parsingOptions;\n                if (!(typeof file === \"string\" && file.startsWith(\"http\"))) return [3 /*break*/, 1];\n                return [2 /*return*/, new Promise(function (resolve) {\n                        fetch(file, { method: method, headers: headers }).then(function (response) {\n                            if (response.status !== 200) {\n                                throw new Error(\"Failed to load \" + file);\n                            }\n                            response.arrayBuffer().then(function (arrBuf) {\n                                var arrBufInt8 = new Uint8Array(arrBuf);\n                                var workbook = (0, xlsx_1.read)(arrBufInt8, __assign({ type: \"array\" }, parsingOptions));\n                                var worksheet = workbook.Sheets[workbook.SheetNames[sheet]];\n                                var data = xlsx_1.utils.sheet_to_json(worksheet);\n                                var df = new __1.DataFrame(data, frameConfig);\n                                resolve(df);\n                            });\n                        }).catch(function (err) {\n                            throw new Error(err);\n                        });\n                    })];\n            case 1:\n                if (!(file instanceof File)) return [3 /*break*/, 3];\n                return [4 /*yield*/, file.arrayBuffer()];\n            case 2:\n                arrBuf = _b.sent();\n                arrBufInt8 = new Uint8Array(arrBuf);\n                workbook = (0, xlsx_1.read)(arrBufInt8, __assign({ type: \"array\" }, parsingOptions));\n                worksheet = workbook.Sheets[workbook.SheetNames[sheet]];\n                data = xlsx_1.utils.sheet_to_json(worksheet);\n                df = new __1.DataFrame(data, frameConfig);\n                return [2 /*return*/, df];\n            case 3: throw new Error(\"ParamError: File not supported. file must be a url or an input File object\");\n        }\n    });\n}); };\nexports.$readExcel = $readExcel;\n/**\n * Converts a DataFrame or Series to Excel Sheet.\n * @param df DataFrame or Series to be converted to JSON.\n * @param options Configuration object. Supported options:\n * - `sheetName`: The sheet name to be written to. Defaults to `'Sheet1'`.\n * - `fileName`: The file to be written to. Defaults to `'./output.xlsx'`.\n * @example\n * ```\n * import { toExcel } from \"danfojs-node\"\n * const df = new DataFrame([[1, 2, 3], [4, 5, 6]])\n * toExcel(df, {\n *     fileName: \"./data/sample.xlsx\",\n *     sheetName: \"MySheet\",\n *   })\n * ```\n */\nvar $toExcel = function (df, options) {\n    var _a = __assign({ fileName: \"./output.xlsx\", sheetName: \"Sheet1\" }, options), fileName = _a.fileName, sheetName = _a.sheetName, writingOptions = _a.writingOptions;\n    if (!(fileName.endsWith(\".xlsx\"))) {\n        fileName = fileName + \".xlsx\";\n    }\n    var data;\n    if (df.$isSeries) {\n        var row = df.values;\n        var col = df.columns;\n        data = __spreadArray([col], (row.map(function (x) { return [x]; })), true);\n    }\n    else {\n        var row = df.values;\n        var cols = df.columns;\n        data = __spreadArray([cols], row, true);\n    }\n    var worksheet = xlsx_1.utils.aoa_to_sheet(data);\n    var wb = xlsx_1.utils.book_new();\n    xlsx_1.utils.book_append_sheet(wb, worksheet, sheetName);\n    (0, xlsx_1.writeFile)(wb, \"\" + fileName, writingOptions);\n};\nexports.$toExcel = $toExcel;\n","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar frame_1 = __importDefault(require(\"../../../danfojs-base/core/frame\"));\n/**\n * Two-dimensional ndarray with axis labels.\n * The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index.\n * Operations between DataFrame (+, -, /, , *) align values based on their associated index values they need not be the same length.\n * @param data 2D Array, JSON, Tensor, Block of data.\n * @param options.index Array of numeric or string names for subseting array. If not specified, indexes are auto generated.\n * @param options.columns Array of column names. If not specified, column names are auto generated.\n * @param options.dtypes Array of data types for each the column. If not specified, dtypes are/is inferred.\n * @param options.config General configuration object for extending or setting NDframe behavior.\n */\nvar DataFrame = /** @class */ (function (_super) {\n    __extends(DataFrame, _super);\n    function DataFrame(data, options) {\n        if (options === void 0) { options = {}; }\n        return _super.call(this, data, options) || this;\n    }\n    return DataFrame;\n}(frame_1.default));\nexports.default = DataFrame;\n","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n*  @license\n* Copyright 2022 JsData. All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n* ==========================================================================\n*/\nvar series_1 = __importDefault(require(\"../../../danfojs-base/core/series\"));\n/**\n * One-dimensional ndarray with axis labels.\n * The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index.\n * Operations between Series (+, -, /, , *) align values based on their associated index values  they need not be the same length.\n * @param data 1D Array, JSON, Tensor, Block of data.\n * @param options.index Array of numeric or string index for subseting array. If not specified, indices are auto generated.\n * @param options.columns Column name. This is like the name of the Series. If not specified, column name is set to 0.\n * @param options.dtypes Data types of the Series data. If not specified, dtypes is inferred.\n * @param options.config General configuration object for extending or setting Series behavior.\n */\nvar Series = /** @class */ (function (_super) {\n    __extends(Series, _super);\n    function Series(data, options) {\n        if (options === void 0) { options = {}; }\n        return _super.call(this, data, options) || this;\n    }\n    return Series;\n}(series_1.default));\nexports.default = Series;\n"]}