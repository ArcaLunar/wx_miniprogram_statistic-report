{"version":3,"sources":["excel.js","lib/exceljs.nodejs.js","lib/doc/workbook.js","lib/doc/worksheet.js","lib/utils/under-dash.js","lib/utils/col-cache.js","lib/doc/range.js","lib/doc/row.js","lib/doc/enums.js","lib/doc/cell.js","lib/utils/shared-formula.js","lib/doc/note.js","lib/doc/column.js","lib/doc/image.js","lib/doc/anchor.js","lib/doc/table.js","lib/doc/data-validations.js","lib/utils/encryptor.js","lib/utils/copy-style.js","lib/doc/defined-names.js","lib/utils/cell-matrix.js","lib/xlsx/xlsx.js","lib/utils/zip-stream.js","lib/utils/stream-buf.js","lib/utils/utils.js","lib/utils/string-buf.js","lib/utils/browser-buffer-encode.js","lib/utils/xml-stream.js","lib/utils/browser-buffer-decode.js","lib/xlsx/xform/style/styles-xform.js","lib/xlsx/xform/base-xform.js","lib/utils/parse-sax.js","lib/xlsx/xform/static-xform.js","lib/xlsx/xform/list-xform.js","lib/xlsx/xform/style/font-xform.js","lib/xlsx/xform/style/color-xform.js","lib/xlsx/xform/simple/boolean-xform.js","lib/xlsx/xform/simple/integer-xform.js","lib/xlsx/xform/simple/string-xform.js","lib/xlsx/xform/style/underline-xform.js","lib/xlsx/xform/style/fill-xform.js","lib/xlsx/xform/style/border-xform.js","lib/xlsx/xform/style/numfmt-xform.js","lib/xlsx/defaultnumformats.js","lib/xlsx/xform/style/style-xform.js","lib/xlsx/xform/style/alignment-xform.js","lib/xlsx/xform/style/protection-xform.js","lib/xlsx/xform/style/dxf-xform.js","lib/xlsx/xform/core/core-xform.js","lib/xlsx/xform/simple/date-xform.js","lib/xlsx/xform/strings/shared-strings-xform.js","lib/xlsx/xform/strings/shared-string-xform.js","lib/xlsx/xform/strings/text-xform.js","lib/xlsx/xform/strings/rich-text-xform.js","lib/xlsx/xform/strings/phonetic-text-xform.js","lib/xlsx/xform/core/relationships-xform.js","lib/xlsx/xform/core/relationship-xform.js","lib/xlsx/xform/core/content-types-xform.js","lib/xlsx/xform/core/app-xform.js","lib/xlsx/xform/core/app-heading-pairs-xform.js","lib/xlsx/xform/core/app-titles-of-parts-xform.js","lib/xlsx/xform/book/workbook-xform.js","lib/xlsx/xform/book/defined-name-xform.js","lib/xlsx/xform/book/sheet-xform.js","lib/xlsx/xform/book/workbook-view-xform.js","lib/xlsx/xform/book/workbook-properties-xform.js","lib/xlsx/xform/book/workbook-calc-properties-xform.js","lib/xlsx/xform/sheet/worksheet-xform.js","lib/xlsx/rel-type.js","lib/xlsx/xform/sheet/merges.js","lib/xlsx/xform/sheet/row-xform.js","lib/xlsx/xform/sheet/cell-xform.js","lib/xlsx/xform/sheet/col-xform.js","lib/xlsx/xform/sheet/dimension-xform.js","lib/xlsx/xform/sheet/hyperlink-xform.js","lib/xlsx/xform/sheet/merge-cell-xform.js","lib/xlsx/xform/sheet/data-validations-xform.js","lib/xlsx/xform/sheet/sheet-properties-xform.js","lib/xlsx/xform/sheet/page-setup-properties-xform.js","lib/xlsx/xform/sheet/outline-properties-xform.js","lib/xlsx/xform/sheet/sheet-format-properties-xform.js","lib/xlsx/xform/sheet/sheet-view-xform.js","lib/xlsx/xform/sheet/sheet-protection-xform.js","lib/xlsx/xform/sheet/page-margins-xform.js","lib/xlsx/xform/sheet/page-setup-xform.js","lib/xlsx/xform/sheet/print-options-xform.js","lib/xlsx/xform/sheet/auto-filter-xform.js","lib/xlsx/xform/sheet/picture-xform.js","lib/xlsx/xform/sheet/drawing-xform.js","lib/xlsx/xform/sheet/table-part-xform.js","lib/xlsx/xform/sheet/row-breaks-xform.js","lib/xlsx/xform/sheet/page-breaks-xform.js","lib/xlsx/xform/sheet/header-footer-xform.js","lib/xlsx/xform/sheet/cf/conditional-formattings-xform.js","lib/xlsx/xform/sheet/cf/conditional-formatting-xform.js","lib/xlsx/xform/composite-xform.js","lib/xlsx/xform/sheet/cf/cf-rule-xform.js","lib/xlsx/xform/sheet/cf/databar-xform.js","lib/xlsx/xform/sheet/cf/cfvo-xform.js","lib/xlsx/xform/sheet/cf/ext-lst-ref-xform.js","lib/xlsx/xform/sheet/cf/formula-xform.js","lib/xlsx/xform/sheet/cf/color-scale-xform.js","lib/xlsx/xform/sheet/cf/icon-set-xform.js","lib/xlsx/xform/sheet/ext-lst-xform.js","lib/xlsx/xform/sheet/cf-ext/conditional-formattings-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/cf-rule-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/databar-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/cfvo-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/f-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/icon-set-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/cf-icon-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/conditional-formatting-ext-xform.js","lib/xlsx/xform/sheet/cf-ext/sqref-ext-xform.js","lib/xlsx/xform/drawing/drawing-xform.js","lib/xlsx/xform/drawing/two-cell-anchor-xform.js","lib/xlsx/xform/drawing/base-cell-anchor-xform.js","lib/xlsx/xform/drawing/cell-position-xform.js","lib/xlsx/xform/drawing/pic-xform.js","lib/xlsx/xform/drawing/blip-fill-xform.js","lib/xlsx/xform/drawing/blip-xform.js","lib/xlsx/xform/drawing/nv-pic-pr-xform.js","lib/xlsx/xform/drawing/c-nv-pr-xform.js","lib/xlsx/xform/drawing/hlink-click-xform.js","lib/xlsx/xform/drawing/ext-lst-xform.js","lib/xlsx/xform/drawing/c-nv-pic-pr-xform.js","lib/xlsx/xform/drawing/sp-pr.js","lib/xlsx/xform/drawing/one-cell-anchor-xform.js","lib/xlsx/xform/drawing/ext-xform.js","lib/xlsx/xform/table/table-xform.js","lib/xlsx/xform/table/auto-filter-xform.js","lib/xlsx/xform/table/filter-column-xform.js","lib/xlsx/xform/table/custom-filter-xform.js","lib/xlsx/xform/table/filter-xform.js","lib/xlsx/xform/table/table-column-xform.js","lib/xlsx/xform/table/table-style-info-xform.js","lib/xlsx/xform/comment/comments-xform.js","lib/xlsx/xform/comment/comment-xform.js","lib/xlsx/xform/comment/vml-notes-xform.js","lib/xlsx/xform/comment/vml-shape-xform.js","lib/xlsx/xform/comment/vml-textbox-xform.js","lib/xlsx/xform/comment/vml-client-data-xform.js","lib/xlsx/xform/comment/vml-anchor-xform.js","lib/xlsx/xform/comment/style/vml-protection-xform.js","lib/xlsx/xform/comment/style/vml-position-xform.js","lib/xlsx/xml/theme1.js","lib/csv/csv.js","lib/doc/modelcontainer.js","lib/stream/xlsx/workbook-writer.js","lib/utils/shared-strings.js","lib/stream/xlsx/worksheet-writer.js","lib/stream/xlsx/sheet-rels-writer.js","lib/stream/xlsx/sheet-comments-writer.js","lib/stream/xlsx/workbook-reader.js","lib/utils/iterate-stream.js","lib/stream/xlsx/worksheet-reader.js","lib/stream/xlsx/hyperlink-reader.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA,AGTA;AJaA,AENA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,ACHA,ALeA,ACHA,AENA,ADGA;AELA,ACHA,ALeA,ACHA,AENA,ADGA;AELA,ACHA,ALeA,ACHA,AENA,ADGA;AIXA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AIXA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AIXA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,ADGA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AFMA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,ADGA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AGTA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AKdA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,ALeA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AJYA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AKfA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AYpCA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,ARwBA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AENA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA;AU7BA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA,AiBnDA;APsBA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA,AiBnDA;APsBA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA,AiBnDA;APsBA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA,AkBtDA,ADGA;APsBA,ALeA,AGTA,AIZA,AGTA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA,AkBtDA,ADGA;APsBA,ALeA,AGTA,AOrBA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,ANkBA,AkBtDA,ADGA;APsBA,ALeA,AGTA,AOrBA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,AavCA,AnByDA,AkBtDA,ADGA;APsBA,ALeA,AGTA,AOrBA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,AavCA,AnByDA,AkBtDA,ADGA;APsBA,ALeA,AGTA,AOrBA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,AavCA,AnByDA,AkBtDA,ADGA;APsBA,ALeA,AGTA,AOrBA,AXiCA,AKfA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,AavCA,AnByDA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,AavCA,AnByDA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,APqBA,AavCA,AnByDA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AuBrEA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AuBrEA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AuBrEA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AFMA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AuBrEA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AuBrEA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AuBrEA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,ADGA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AOrBA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AOrBA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AOrBA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,ADGA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,ADGA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,AMlBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,ADGA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,AFMA,ANkBA,Af6CA,AavCA,ADGA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,ADGA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,ARwBA,Af6CA,AavCA,ADGA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,ADGA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,ARwBA,Af6CA,AavCA,ADGA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,ADGA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,ARwBA,Af6CA,AavCA,ADGA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AENA,AHSA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,ARwBA,Af6CA,AavCA,ADGA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AENA,AHSA,ARwBA;APsBA,ALeA,AGTA,AOrBA,ANkBA,AFMA,ALeA,ACHA,AQxBA,AbuCA,ACHA,AyB3EA,ARwBA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AENA,AHSA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AHSA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AHSA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AHSA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AENA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AENA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AENA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AYpCA,Ac1CA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,ADGA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,AJYA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,AJYA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,AJYA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ALeA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ALeA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ALeA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,ARwBA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,ADGA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AGTA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,A0B9EA,ARwBA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,ALeA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AQxBA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AbuCA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;APsBA,ALeA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AS3BA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AENA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AGTA,ACHA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AKfA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AGTA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AIZA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AavCA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AkBtDA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AkBtDA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AkBtDA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,ALeA,AqB/DA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,ALeA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AENA,ArB+DA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AmBzDA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AqB/DA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,ANkBA,AqB/DA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,Ae7CA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,Af6CA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,AU9BA,AlBsDA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,AOrBA,AtBkEA,AgBhDA,AZoCA,ACHA,AgBhDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,AOrBA,AtBkEA,AgBhDA,AZoCA,AiBnDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,AOrBA,AtBkEA,AgBhDA,AZoCA,AiBnDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,AQxBA,ADGA,AtBkEA,AgBhDA,AZoCA,AiBnDA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,ANkBA,AYpCA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AkBtDA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A2BjFA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A2BjFA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A2BjFA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A4BpFA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A4BpFA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A4BpFA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A6BvFA,ADGA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A6BvFA,ADGA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A6BvFA,ADGA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A6BvFA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A6BvFA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A6BvFA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A+B7FA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A+B7FA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,A+B7FA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ADGA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ADGA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ADGA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AFMA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AQxBA,AIZA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AFMA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AFMA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,ACHA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,ACHA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AQxBA,ADGA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,ACHA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AtBkEA,AgBhDA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AENA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,AnByDA,AoB5DA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AENA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AENA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AYpCA,AFMA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,ANkBA,AKfA,ADGA,AFMA,ADGA,AENA,APqBA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,ANkBA,AU9BA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,AYpCA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,Ac1CA,AFMA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ACHA,AFMA,ADGA,AT2BA,AOrBA,Ac1CA,AFMA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AFMA,ADGA,ADGA,AT2BA,AOrBA,Ac1CA,AFMA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,Ac1CA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,Ac1CA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,Ac1CA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,AFMA,ACHA,AHSA,AlBsDA,AKfA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,AFMA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,AFMA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AHSA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AHSA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AHSA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,AJYA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,AJYA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,AJYA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ALeA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,ACHA,AGTA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ALeA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,AIZA,ADGA,ADGA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ALeA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AiBnDA,Af6CA,AkBtDA,ACHA,AGTA,AgBhDA,AyB3EA,AtCkHA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AbuCA,ACHA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AHSA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,ACHA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AS3BA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AbuCA,AgChGA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AS3BA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AS3BA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AOrBA,AgBhDA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AOrBA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AV8BA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AIZA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,ACHA,AGTA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AIZA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AIZA,AgBhDA,AmBzDA,AENA,AHSA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AIZA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AHSA,ACHA,ACHA,ANkBA,AU9BA,ADGA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AIZA,AgBhDA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,ARwBA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ACHA,ANkBA,AU9BA,AIZA,ALeA,AMlBA,Ad0CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,AMlBA,APqBA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,AOrBA,AbuCA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,Ad0CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,Ad0CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AFMA,ADGA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AuBrEA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AIZA,Af6CA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,ACHA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AbuCA,ADGA,AHSA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AFMA,ALeA,AU9BA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,Ad0CA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ALeA,AMlBA,AGTA,AFMA,Af6CA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AIZA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AHSA,ADGA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ANkBA,ACHA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,Ad0CA,AKfA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AIZA,AlBsDA,AKfA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AmBzDA,ADGA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AjBmDA,ALeA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AkBtDA,AJYA,AT2BA,AsClHA,Af6CA,ACHA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AkBtDA,AJYA,AT2BA,AsClHA,Af6CA,AsBlEA,ArB+DA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AkBtDA,AJYA,AT2BA,AsClHA,Af6CA,AsBlEA,ArB+DA,AIZA,AYpCA,AIZA,AbuCA,AYpCA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AkBtDA,AJYA,A6BvFA,Af6CA,AsBlEA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AoB5DA,AkBtDA,AJYA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AJYA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AJYA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AuBrEA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,ArB+DA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AtCkHA,A6BvFA,Af6CA,AyB3EA,AFMA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AFMA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AFMA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AENA,AJYA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,AGTA,AFMA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AENA,AJYA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AU9BA,AHSA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AT2BA,Af6CA,AyB3EA,AENA,AJYA,ADGA,AIZA,AzB2EA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,A3BiFA,AIZA,AYpCA,AIZA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,A3BiFA,AIZA,AgBhDA,ADGA,ARwBA,ACHA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,A3BiFA,AIZA,AgBhDA,ADGA,APqBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ADGA,APqBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,AQxBA,AtBkEA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AENA,AkBtDA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AJYA,ADGA,AIZA,AENA,ACHA,A5BoFA,AIZA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AxBwEA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AxBwEA,AgBhDA,ARwBA,ACHA,AKfA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AxBwEA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,AtBkEA,AJYA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,AgBhDA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,AMlBA,ApB4DA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AyB3EA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AiCnGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AiCnGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AiCnGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,ARwBA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,ADGA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AV8BA,AENA,AGTA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AOrBA,AKfA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AV8BA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AV8BA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,AZoCA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,AZoCA,AKfA,APqBA,ADGA,AIZA,AENA,ACHA,AENA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,AZoCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AkCtGA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,APqBA,ADGA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A1B8EA,ADGA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AHSA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AbuCA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AYpCA,ADGA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AxBwEA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AkBtDA,A1C8HA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AkBtDA,A1C8HA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AIZA,AENA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AkCtGA,AkBtDA,A1C8HA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AoD5JA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AoD5JA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AoD5JA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AFMA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AFMA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AFMA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,ACHA,AHSA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AKfA,ARwBA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,ACHA,AHSA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AENA,ACHA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,ACHA,AHSA,ACHA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,ACHA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,ACHA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,Ad0CA,AWjCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,ACHA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AGTA,A1B8EA,A2BjFA,AXiCA,ARwBA,AHSA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,AFMA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,ARwBA,AHSA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,AFMA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,ARwBA,AHSA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AGTA,ALeA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,AFMA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AIZA,AHSA,A3CiIA,AuCrHA,ALeA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AIZA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AIZA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AGTA,AhBgDA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AHSA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,APqBA,AENA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AENA,AIZA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AOrBA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AS3BA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AS3BA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AS3BA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AENA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AHSA,AMlBA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AHSA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,ADGA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,ARwBA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,AGTA,AvBqEA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AmGzSA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AmGzSA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AmGzSA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ADGA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AQxBA,AXiCA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AsDlKA,AGTA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AFMA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AFMA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,AMlBA,ALeA,AGTA,AbuCA,ApB4DA,A2BjFA,AXiCA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AFMA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,AJYA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,AJYA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,AJYA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,ACHA,AKfA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ALeA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AGTA,AbuCA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ALeA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ALeA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,AyD3KA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,AHSA,A3CiIA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A0E9NA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A0E9NA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A0E9NA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,ALeA,AFMA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AjBmDA,AMlBA,AHSA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,AnByDA,AGTA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,AnByDA,AGTA,ALeA,AHSA,AU9BA,AIZA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,AnByDA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AkCtGA,ACHA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,ACHA,ApB4DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AmCzGA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,ACHA,ApB4DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AmCzGA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,ACHA,ApB4DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AmCzGA,AV8BA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AENA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AKfA,AHSA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AKfA,AHSA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AKfA,AHSA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AgBhDA,AXiCA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ArB+DA,AGTA,ALeA,AHSA,Ac1CA,APqBA,AMlBA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AOrBA,ADGA,ADGA,AHSA,ACHA,ACHA,AlBsDA,ARwBA,AavCA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,AENA,ADGA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AOrBA,ADGA,ADGA,AHSA,ACHA,ACHA,AlBsDA,ARwBA,AavCA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AENA,ACHA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AOrBA,ADGA,ADGA,AHSA,ACHA,ACHA,AlBsDA,ARwBA,AavCA,AT2BA,A9C0IA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlBsDA,ARwBA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlBsDA,ARwBA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,AlBsDA,ARwBA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;AZqCA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA,A2HjXA;AvIsZA,AFMA,AQxBA,AZoCA,AoB5DA,AsClHA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA,A2HjXA;AvIsZA,AFMA,AQxBA,AZoCA,A0D9KA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA,A2HjXA;ACFA,AxIwZA,AFMA,AQxBA,AZoCA,A0D9KA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA,A2HjXA;ACFA,AxIwZA,AFMA,AQxBA,AZoCA,A0D9KA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,A0D9KA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,A0D9KA,A2EjOA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AqI/YA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AqI/YA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,AXiCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,AavCA,AvDqKA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,AXiCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,AXiCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AGTA,ACHA,ANkBA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,ACHA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,ACHA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AKfA,Ad0CA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,ACHA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,A1B8EA,A1C8HA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AgJhbA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AmJzbA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AmJzbA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AmJzbA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AoJ5bA,ADGA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AoJ5bA,ADGA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AoJ5bA,ADGA,AHSA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AyI3ZA,AnIyYA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AENA,ADGA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AENA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AENA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AENA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,ADGA,ADGA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AQxBA,AFMA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AoG5SA,ACHA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,ALeA,AZoCA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,ACHA,ApE4MA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,AnEyMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AMlBA,ADGA,AHSA,ACHA,AnEyMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AnEyMA,AyB3EA,ApB4DA,AT2BA,A3BiFA,AXiCA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AnEyMA,AyB3EA,ApB4DA,AT2BA,AtCkHA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AqG/SA,AFMA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,ADGA,AKfA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AIZA,AjBmDA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,ACHA,AnEyMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,AMlBA,AZoCA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AbuCA,AIZA,AHSA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AT2BA,AHSA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AT2BA,AHSA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,AmGzSA,A3GiUA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AZoCA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AZoCA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,AZoCA,AlEsMA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AwJxcA,AJYA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ADGA,AENA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ACHA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ACHA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ACHA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ACHA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AoJ5bA,ACHA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AyB3EA,A7BuFA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,AtCkHA,ARwBA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;A4HnXA,AxIwZA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,A9E0OA,AJYA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AlFsPA,A9C0IA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA,AhIgYA;AZqCA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,ALeA,AOrBA,ALeA;A5IqaA,ANkBA,AqJ/bA,AENA,ALeA;A5IqaA,ANkBA,AqJ/bA,AENA,ALeA;A5IqaA,ANkBA,AqJ/bA,AENA,ALeA;A5IqaA,ANkBA,AqJ/bA,AENA,ALeA;A5IqaA,ANkBA,AqJ/bA,AENA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AuJrcA,ALeA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,ANkBA,AkJtbA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;A5IqaA,A4IpaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * Copyright (c) 2014-2019 Guyon Roche\n * LICENCE: MIT - please refer to LICENSE file included with this module\n * or https://github.com/exceljs/exceljs/blob/master/LICENSE\n */\n\nif (parseInt(process.versions.node.split('.')[0], 10) < 10) {\n  throw new Error(\n    'For node versions older than 10, please use the ES5 Import: https://github.com/exceljs/exceljs#es5-imports'\n  );\n}\n\nmodule.exports = require('./lib/exceljs.nodejs.js');\n","const ExcelJS = {\n  Workbook: require('./doc/workbook'),\n  ModelContainer: require('./doc/modelcontainer'),\n  stream: {\n    xlsx: {\n      WorkbookWriter: require('./stream/xlsx/workbook-writer'),\n      WorkbookReader: require('./stream/xlsx/workbook-reader'),\n    },\n  },\n};\n\nObject.assign(ExcelJS, require('./doc/enums'));\n\nmodule.exports = ExcelJS;\n","\n\nconst Worksheet = require('./worksheet');\nconst DefinedNames = require('./defined-names');\nconst XLSX = require('../xlsx/xlsx');\nconst CSV = require('../csv/csv');\n\n// Workbook requirements\n//  Load and Save from file and stream\n//  Access/Add/Delete individual worksheets\n//  Manage String table, Hyperlink table, etc.\n//  Manage scaffolding for contained objects to write to/read from\n\nclass Workbook {\n  constructor() {\n    this.category = '';\n    this.company = '';\n    this.created = new Date();\n    this.description = '';\n    this.keywords = '';\n    this.manager = '';\n    this.modified = this.created;\n    this.properties = {};\n    this.calcProperties = {};\n    this._worksheets = [];\n    this.subject = '';\n    this.title = '';\n    this.views = [];\n    this.media = [];\n    this._definedNames = new DefinedNames();\n  }\n\n  get xlsx() {\n    if (!this._xlsx) this._xlsx = new XLSX(this);\n    return this._xlsx;\n  }\n\n  get csv() {\n    if (!this._csv) this._csv = new CSV(this);\n    return this._csv;\n  }\n\n  get nextId() {\n    // find the next unique spot to add worksheet\n    for (let i = 1; i < this._worksheets.length; i++) {\n      if (!this._worksheets[i]) {\n        return i;\n      }\n    }\n    return this._worksheets.length || 1;\n  }\n\n  addWorksheet(name, options) {\n    const id = this.nextId;\n\n    // if options is a color, call it tabColor (and signal deprecated message)\n    if (options) {\n      if (typeof options === 'string') {\n        // eslint-disable-next-line no-console\n        console.trace(\n          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: \"rbg value\" } }'\n        );\n        options = {\n          properties: {\n            tabColor: {argb: options},\n          },\n        };\n      } else if (options.argb || options.theme || options.indexed) {\n        // eslint-disable-next-line no-console\n        console.trace(\n          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }'\n        );\n        options = {\n          properties: {\n            tabColor: options,\n          },\n        };\n      }\n    }\n\n    const lastOrderNo = this._worksheets.reduce((acc, ws) => ((ws && ws.orderNo) > acc ? ws.orderNo : acc), 0);\n    const worksheetOptions = Object.assign({}, options, {\n      id,\n      name,\n      orderNo: lastOrderNo + 1,\n      workbook: this,\n    });\n\n    const worksheet = new Worksheet(worksheetOptions);\n\n    this._worksheets[id] = worksheet;\n    return worksheet;\n  }\n\n  removeWorksheetEx(worksheet) {\n    delete this._worksheets[worksheet.id];\n  }\n\n  removeWorksheet(id) {\n    const worksheet = this.getWorksheet(id);\n    if (worksheet) {\n      worksheet.destroy();\n    }\n  }\n\n  getWorksheet(id) {\n    if (id === undefined) {\n      return this._worksheets.find(Boolean);\n    }\n    if (typeof id === 'number') {\n      return this._worksheets[id];\n    }\n    if (typeof id === 'string') {\n      return this._worksheets.find(worksheet => worksheet && worksheet.name === id);\n    }\n    return undefined;\n  }\n\n  get worksheets() {\n    // return a clone of _worksheets\n    return this._worksheets\n      .slice(1)\n      .sort((a, b) => a.orderNo - b.orderNo)\n      .filter(Boolean);\n  }\n\n  eachSheet(iteratee) {\n    this.worksheets.forEach(sheet => {\n      iteratee(sheet, sheet.id);\n    });\n  }\n\n  get definedNames() {\n    return this._definedNames;\n  }\n\n  clearThemes() {\n    // Note: themes are not an exposed feature, meddle at your peril!\n    this._themes = undefined;\n  }\n\n  addImage(image) {\n    // TODO:  validation?\n    const id = this.media.length;\n    this.media.push(Object.assign({}, image, {type: 'image'}));\n    return id;\n  }\n\n  getImage(id) {\n    return this.media[id];\n  }\n\n  get model() {\n    return {\n      creator: this.creator || 'Unknown',\n      lastModifiedBy: this.lastModifiedBy || 'Unknown',\n      lastPrinted: this.lastPrinted,\n      created: this.created,\n      modified: this.modified,\n      properties: this.properties,\n      worksheets: this.worksheets.map(worksheet => worksheet.model),\n      sheets: this.worksheets.map(ws => ws.model).filter(Boolean),\n      definedNames: this._definedNames.model,\n      views: this.views,\n      company: this.company,\n      manager: this.manager,\n      title: this.title,\n      subject: this.subject,\n      keywords: this.keywords,\n      category: this.category,\n      description: this.description,\n      language: this.language,\n      revision: this.revision,\n      contentStatus: this.contentStatus,\n      themes: this._themes,\n      media: this.media,\n      calcProperties: this.calcProperties,\n    };\n  }\n\n  set model(value) {\n    this.creator = value.creator;\n    this.lastModifiedBy = value.lastModifiedBy;\n    this.lastPrinted = value.lastPrinted;\n    this.created = value.created;\n    this.modified = value.modified;\n    this.company = value.company;\n    this.manager = value.manager;\n    this.title = value.title;\n    this.subject = value.subject;\n    this.keywords = value.keywords;\n    this.category = value.category;\n    this.description = value.description;\n    this.language = value.language;\n    this.revision = value.revision;\n    this.contentStatus = value.contentStatus;\n\n    this.properties = value.properties;\n    this.calcProperties = value.calcProperties;\n    this._worksheets = [];\n    value.worksheets.forEach(worksheetModel => {\n      const {id, name, state} = worksheetModel;\n      const orderNo = value.sheets && value.sheets.findIndex(ws => ws.id === id);\n      const worksheet = (this._worksheets[id] = new Worksheet({\n        id,\n        name,\n        orderNo,\n        state,\n        workbook: this,\n      }));\n      worksheet.model = worksheetModel;\n    });\n\n    this._definedNames.model = value.definedNames;\n    this.views = value.views;\n    this._themes = value.themes;\n    this.media = value.media || [];\n  }\n}\n\nmodule.exports = Workbook;\n","const _ = require('../utils/under-dash');\n\nconst colCache = require('../utils/col-cache');\nconst Range = require('./range');\nconst Row = require('./row');\nconst Column = require('./column');\nconst Enums = require('./enums');\nconst Image = require('./image');\nconst Table = require('./table');\nconst DataValidations = require('./data-validations');\nconst Encryptor = require('../utils/encryptor');\nconst {copyStyle} = require('../utils/copy-style');\n\n// Worksheet requirements\n//  Operate as sheet inside workbook or standalone\n//  Load and Save from file and stream\n//  Access/Add/Delete individual cells\n//  Manage column widths and row heights\n\nclass Worksheet {\n  constructor(options) {\n    options = options || {};\n    this._workbook = options.workbook;\n\n    // in a workbook, each sheet will have a number\n    this.id = options.id;\n    this.orderNo = options.orderNo;\n\n    // and a name\n    this.name = options.name;\n\n    // add a state\n    this.state = options.state || 'visible';\n\n    // rows allows access organised by row. Sparse array of arrays indexed by row-1, col\n    // Note: _rows is zero based. Must subtract 1 to go from cell.row to index\n    this._rows = [];\n\n    // column definitions\n    this._columns = null;\n\n    // column keys (addRow convenience): key ==> this._collumns index\n    this._keys = {};\n\n    // keep record of all merges\n    this._merges = {};\n\n    // record of all row and column pageBreaks\n    this.rowBreaks = [];\n\n    // for tabColor, default row height, outline levels, etc\n    this.properties = Object.assign(\n      {},\n      {\n        defaultRowHeight: 15,\n        dyDescent: 55,\n        outlineLevelCol: 0,\n        outlineLevelRow: 0,\n      },\n      options.properties\n    );\n\n    // for all things printing\n    this.pageSetup = Object.assign(\n      {},\n      {\n        margins: {left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3},\n        orientation: 'portrait',\n        horizontalDpi: 4294967295,\n        verticalDpi: 4294967295,\n        fitToPage: !!(\n          options.pageSetup &&\n          (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) &&\n          !options.pageSetup.scale\n        ),\n        pageOrder: 'downThenOver',\n        blackAndWhite: false,\n        draft: false,\n        cellComments: 'None',\n        errors: 'displayed',\n        scale: 100,\n        fitToWidth: 1,\n        fitToHeight: 1,\n        paperSize: undefined,\n        showRowColHeaders: false,\n        showGridLines: false,\n        firstPageNumber: undefined,\n        horizontalCentered: false,\n        verticalCentered: false,\n        rowBreaks: null,\n        colBreaks: null,\n      },\n      options.pageSetup\n    );\n\n    this.headerFooter = Object.assign(\n      {},\n      {\n        differentFirst: false,\n        differentOddEven: false,\n        oddHeader: null,\n        oddFooter: null,\n        evenHeader: null,\n        evenFooter: null,\n        firstHeader: null,\n        firstFooter: null,\n      },\n      options.headerFooter\n    );\n\n    this.dataValidations = new DataValidations();\n\n    // for freezepanes, split, zoom, gridlines, etc\n    this.views = options.views || [];\n\n    this.autoFilter = options.autoFilter || null;\n\n    // for images, etc\n    this._media = [];\n\n    // worksheet protection\n    this.sheetProtection = null;\n\n    // for tables\n    this.tables = {};\n\n    this.conditionalFormattings = [];\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(name) {\n    if (name === undefined) {\n      name = `sheet${this.id}`;\n    }\n\n    if (this._name === name) return;\n\n    if (typeof name !== 'string') {\n      throw new Error('The name has to be a string.');\n    }\n\n    if (name === '') {\n      throw new Error('The name can\\'t be empty.');\n    }\n\n    if (name === 'History') {\n      throw new Error('The name \"History\" is protected. Please use a different name.');\n    }\n\n    // Illegal character in worksheet name: asterisk (*), question mark (?),\n    // colon (:), forward slash (/ \\), or bracket ([])\n    if (/[*?:/\\\\[\\]]/.test(name)) {\n      throw new Error(`Worksheet name ${name} cannot include any of the following characters: * ? : \\\\ / [ ]`);\n    }\n\n    if (/(^')|('$)/.test(name)) {\n      throw new Error(`The first or last character of worksheet name cannot be a single quotation mark: ${name}`);\n    }\n\n    if (name && name.length > 31) {\n      // eslint-disable-next-line no-console\n      console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);\n      name = name.substring(0, 31);\n    }\n\n    if (this._workbook._worksheets.find(ws => ws && ws.name.toLowerCase() === name.toLowerCase())) {\n      throw new Error(`Worksheet name already exists: ${name}`);\n    }\n\n    this._name = name;\n  }\n\n  get workbook() {\n    return this._workbook;\n  }\n\n  // when you're done with this worksheet, call this to remove from workbook\n  destroy() {\n    this._workbook.removeWorksheetEx(this);\n  }\n\n  // Get the bounding range of the cells in this worksheet\n  get dimensions() {\n    const dimensions = new Range();\n    this._rows.forEach(row => {\n      if (row) {\n        const rowDims = row.dimensions;\n        if (rowDims) {\n          dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);\n        }\n      }\n    });\n    return dimensions;\n  }\n\n  // =========================================================================\n  // Columns\n\n  // get the current columns array.\n  get columns() {\n    return this._columns;\n  }\n\n  // set the columns from an array of column definitions.\n  // Note: any headers defined will overwrite existing values.\n  set columns(value) {\n    // calculate max header row count\n    this._headerRowCount = value.reduce((pv, cv) => {\n      const headerCount = (cv.header && 1) || (cv.headers && cv.headers.length) || 0;\n      return Math.max(pv, headerCount);\n    }, 0);\n\n    // construct Column objects\n    let count = 1;\n    const columns = (this._columns = []);\n    value.forEach(defn => {\n      const column = new Column(this, count++, false);\n      columns.push(column);\n      column.defn = defn;\n    });\n  }\n\n  getColumnKey(key) {\n    return this._keys[key];\n  }\n\n  setColumnKey(key, value) {\n    this._keys[key] = value;\n  }\n\n  deleteColumnKey(key) {\n    delete this._keys[key];\n  }\n\n  eachColumnKey(f) {\n    _.each(this._keys, f);\n  }\n\n  // get a single column by col number. If it doesn't exist, create it and any gaps before it\n  getColumn(c) {\n    if (typeof c === 'string') {\n      // if it matches a key'd column, return that\n      const col = this._keys[c];\n      if (col) return col;\n\n      // otherwise, assume letter\n      c = colCache.l2n(c);\n    }\n    if (!this._columns) {\n      this._columns = [];\n    }\n    if (c > this._columns.length) {\n      let n = this._columns.length + 1;\n      while (n <= c) {\n        this._columns.push(new Column(this, n++));\n      }\n    }\n    return this._columns[c - 1];\n  }\n\n  spliceColumns(start, count, ...inserts) {\n    const rows = this._rows;\n    const nRows = rows.length;\n    if (inserts.length > 0) {\n      // must iterate over all rows whether they exist yet or not\n      for (let i = 0; i < nRows; i++) {\n        const rowArguments = [start, count];\n        // eslint-disable-next-line no-loop-func\n        inserts.forEach(insert => {\n          rowArguments.push(insert[i] || null);\n        });\n        const row = this.getRow(i + 1);\n        // eslint-disable-next-line prefer-spread\n        row.splice.apply(row, rowArguments);\n      }\n    } else {\n      // nothing to insert, so just splice all rows\n      this._rows.forEach(r => {\n        if (r) {\n          r.splice(start, count);\n        }\n      });\n    }\n\n    // splice column definitions\n    const nExpand = inserts.length - count;\n    const nKeep = start + count;\n    const nEnd = this._columns.length;\n    if (nExpand < 0) {\n      for (let i = start + inserts.length; i <= nEnd; i++) {\n        this.getColumn(i).defn = this.getColumn(i - nExpand).defn;\n      }\n    } else if (nExpand > 0) {\n      for (let i = nEnd; i >= nKeep; i--) {\n        this.getColumn(i + nExpand).defn = this.getColumn(i).defn;\n      }\n    }\n    for (let i = start; i < start + inserts.length; i++) {\n      this.getColumn(i).defn = null;\n    }\n\n    // account for defined names\n    this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);\n  }\n\n  get lastColumn() {\n    return this.getColumn(this.columnCount);\n  }\n\n  get columnCount() {\n    let maxCount = 0;\n    this.eachRow(row => {\n      maxCount = Math.max(maxCount, row.cellCount);\n    });\n    return maxCount;\n  }\n\n  get actualColumnCount() {\n    // performance nightmare - for each row, counts all the columns used\n    const counts = [];\n    let count = 0;\n    this.eachRow(row => {\n      row.eachCell(({col}) => {\n        if (!counts[col]) {\n          counts[col] = true;\n          count++;\n        }\n      });\n    });\n    return count;\n  }\n\n  // =========================================================================\n  // Rows\n\n  _commitRow() {\n    // nop - allows streaming reader to fill a document\n  }\n\n  get _lastRowNumber() {\n    // need to cope with results of splice\n    const rows = this._rows;\n    let n = rows.length;\n    while (n > 0 && rows[n - 1] === undefined) {\n      n--;\n    }\n    return n;\n  }\n\n  get _nextRow() {\n    return this._lastRowNumber + 1;\n  }\n\n  get lastRow() {\n    if (this._rows.length) {\n      return this._rows[this._rows.length - 1];\n    }\n    return undefined;\n  }\n\n  // find a row (if exists) by row number\n  findRow(r) {\n    return this._rows[r - 1];\n  }\n\n  // find multiple rows (if exists) by row number\n  findRows(start, length) {\n    return this._rows.slice(start - 1, start - 1 + length);\n  }\n\n  get rowCount() {\n    return this._lastRowNumber;\n  }\n\n  get actualRowCount() {\n    // counts actual rows that have actual data\n    let count = 0;\n    this.eachRow(() => {\n      count++;\n    });\n    return count;\n  }\n\n  // get a row by row number.\n  getRow(r) {\n    let row = this._rows[r - 1];\n    if (!row) {\n      row = this._rows[r - 1] = new Row(this, r);\n    }\n    return row;\n  }\n\n  // get multiple rows by row number.\n  getRows(start, length) {\n    if (length < 1) return undefined;\n    const rows = [];\n    for (let i = start; i < start + length; i++) {\n      rows.push(this.getRow(i));\n    }\n    return rows;\n  }\n\n  addRow(value, style = 'n') {\n    const rowNo = this._nextRow;\n    const row = this.getRow(rowNo);\n    row.values = value;\n    this._setStyleOption(rowNo, style[0] === 'i' ? style : 'n');\n    return row;\n  }\n\n  addRows(value, style = 'n') {\n    const rows = [];\n    value.forEach(row => {\n      rows.push(this.addRow(row, style));\n    });\n    return rows;\n  }\n\n  insertRow(pos, value, style = 'n') {\n    this.spliceRows(pos, 0, value);\n    this._setStyleOption(pos, style);\n    return this.getRow(pos);\n  }\n\n  insertRows(pos, values, style = 'n') {\n    this.spliceRows(pos, 0, ...values);\n    if (style !== 'n') {\n      // copy over the styles\n      for (let i = 0; i < values.length; i++) {\n        if (style[0] === 'o' && this.findRow(values.length + pos + i) !== undefined) {\n          this._copyStyle(values.length + pos + i, pos + i, style[1] === '+');\n        } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\n          this._copyStyle(pos - 1, pos + i, style[1] === '+');\n        }\n      }\n    }\n    return this.getRows(pos, values.length);\n  }\n\n  // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')\n  _setStyleOption(pos, style = 'n') {\n    if (style[0] === 'o' && this.findRow(pos + 1) !== undefined) {\n      this._copyStyle(pos + 1, pos, style[1] === '+');\n    } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\n      this._copyStyle(pos - 1, pos, style[1] === '+');\n    }\n  }\n\n  _copyStyle(src, dest, styleEmpty = false) {\n    const rSrc = this.getRow(src);\n    const rDst = this.getRow(dest);\n    rDst.style = copyStyle(rSrc.style);\n    // eslint-disable-next-line no-loop-func\n    rSrc.eachCell({includeEmpty: styleEmpty}, (cell, colNumber) => {\n      rDst.getCell(colNumber).style = copyStyle(cell.style);\n    });\n    rDst.height = rSrc.height;\n  }\n\n  duplicateRow(rowNum, count, insert = false) {\n    // create count duplicates of rowNum\n    // either inserting new or overwriting existing rows\n\n    const rSrc = this._rows[rowNum - 1];\n    const inserts = new Array(count).fill(rSrc.values);\n    this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);\n\n    // now copy styles...\n    for (let i = 0; i < count; i++) {\n      const rDst = this._rows[rowNum + i];\n      rDst.style = rSrc.style;\n      rDst.height = rSrc.height;\n      // eslint-disable-next-line no-loop-func\n      rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\n        rDst.getCell(colNumber).style = cell.style;\n      });\n    }\n  }\n\n  spliceRows(start, count, ...inserts) {\n    // same problem as row.splice, except worse.\n    const nKeep = start + count;\n    const nInserts = inserts.length;\n    const nExpand = nInserts - count;\n    const nEnd = this._rows.length;\n    let i;\n    let rSrc;\n    if (nExpand < 0) {\n      // remove rows\n      if (start === nEnd) {\n        this._rows[nEnd - 1] = undefined;\n      }\n      for (i = nKeep; i <= nEnd; i++) {\n        rSrc = this._rows[i - 1];\n        if (rSrc) {\n          const rDst = this.getRow(i + nExpand);\n          rDst.values = rSrc.values;\n          rDst.style = rSrc.style;\n          rDst.height = rSrc.height;\n          // eslint-disable-next-line no-loop-func\n          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\n            rDst.getCell(colNumber).style = cell.style;\n          });\n          this._rows[i - 1] = undefined;\n        } else {\n          this._rows[i + nExpand - 1] = undefined;\n        }\n      }\n    } else if (nExpand > 0) {\n      // insert new cells\n      for (i = nEnd; i >= nKeep; i--) {\n        rSrc = this._rows[i - 1];\n        if (rSrc) {\n          const rDst = this.getRow(i + nExpand);\n          rDst.values = rSrc.values;\n          rDst.style = rSrc.style;\n          rDst.height = rSrc.height;\n          // eslint-disable-next-line no-loop-func\n          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\n            rDst.getCell(colNumber).style = cell.style;\n\n            // remerge cells accounting for insert offset\n            if (cell._value.constructor.name === 'MergeValue') {\n              const cellToBeMerged = this.getRow(cell._row._number + nInserts).getCell(colNumber);\n              const prevMaster = cell._value._master;\n              const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);\n              cellToBeMerged.merge(newMaster);\n            }\n          });\n        } else {\n          this._rows[i + nExpand - 1] = undefined;\n        }\n      }\n    }\n\n    // now copy over the new values\n    for (i = 0; i < nInserts; i++) {\n      const rDst = this.getRow(start + i);\n      rDst.style = {};\n      rDst.values = inserts[i];\n    }\n\n    // account for defined names\n    this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);\n  }\n\n  // iterate over every row in the worksheet, including maybe empty rows\n  eachRow(options, iteratee) {\n    if (!iteratee) {\n      iteratee = options;\n      options = undefined;\n    }\n    if (options && options.includeEmpty) {\n      const n = this._rows.length;\n      for (let i = 1; i <= n; i++) {\n        iteratee(this.getRow(i), i);\n      }\n    } else {\n      this._rows.forEach(row => {\n        if (row && row.hasValues) {\n          iteratee(row, row.number);\n        }\n      });\n    }\n  }\n\n  // return all rows as sparse array\n  getSheetValues() {\n    const rows = [];\n    this._rows.forEach(row => {\n      if (row) {\n        rows[row.number] = row.values;\n      }\n    });\n    return rows;\n  }\n\n  // =========================================================================\n  // Cells\n\n  // returns the cell at [r,c] or address given by r. If not found, return undefined\n  findCell(r, c) {\n    const address = colCache.getAddress(r, c);\n    const row = this._rows[address.row - 1];\n    return row ? row.findCell(address.col) : undefined;\n  }\n\n  // return the cell at [r,c] or address given by r. If not found, create a new one.\n  getCell(r, c) {\n    const address = colCache.getAddress(r, c);\n    const row = this.getRow(address.row);\n    return row.getCellEx(address);\n  }\n\n  // =========================================================================\n  // Merge\n\n  // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell\n  mergeCells(...cells) {\n    const dimensions = new Range(cells);\n    this._mergeCellsInternal(dimensions);\n  }\n\n  mergeCellsWithoutStyle(...cells) {\n    const dimensions = new Range(cells);\n    this._mergeCellsInternal(dimensions, true);\n  }\n\n  _mergeCellsInternal(dimensions, ignoreStyle) {\n    // check cells aren't already merged\n    _.each(this._merges, merge => {\n      if (merge.intersects(dimensions)) {\n        throw new Error('Cannot merge already merged cells');\n      }\n    });\n\n    // apply merge\n    const master = this.getCell(dimensions.top, dimensions.left);\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\n        // merge all but the master cell\n        if (i > dimensions.top || j > dimensions.left) {\n          this.getCell(i, j).merge(master, ignoreStyle);\n        }\n      }\n    }\n\n    // index merge\n    this._merges[master.address] = dimensions;\n  }\n\n  _unMergeMaster(master) {\n    // master is always top left of a rectangle\n    const merge = this._merges[master.address];\n    if (merge) {\n      for (let i = merge.top; i <= merge.bottom; i++) {\n        for (let j = merge.left; j <= merge.right; j++) {\n          this.getCell(i, j).unmerge();\n        }\n      }\n      delete this._merges[master.address];\n    }\n  }\n\n  get hasMerges() {\n    // return true if this._merges has a merge object\n    return _.some(this._merges, Boolean);\n  }\n\n  // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,\n  // un-merge the group. Note this function can affect multiple merges and merge-blocks are\n  // atomic - either they're all merged or all un-merged.\n  unMergeCells(...cells) {\n    const dimensions = new Range(cells);\n\n    // find any cells in that range and unmerge them\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\n        const cell = this.findCell(i, j);\n        if (cell) {\n          if (cell.type === Enums.ValueType.Merge) {\n            // this cell merges to another master\n            this._unMergeMaster(cell.master);\n          } else if (this._merges[cell.address]) {\n            // this cell is a master\n            this._unMergeMaster(cell);\n          }\n        }\n      }\n    }\n  }\n\n  // ===========================================================================\n  // Shared/Array Formula\n  fillFormula(range, formula, results, shareType = 'shared') {\n    // Define formula for top-left cell and share to rest\n    const decoded = colCache.decode(range);\n    const {top, left, bottom, right} = decoded;\n    const width = right - left + 1;\n    const masterAddress = colCache.encodeAddress(top, left);\n    const isShared = shareType === 'shared';\n\n    // work out result accessor\n    let getResult;\n    if (typeof results === 'function') {\n      getResult = results;\n    } else if (Array.isArray(results)) {\n      if (Array.isArray(results[0])) {\n        getResult = (row, col) => results[row - top][col - left];\n      } else {\n        // eslint-disable-next-line no-mixed-operators\n        getResult = (row, col) => results[(row - top) * width + (col - left)];\n      }\n    } else {\n      getResult = () => undefined;\n    }\n    let first = true;\n    for (let r = top; r <= bottom; r++) {\n      for (let c = left; c <= right; c++) {\n        if (first) {\n          this.getCell(r, c).value = {\n            shareType,\n            formula,\n            ref: range,\n            result: getResult(r, c),\n          };\n          first = false;\n        } else {\n          this.getCell(r, c).value = isShared\n            ? {\n                sharedFormula: masterAddress,\n                result: getResult(r, c),\n              }\n            : getResult(r, c);\n        }\n      }\n    }\n  }\n\n  // =========================================================================\n  // Images\n  addImage(imageId, range) {\n    const model = {\n      type: 'image',\n      imageId,\n      range,\n    };\n    this._media.push(new Image(this, model));\n  }\n\n  getImages() {\n    return this._media.filter(m => m.type === 'image');\n  }\n\n  addBackgroundImage(imageId) {\n    const model = {\n      type: 'background',\n      imageId,\n    };\n    this._media.push(new Image(this, model));\n  }\n\n  getBackgroundImageId() {\n    const image = this._media.find(m => m.type === 'background');\n    return image && image.imageId;\n  }\n\n  // =========================================================================\n  // Worksheet Protection\n  protect(password, options) {\n    // TODO: make this function truly async\n    // perhaps marshal to worker thread or something\n    return new Promise(resolve => {\n      this.sheetProtection = {\n        sheet: true,\n      };\n      if (options && 'spinCount' in options) {\n        // force spinCount to be integer >= 0\n        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;\n      }\n      if (password) {\n        this.sheetProtection.algorithmName = 'SHA-512';\n        this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString('base64');\n        this.sheetProtection.spinCount = options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount\n        this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(\n          password,\n          'SHA512',\n          this.sheetProtection.saltValue,\n          this.sheetProtection.spinCount\n        );\n      }\n      if (options) {\n        this.sheetProtection = Object.assign(this.sheetProtection, options);\n        if (!password && 'spinCount' in options) {\n          delete this.sheetProtection.spinCount;\n        }\n      }\n      resolve();\n    });\n  }\n\n  unprotect() {\n    this.sheetProtection = null;\n  }\n\n  // =========================================================================\n  // Tables\n  addTable(model) {\n    const table = new Table(this, model);\n    this.tables[model.name] = table;\n    return table;\n  }\n\n  getTable(name) {\n    return this.tables[name];\n  }\n\n  removeTable(name) {\n    delete this.tables[name];\n  }\n\n  getTables() {\n    return Object.values(this.tables);\n  }\n\n  // ===========================================================================\n  // Conditional Formatting\n  addConditionalFormatting(cf) {\n    this.conditionalFormattings.push(cf);\n  }\n\n  removeConditionalFormatting(filter) {\n    if (typeof filter === 'number') {\n      this.conditionalFormattings.splice(filter, 1);\n    } else if (filter instanceof Function) {\n      this.conditionalFormattings = this.conditionalFormattings.filter(filter);\n    } else {\n      this.conditionalFormattings = [];\n    }\n  }\n\n  // ===========================================================================\n  // Deprecated\n  get tabColor() {\n    // eslint-disable-next-line no-console\n    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\n    return this.properties.tabColor;\n  }\n\n  set tabColor(value) {\n    // eslint-disable-next-line no-console\n    console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\n    this.properties.tabColor = value;\n  }\n\n  // ===========================================================================\n  // Model\n\n  get model() {\n    const model = {\n      id: this.id,\n      name: this.name,\n      dataValidations: this.dataValidations.model,\n      properties: this.properties,\n      state: this.state,\n      pageSetup: this.pageSetup,\n      headerFooter: this.headerFooter,\n      rowBreaks: this.rowBreaks,\n      views: this.views,\n      autoFilter: this.autoFilter,\n      media: this._media.map(medium => medium.model),\n      sheetProtection: this.sheetProtection,\n      tables: Object.values(this.tables).map(table => table.model),\n      conditionalFormattings: this.conditionalFormattings,\n    };\n\n    // =================================================\n    // columns\n    model.cols = Column.toModel(this.columns);\n\n    // ==========================================================\n    // Rows\n    const rows = (model.rows = []);\n    const dimensions = (model.dimensions = new Range());\n    this._rows.forEach(row => {\n      const rowModel = row && row.model;\n      if (rowModel) {\n        dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);\n        rows.push(rowModel);\n      }\n    });\n\n    // ==========================================================\n    // Merges\n    model.merges = [];\n    _.each(this._merges, merge => {\n      model.merges.push(merge.range);\n    });\n\n    return model;\n  }\n\n  _parseRows(model) {\n    this._rows = [];\n    model.rows.forEach(rowModel => {\n      const row = new Row(this, rowModel.number);\n      this._rows[row.number - 1] = row;\n      row.model = rowModel;\n    });\n  }\n\n  _parseMergeCells(model) {\n    _.each(model.mergeCells, merge => {\n      // Do not merge styles when importing an Excel file\n      // since each cell may have different styles intentionally.\n      this.mergeCellsWithoutStyle(merge);\n    });\n  }\n\n  set model(value) {\n    this.name = value.name;\n    this._columns = Column.fromModel(this, value.cols);\n    this._parseRows(value);\n\n    this._parseMergeCells(value);\n    this.dataValidations = new DataValidations(value.dataValidations);\n    this.properties = value.properties;\n    this.pageSetup = value.pageSetup;\n    this.headerFooter = value.headerFooter;\n    this.views = value.views;\n    this.autoFilter = value.autoFilter;\n    this._media = value.media.map(medium => new Image(this, medium));\n    this.sheetProtection = value.sheetProtection;\n    this.tables = value.tables.reduce((tables, table) => {\n      const t = new Table();\n      t.model = table;\n      tables[table.name] = t;\n      return tables;\n    }, {});\n    this.conditionalFormattings = value.conditionalFormattings;\n  }\n}\n\nmodule.exports = Worksheet;\n","const {toString} = Object.prototype;\nconst escapeHtmlRegex = /[\"&<>]/;\nconst _ = {\n  each: function each(obj, cb) {\n    if (obj) {\n      if (Array.isArray(obj)) {\n        obj.forEach(cb);\n      } else {\n        Object.keys(obj).forEach(key => {\n          cb(obj[key], key);\n        });\n      }\n    }\n  },\n\n  some: function some(obj, cb) {\n    if (obj) {\n      if (Array.isArray(obj)) {\n        return obj.some(cb);\n      }\n      return Object.keys(obj).some(key => cb(obj[key], key));\n    }\n    return false;\n  },\n\n  every: function every(obj, cb) {\n    if (obj) {\n      if (Array.isArray(obj)) {\n        return obj.every(cb);\n      }\n      return Object.keys(obj).every(key => cb(obj[key], key));\n    }\n    return true;\n  },\n\n  map: function map(obj, cb) {\n    if (obj) {\n      if (Array.isArray(obj)) {\n        return obj.map(cb);\n      }\n      return Object.keys(obj).map(key => cb(obj[key], key));\n    }\n    return [];\n  },\n\n  keyBy(a, p) {\n    return a.reduce((o, v) => {\n      o[v[p]] = v;\n      return o;\n    }, {});\n  },\n\n  isEqual: function isEqual(a, b) {\n    const aType = typeof a;\n    const bType = typeof b;\n    const aArray = Array.isArray(a);\n    const bArray = Array.isArray(b);\n    let keys;\n\n    if (aType !== bType) {\n      return false;\n    }\n    switch (typeof a) {\n      case 'object':\n        if (aArray || bArray) {\n          if (aArray && bArray) {\n            return (\n              a.length === b.length &&\n              a.every((aValue, index) => {\n                const bValue = b[index];\n                return _.isEqual(aValue, bValue);\n              })\n            );\n          }\n          return false;\n        }\n\n        if (a === null || b === null) {\n          return a === b;\n        }\n\n        // Compare object keys and values\n        keys = Object.keys(a);\n\n        if (Object.keys(b).length !== keys.length) {\n          return false;\n        }\n\n        for (const key of keys) {\n          if (!b.hasOwnProperty(key)) {\n            return false;\n          }\n        }\n\n        return _.every(a, (aValue, key) => {\n          const bValue = b[key];\n          return _.isEqual(aValue, bValue);\n        });\n\n      default:\n        return a === b;\n    }\n  },\n\n  escapeHtml(html) {\n    const regexResult = escapeHtmlRegex.exec(html);\n    if (!regexResult) return html;\n\n    let result = '';\n    let escape = '';\n    let lastIndex = 0;\n    let i = regexResult.index;\n    for (; i < html.length; i++) {\n      switch (html.charAt(i)) {\n        case '\"':\n          escape = '&quot;';\n          break;\n        case '&':\n          escape = '&amp;';\n          break;\n        case '\\'':\n          escape = '&apos;';\n          break;\n        case '<':\n          escape = '&lt;';\n          break;\n        case '>':\n          escape = '&gt;';\n          break;\n        default:\n          continue;\n      }\n      if (lastIndex !== i) result += html.substring(lastIndex, i);\n      lastIndex = i + 1;\n      result += escape;\n    }\n    if (lastIndex !== i) return result + html.substring(lastIndex, i);\n    return result;\n  },\n\n  strcmp(a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  },\n\n  isUndefined(val) {\n    return toString.call(val) === '[object Undefined]';\n  },\n\n  isObject(val) {\n    return toString.call(val) === '[object Object]';\n  },\n\n  deepMerge() {\n    const target = arguments[0] || {};\n    const {length} = arguments;\n    // eslint-disable-next-line one-var\n    let src, clone, copyIsArray;\n\n    function assignValue(val, key) {\n      src = target[key];\n      copyIsArray = Array.isArray(val);\n      if (_.isObject(val) || copyIsArray) {\n        if (copyIsArray) {\n          copyIsArray = false;\n          clone = src && Array.isArray(src) ? src : [];\n        } else {\n          clone = src && _.isObject(src) ? src : {};\n        }\n        target[key] = _.deepMerge(clone, val);\n      } else if (!_.isUndefined(val)) {\n        target[key] = val;\n      }\n    }\n\n    for (let i = 0; i < length; i++) {\n      _.each(arguments[i], assignValue);\n    }\n    return target;\n  },\n};\n\nmodule.exports = _;\n","const addressRegex = /^[A-Z]+\\d+$/;\n// =========================================================================\n// Column Letter to Number conversion\nconst colCache = {\n  _dictionary: [\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ],\n  _l2nFill: 0,\n  _l2n: {},\n  _n2l: [],\n  _level(n) {\n    if (n <= 26) {\n      return 1;\n    }\n    if (n <= 26 * 26) {\n      return 2;\n    }\n    return 3;\n  },\n  _fill(level) {\n    let c;\n    let v;\n    let l1;\n    let l2;\n    let l3;\n    let n = 1;\n    if (level >= 4) {\n      throw new Error('Out of bounds. Excel supports columns from 1 to 16384');\n    }\n    if (this._l2nFill < 1 && level >= 1) {\n      while (n <= 26) {\n        c = this._dictionary[n - 1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n      this._l2nFill = 1;\n    }\n    if (this._l2nFill < 2 && level >= 2) {\n      n = 27;\n      while (n <= 26 + (26 * 26)) {\n        v = n - (26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26);\n        c = this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n      this._l2nFill = 2;\n    }\n    if (this._l2nFill < 3 && level >= 3) {\n      n = 26 + (26 * 26) + 1;\n      while (n <= 16384) {\n        v = n - ((26 * 26) + 26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26) % 26;\n        l3 = Math.floor(v / (26 * 26));\n        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n      this._l2nFill = 3;\n    }\n  },\n  l2n(l) {\n    if (!this._l2n[l]) {\n      this._fill(l.length);\n    }\n    if (!this._l2n[l]) {\n      throw new Error(`Out of bounds. Invalid column letter: ${l}`);\n    }\n    return this._l2n[l];\n  },\n  n2l(n) {\n    if (n < 1 || n > 16384) {\n      throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);\n    }\n    if (!this._n2l[n]) {\n      this._fill(this._level(n));\n    }\n    return this._n2l[n];\n  },\n\n  // =========================================================================\n  // Address processing\n  _hash: {},\n\n  // check if value looks like an address\n  validateAddress(value) {\n    if (!addressRegex.test(value)) {\n      throw new Error(`Invalid Address: ${value}`);\n    }\n    return true;\n  },\n\n  // convert address string into structure\n  decodeAddress(value) {\n    const addr = value.length < 5 && this._hash[value];\n    if (addr) {\n      return addr;\n    }\n    let hasCol = false;\n    let col = '';\n    let colNumber = 0;\n    let hasRow = false;\n    let row = '';\n    let rowNumber = 0;\n    for (let i = 0, char; i < value.length; i++) {\n      char = value.charCodeAt(i);\n      // col should before row\n      if (!hasRow && char >= 65 && char <= 90) {\n        // 65 = 'A'.charCodeAt(0)\n        // 90 = 'Z'.charCodeAt(0)\n        hasCol = true;\n        col += value[i];\n        // colNumber starts from 1\n        colNumber = (colNumber * 26) + char - 64;\n      } else if (char >= 48 && char <= 57) {\n        // 48 = '0'.charCodeAt(0)\n        // 57 = '9'.charCodeAt(0)\n        hasRow = true;\n        row += value[i];\n        // rowNumber starts from 0\n        rowNumber = (rowNumber * 10) + char - 48;\n      } else if (hasRow && hasCol && char !== 36) {\n        // 36 = '$'.charCodeAt(0)\n        break;\n      }\n    }\n    if (!hasCol) {\n      colNumber = undefined;\n    } else if (colNumber > 16384) {\n      throw new Error(`Out of bounds. Invalid column letter: ${col}`);\n    }\n    if (!hasRow) {\n      rowNumber = undefined;\n    }\n\n    // in case $row$col\n    value = col + row;\n\n    const address = {\n      address: value,\n      col: colNumber,\n      row: rowNumber,\n      $col$row: `$${col}$${row}`,\n    };\n\n    // mem fix - cache only the tl 100x100 square\n    if (colNumber <= 100 && rowNumber <= 100) {\n      this._hash[value] = address;\n      this._hash[address.$col$row] = address;\n    }\n\n    return address;\n  },\n\n  // convert r,c into structure (if only 1 arg, assume r is address string)\n  getAddress(r, c) {\n    if (c) {\n      const address = this.n2l(c) + r;\n      return this.decodeAddress(address);\n    }\n    return this.decodeAddress(r);\n  },\n\n  // convert [address], [tl:br] into address structures\n  decode(value) {\n    const parts = value.split(':');\n    if (parts.length === 2) {\n      const tl = this.decodeAddress(parts[0]);\n      const br = this.decodeAddress(parts[1]);\n      const result = {\n        top: Math.min(tl.row, br.row),\n        left: Math.min(tl.col, br.col),\n        bottom: Math.max(tl.row, br.row),\n        right: Math.max(tl.col, br.col),\n      };\n      // reconstruct tl, br and dimensions\n      result.tl = this.n2l(result.left) + result.top;\n      result.br = this.n2l(result.right) + result.bottom;\n      result.dimensions = `${result.tl}:${result.br}`;\n      return result;\n    }\n    return this.decodeAddress(value);\n  },\n\n  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures\n  decodeEx(value) {\n    const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);\n\n    const sheetName = groups[1] || groups[2]; // Qouted and unqouted groups\n    const reference = groups[3]; // Remaining address\n\n    const parts = reference.split(':');\n    if (parts.length > 1) {\n      let tl = this.decodeAddress(parts[0]);\n      let br = this.decodeAddress(parts[1]);\n      const top = Math.min(tl.row, br.row);\n      const left = Math.min(tl.col, br.col);\n      const bottom = Math.max(tl.row, br.row);\n      const right = Math.max(tl.col, br.col);\n\n      tl = this.n2l(left) + top;\n      br = this.n2l(right) + bottom;\n\n      return {\n        top,\n        left,\n        bottom,\n        right,\n        sheetName,\n        tl: {address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName},\n        br: {\n          address: br,\n          col: right,\n          row: bottom,\n          $col$row: `$${this.n2l(right)}$${bottom}`,\n          sheetName,\n        },\n        dimensions: `${tl}:${br}`,\n      };\n    }\n    if (reference.startsWith('#')) {\n      return sheetName ? {sheetName, error: reference} : {error: reference};\n    }\n\n    const address = this.decodeAddress(reference);\n    return sheetName ? {sheetName, ...address} : address;\n  },\n\n  // convert row,col into address string\n  encodeAddress(row, col) {\n    return colCache.n2l(col) + row;\n  },\n\n  // convert row,col into string address or t,l,b,r into range\n  encode() {\n    switch (arguments.length) {\n      case 2:\n        return colCache.encodeAddress(arguments[0], arguments[1]);\n      case 4:\n        return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(\n          arguments[2],\n          arguments[3]\n        )}`;\n      default:\n        throw new Error('Can only encode with 2 or 4 arguments');\n    }\n  },\n\n  // return true if address is contained within range\n  inRange(range, address) {\n    const [left, top, , right, bottom] = range;\n    const [col, row] = address;\n    return col >= left && col <= right && row >= top && row <= bottom;\n  },\n};\n\nmodule.exports = colCache;\n","const colCache = require('../utils/col-cache');\n\n// used by worksheet to calculate sheet dimensions\nclass Range {\n  constructor() {\n    this.decode(arguments);\n  }\n\n  setTLBR(t, l, b, r, s) {\n    if (arguments.length < 4) {\n      // setTLBR(tl, br, s)\n      const tl = colCache.decodeAddress(t);\n      const br = colCache.decodeAddress(l);\n      this.model = {\n        top: Math.min(tl.row, br.row),\n        left: Math.min(tl.col, br.col),\n        bottom: Math.max(tl.row, br.row),\n        right: Math.max(tl.col, br.col),\n        sheetName: b,\n      };\n\n      this.setTLBR(tl.row, tl.col, br.row, br.col, s);\n    } else {\n      // setTLBR(t, l, b, r, s)\n      this.model = {\n        top: Math.min(t, b),\n        left: Math.min(l, r),\n        bottom: Math.max(t, b),\n        right: Math.max(l, r),\n        sheetName: s,\n      };\n    }\n  }\n\n  decode(argv) {\n    switch (argv.length) {\n      case 5: // [t,l,b,r,s]\n        this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);\n        break;\n      case 4: // [t,l,b,r]\n        this.setTLBR(argv[0], argv[1], argv[2], argv[3]);\n        break;\n\n      case 3: // [tl,br,s]\n        this.setTLBR(argv[0], argv[1], argv[2]);\n        break;\n      case 2: // [tl,br]\n        this.setTLBR(argv[0], argv[1]);\n        break;\n\n      case 1: {\n        const value = argv[0];\n        if (value instanceof Range) {\n          // copy constructor\n          this.model = {\n            top: value.model.top,\n            left: value.model.left,\n            bottom: value.model.bottom,\n            right: value.model.right,\n            sheetName: value.sheetName,\n          };\n        } else if (value instanceof Array) {\n          // an arguments array\n          this.decode(value);\n        } else if (value.top && value.left && value.bottom && value.right) {\n          // a model\n          this.model = {\n            top: value.top,\n            left: value.left,\n            bottom: value.bottom,\n            right: value.right,\n            sheetName: value.sheetName,\n          };\n        } else {\n          // [sheetName!]tl:br\n          const tlbr = colCache.decodeEx(value);\n          if (tlbr.top) {\n            this.model = {\n              top: tlbr.top,\n              left: tlbr.left,\n              bottom: tlbr.bottom,\n              right: tlbr.right,\n              sheetName: tlbr.sheetName,\n            };\n          } else {\n            this.model = {\n              top: tlbr.row,\n              left: tlbr.col,\n              bottom: tlbr.row,\n              right: tlbr.col,\n              sheetName: tlbr.sheetName,\n            };\n          }\n        }\n        break;\n      }\n\n      case 0:\n        this.model = {\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0,\n        };\n        break;\n\n      default:\n        throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);\n    }\n  }\n\n  get top() {\n    return this.model.top || 1;\n  }\n\n  set top(value) {\n    this.model.top = value;\n  }\n\n  get left() {\n    return this.model.left || 1;\n  }\n\n  set left(value) {\n    this.model.left = value;\n  }\n\n  get bottom() {\n    return this.model.bottom || 1;\n  }\n\n  set bottom(value) {\n    this.model.bottom = value;\n  }\n\n  get right() {\n    return this.model.right || 1;\n  }\n\n  set right(value) {\n    this.model.right = value;\n  }\n\n  get sheetName() {\n    return this.model.sheetName;\n  }\n\n  set sheetName(value) {\n    this.model.sheetName = value;\n  }\n\n  get _serialisedSheetName() {\n    const {sheetName} = this.model;\n    if (sheetName) {\n      if (/^[a-zA-Z0-9]*$/.test(sheetName)) {\n        return `${sheetName}!`;\n      }\n      return `'${sheetName}'!`;\n    }\n    return '';\n  }\n\n  expand(top, left, bottom, right) {\n    if (!this.model.top || top < this.top) this.top = top;\n    if (!this.model.left || left < this.left) this.left = left;\n    if (!this.model.bottom || bottom > this.bottom) this.bottom = bottom;\n    if (!this.model.right || right > this.right) this.right = right;\n  }\n\n  expandRow(row) {\n    if (row) {\n      const {dimensions, number} = row;\n      if (dimensions) {\n        this.expand(number, dimensions.min, number, dimensions.max);\n      }\n    }\n  }\n\n  expandToAddress(addressStr) {\n    const address = colCache.decodeEx(addressStr);\n    this.expand(address.row, address.col, address.row, address.col);\n  }\n\n  get tl() {\n    return colCache.n2l(this.left) + this.top;\n  }\n\n  get $t$l() {\n    return `$${colCache.n2l(this.left)}$${this.top}`;\n  }\n\n  get br() {\n    return colCache.n2l(this.right) + this.bottom;\n  }\n\n  get $b$r() {\n    return `$${colCache.n2l(this.right)}$${this.bottom}`;\n  }\n\n  get range() {\n    return `${this._serialisedSheetName + this.tl}:${this.br}`;\n  }\n\n  get $range() {\n    return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;\n  }\n\n  get shortRange() {\n    return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;\n  }\n\n  get $shortRange() {\n    return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;\n  }\n\n  get count() {\n    return (1 + this.bottom - this.top) * (1 + this.right - this.left);\n  }\n\n  toString() {\n    return this.range;\n  }\n\n  intersects(other) {\n    if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName) return false;\n    if (other.bottom < this.top) return false;\n    if (other.top > this.bottom) return false;\n    if (other.right < this.left) return false;\n    if (other.left > this.right) return false;\n    return true;\n  }\n\n  contains(addressStr) {\n    const address = colCache.decodeEx(addressStr);\n    return this.containsEx(address);\n  }\n\n  containsEx(address) {\n    if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName) return false;\n    return (\n      address.row >= this.top &&\n      address.row <= this.bottom &&\n      address.col >= this.left &&\n      address.col <= this.right\n    );\n  }\n\n  forEachAddress(cb) {\n    for (let col = this.left; col <= this.right; col++) {\n      for (let row = this.top; row <= this.bottom; row++) {\n        cb(colCache.encodeAddress(row, col), row, col);\n      }\n    }\n  }\n}\n\nmodule.exports = Range;\n","\n\nconst _ = require('../utils/under-dash');\n\nconst Enums = require('./enums');\nconst colCache = require('../utils/col-cache');\nconst Cell = require('./cell');\n\nclass Row {\n  constructor(worksheet, number) {\n    this._worksheet = worksheet;\n    this._number = number;\n    this._cells = [];\n    this.style = {};\n    this.outlineLevel = 0;\n  }\n\n  // return the row number\n  get number() {\n    return this._number;\n  }\n\n  get worksheet() {\n    return this._worksheet;\n  }\n\n  // Inform Streaming Writer that this row (and all rows before it) are complete\n  // and ready to write. Has no effect on Worksheet document\n  commit() {\n    this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle\n  }\n\n  // helps GC by breaking cyclic references\n  destroy() {\n    delete this._worksheet;\n    delete this._cells;\n    delete this.style;\n  }\n\n  findCell(colNumber) {\n    return this._cells[colNumber - 1];\n  }\n\n  // given {address, row, col}, find or create new cell\n  getCellEx(address) {\n    let cell = this._cells[address.col - 1];\n    if (!cell) {\n      const column = this._worksheet.getColumn(address.col);\n      cell = new Cell(this, column, address.address);\n      this._cells[address.col - 1] = cell;\n    }\n    return cell;\n  }\n\n  // get cell by key, letter or column number\n  getCell(col) {\n    if (typeof col === 'string') {\n      // is it a key?\n      const column = this._worksheet.getColumnKey(col);\n      if (column) {\n        col = column.number;\n      } else {\n        col = colCache.l2n(col);\n      }\n    }\n    return (\n      this._cells[col - 1] ||\n      this.getCellEx({\n        address: colCache.encodeAddress(this._number, col),\n        row: this._number,\n        col,\n      })\n    );\n  }\n\n  // remove cell(s) and shift all higher cells down by count\n  splice(start, count, ...inserts) {\n    const nKeep = start + count;\n    const nExpand = inserts.length - count;\n    const nEnd = this._cells.length;\n    let i;\n    let cSrc;\n    let cDst;\n\n    if (nExpand < 0) {\n      // remove cells\n      for (i = start + inserts.length; i <= nEnd; i++) {\n        cDst = this._cells[i - 1];\n        cSrc = this._cells[i - nExpand - 1];\n        if (cSrc) {\n          cDst = this.getCell(i);\n          cDst.value = cSrc.value;\n          cDst.style = cSrc.style;\n          // eslint-disable-next-line no-underscore-dangle\n          cDst._comment = cSrc._comment;\n        } else if (cDst) {\n          cDst.value = null;\n          cDst.style = {};\n          // eslint-disable-next-line no-underscore-dangle\n          cDst._comment = undefined;\n        }\n      }\n    } else if (nExpand > 0) {\n      // insert new cells\n      for (i = nEnd; i >= nKeep; i--) {\n        cSrc = this._cells[i - 1];\n        if (cSrc) {\n          cDst = this.getCell(i + nExpand);\n          cDst.value = cSrc.value;\n          cDst.style = cSrc.style;\n          // eslint-disable-next-line no-underscore-dangle\n          cDst._comment = cSrc._comment;\n        } else {\n          this._cells[i + nExpand - 1] = undefined;\n        }\n      }\n    }\n\n    // now add the new values\n    for (i = 0; i < inserts.length; i++) {\n      cDst = this.getCell(start + i);\n      cDst.value = inserts[i];\n      cDst.style = {};\n      // eslint-disable-next-line no-underscore-dangle\n      cDst._comment = undefined;\n    }\n  }\n\n  // Iterate over all non-null cells in this row\n  eachCell(options, iteratee) {\n    if (!iteratee) {\n      iteratee = options;\n      options = null;\n    }\n    if (options && options.includeEmpty) {\n      const n = this._cells.length;\n      for (let i = 1; i <= n; i++) {\n        iteratee(this.getCell(i), i);\n      }\n    } else {\n      this._cells.forEach((cell, index) => {\n        if (cell && cell.type !== Enums.ValueType.Null) {\n          iteratee(cell, index + 1);\n        }\n      });\n    }\n  }\n\n  // ===========================================================================\n  // Page Breaks\n  addPageBreak(lft, rght) {\n    const ws = this._worksheet;\n    const left = Math.max(0, lft - 1) || 0;\n    const right = Math.max(0, rght - 1) || 16838;\n    const pb = {\n      id: this._number,\n      max: right,\n      man: 1,\n    };\n    if (left) pb.min = left;\n\n    ws.rowBreaks.push(pb);\n  }\n\n  // return a sparse array of cell values\n  get values() {\n    const values = [];\n    this._cells.forEach(cell => {\n      if (cell && cell.type !== Enums.ValueType.Null) {\n        values[cell.col] = cell.value;\n      }\n    });\n    return values;\n  }\n\n  // set the values by contiguous or sparse array, or by key'd object literal\n  set values(value) {\n    // this operation is not additive - any prior cells are removed\n    this._cells = [];\n    if (!value) {\n      // empty row\n    } else if (value instanceof Array) {\n      let offset = 0;\n      if (value.hasOwnProperty('0')) {\n        // contiguous array - start at column 1\n        offset = 1;\n      }\n      value.forEach((item, index) => {\n        if (item !== undefined) {\n          this.getCellEx({\n            address: colCache.encodeAddress(this._number, index + offset),\n            row: this._number,\n            col: index + offset,\n          }).value = item;\n        }\n      });\n    } else {\n      // assume object with column keys\n      this._worksheet.eachColumnKey((column, key) => {\n        if (value[key] !== undefined) {\n          this.getCellEx({\n            address: colCache.encodeAddress(this._number, column.number),\n            row: this._number,\n            col: column.number,\n          }).value = value[key];\n        }\n      });\n    }\n  }\n\n  // returns true if the row includes at least one cell with a value\n  get hasValues() {\n    return _.some(this._cells, cell => cell && cell.type !== Enums.ValueType.Null);\n  }\n\n  get cellCount() {\n    return this._cells.length;\n  }\n\n  get actualCellCount() {\n    let count = 0;\n    this.eachCell(() => {\n      count++;\n    });\n    return count;\n  }\n\n  // get the min and max column number for the non-null cells in this row or null\n  get dimensions() {\n    let min = 0;\n    let max = 0;\n    this._cells.forEach(cell => {\n      if (cell && cell.type !== Enums.ValueType.Null) {\n        if (!min || min > cell.col) {\n          min = cell.col;\n        }\n        if (max < cell.col) {\n          max = cell.col;\n        }\n      }\n    });\n    return min > 0\n      ? {\n          min,\n          max,\n        }\n      : null;\n  }\n\n  // =========================================================================\n  // styles\n  _applyStyle(name, value) {\n    this.style[name] = value;\n    this._cells.forEach(cell => {\n      if (cell) {\n        cell[name] = value;\n      }\n    });\n    return value;\n  }\n\n  get numFmt() {\n    return this.style.numFmt;\n  }\n\n  set numFmt(value) {\n    this._applyStyle('numFmt', value);\n  }\n\n  get font() {\n    return this.style.font;\n  }\n\n  set font(value) {\n    this._applyStyle('font', value);\n  }\n\n  get alignment() {\n    return this.style.alignment;\n  }\n\n  set alignment(value) {\n    this._applyStyle('alignment', value);\n  }\n\n  get protection() {\n    return this.style.protection;\n  }\n\n  set protection(value) {\n    this._applyStyle('protection', value);\n  }\n\n  get border() {\n    return this.style.border;\n  }\n\n  set border(value) {\n    this._applyStyle('border', value);\n  }\n\n  get fill() {\n    return this.style.fill;\n  }\n\n  set fill(value) {\n    this._applyStyle('fill', value);\n  }\n\n  get hidden() {\n    return !!this._hidden;\n  }\n\n  set hidden(value) {\n    this._hidden = value;\n  }\n\n  get outlineLevel() {\n    return this._outlineLevel || 0;\n  }\n\n  set outlineLevel(value) {\n    this._outlineLevel = value;\n  }\n\n  get collapsed() {\n    return !!(\n      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow\n    );\n  }\n\n  // =========================================================================\n  get model() {\n    const cells = [];\n    let min = 0;\n    let max = 0;\n    this._cells.forEach(cell => {\n      if (cell) {\n        const cellModel = cell.model;\n        if (cellModel) {\n          if (!min || min > cell.col) {\n            min = cell.col;\n          }\n          if (max < cell.col) {\n            max = cell.col;\n          }\n          cells.push(cellModel);\n        }\n      }\n    });\n\n    return this.height || cells.length\n      ? {\n          cells,\n          number: this.number,\n          min,\n          max,\n          height: this.height,\n          style: this.style,\n          hidden: this.hidden,\n          outlineLevel: this.outlineLevel,\n          collapsed: this.collapsed,\n        }\n      : null;\n  }\n\n  set model(value) {\n    if (value.number !== this._number) {\n      throw new Error('Invalid row number in model');\n    }\n    this._cells = [];\n    let previousAddress;\n    value.cells.forEach(cellModel => {\n      switch (cellModel.type) {\n        case Cell.Types.Merge:\n          // special case - don't add this types\n          break;\n        default: {\n          let address;\n          if (cellModel.address) {\n            address = colCache.decodeAddress(cellModel.address);\n          } else if (previousAddress) {\n            // This is a <c> element without an r attribute\n            // Assume that it's the cell for the next column\n            const {row} = previousAddress;\n            const col = previousAddress.col + 1;\n            address = {\n              row,\n              col,\n              address: colCache.encodeAddress(row, col),\n              $col$row: `$${colCache.n2l(col)}$${row}`,\n            };\n          }\n          previousAddress = address;\n          const cell = this.getCellEx(address);\n          cell.model = cellModel;\n          break;\n        }\n      }\n    });\n\n    if (value.height) {\n      this.height = value.height;\n    } else {\n      delete this.height;\n    }\n\n    this.hidden = value.hidden;\n    this.outlineLevel = value.outlineLevel || 0;\n\n    this.style = (value.style && JSON.parse(JSON.stringify(value.style))) || {};\n  }\n}\n\nmodule.exports = Row;\n","\n\nmodule.exports = {\n  ValueType: {\n    Null: 0,\n    Merge: 1,\n    Number: 2,\n    String: 3,\n    Date: 4,\n    Hyperlink: 5,\n    Formula: 6,\n    SharedString: 7,\n    RichText: 8,\n    Boolean: 9,\n    Error: 10,\n  },\n  FormulaType: {\n    None: 0,\n    Master: 1,\n    Shared: 2,\n  },\n  RelationshipType: {\n    None: 0,\n    OfficeDocument: 1,\n    Worksheet: 2,\n    CalcChain: 3,\n    SharedStrings: 4,\n    Styles: 5,\n    Theme: 6,\n    Hyperlink: 7,\n  },\n  DocumentType: {\n    Xlsx: 1,\n  },\n  ReadingOrder: {\n    LeftToRight: 1,\n    RightToLeft: 2,\n  },\n  ErrorValue: {\n    NotApplicable: '#N/A',\n    Ref: '#REF!',\n    Name: '#NAME?',\n    DivZero: '#DIV/0!',\n    Null: '#NULL!',\n    Value: '#VALUE!',\n    Num: '#NUM!',\n  },\n};\n","/* eslint-disable max-classes-per-file */\nconst colCache = require('../utils/col-cache');\nconst _ = require('../utils/under-dash');\nconst Enums = require('./enums');\nconst {slideFormula} = require('../utils/shared-formula');\nconst Note = require('./note');\n// Cell requirements\n//  Operate inside a worksheet\n//  Store and retrieve a value with a range of types: text, number, date, hyperlink, reference, formula, etc.\n//  Manage/use and manipulate cell format either as local to cell or inherited from column or row.\n\nclass Cell {\n  constructor(row, column, address) {\n    if (!row || !column) {\n      throw new Error('A Cell needs a Row');\n    }\n\n    this._row = row;\n    this._column = column;\n\n    colCache.validateAddress(address);\n    this._address = address;\n\n    // TODO: lazy evaluation of this._value\n    this._value = Value.create(Cell.Types.Null, this);\n\n    this.style = this._mergeStyle(row.style, column.style, {});\n\n    this._mergeCount = 0;\n  }\n\n  get worksheet() {\n    return this._row.worksheet;\n  }\n\n  get workbook() {\n    return this._row.worksheet.workbook;\n  }\n\n  // help GC by removing cyclic (and other) references\n  destroy() {\n    delete this.style;\n    delete this._value;\n    delete this._row;\n    delete this._column;\n    delete this._address;\n  }\n\n  // =========================================================================\n  // Styles stuff\n  get numFmt() {\n    return this.style.numFmt;\n  }\n\n  set numFmt(value) {\n    this.style.numFmt = value;\n  }\n\n  get font() {\n    return this.style.font;\n  }\n\n  set font(value) {\n    this.style.font = value;\n  }\n\n  get alignment() {\n    return this.style.alignment;\n  }\n\n  set alignment(value) {\n    this.style.alignment = value;\n  }\n\n  get border() {\n    return this.style.border;\n  }\n\n  set border(value) {\n    this.style.border = value;\n  }\n\n  get fill() {\n    return this.style.fill;\n  }\n\n  set fill(value) {\n    this.style.fill = value;\n  }\n\n  get protection() {\n    return this.style.protection;\n  }\n\n  set protection(value) {\n    this.style.protection = value;\n  }\n\n  _mergeStyle(rowStyle, colStyle, style) {\n    const numFmt = (rowStyle && rowStyle.numFmt) || (colStyle && colStyle.numFmt);\n    if (numFmt) style.numFmt = numFmt;\n\n    const font = (rowStyle && rowStyle.font) || (colStyle && colStyle.font);\n    if (font) style.font = font;\n\n    const alignment = (rowStyle && rowStyle.alignment) || (colStyle && colStyle.alignment);\n    if (alignment) style.alignment = alignment;\n\n    const border = (rowStyle && rowStyle.border) || (colStyle && colStyle.border);\n    if (border) style.border = border;\n\n    const fill = (rowStyle && rowStyle.fill) || (colStyle && colStyle.fill);\n    if (fill) style.fill = fill;\n\n    const protection = (rowStyle && rowStyle.protection) || (colStyle && colStyle.protection);\n    if (protection) style.protection = protection;\n\n    return style;\n  }\n\n  // =========================================================================\n  // return the address for this cell\n  get address() {\n    return this._address;\n  }\n\n  get row() {\n    return this._row.number;\n  }\n\n  get col() {\n    return this._column.number;\n  }\n\n  get $col$row() {\n    return `$${this._column.letter}$${this.row}`;\n  }\n\n  // =========================================================================\n  // Value stuff\n\n  get type() {\n    return this._value.type;\n  }\n\n  get effectiveType() {\n    return this._value.effectiveType;\n  }\n\n  toCsvString() {\n    return this._value.toCsvString();\n  }\n\n  // =========================================================================\n  // Merge stuff\n\n  addMergeRef() {\n    this._mergeCount++;\n  }\n\n  releaseMergeRef() {\n    this._mergeCount--;\n  }\n\n  get isMerged() {\n    return this._mergeCount > 0 || this.type === Cell.Types.Merge;\n  }\n\n  merge(master, ignoreStyle) {\n    this._value.release();\n    this._value = Value.create(Cell.Types.Merge, this, master);\n    if (!ignoreStyle) {\n      this.style = master.style;\n    }\n  }\n\n  unmerge() {\n    if (this.type === Cell.Types.Merge) {\n      this._value.release();\n      this._value = Value.create(Cell.Types.Null, this);\n      this.style = this._mergeStyle(this._row.style, this._column.style, {});\n    }\n  }\n\n  isMergedTo(master) {\n    if (this._value.type !== Cell.Types.Merge) return false;\n    return this._value.isMergedTo(master);\n  }\n\n  get master() {\n    if (this.type === Cell.Types.Merge) {\n      return this._value.master;\n    }\n    return this; // an unmerged cell is its own master\n  }\n\n  get isHyperlink() {\n    return this._value.type === Cell.Types.Hyperlink;\n  }\n\n  get hyperlink() {\n    return this._value.hyperlink;\n  }\n\n  // return the value\n  get value() {\n    return this._value.value;\n  }\n\n  // set the value - can be number, string or raw\n  set value(v) {\n    // special case - merge cells set their master's value\n    if (this.type === Cell.Types.Merge) {\n      this._value.master.value = v;\n      return;\n    }\n\n    this._value.release();\n\n    // assign value\n    this._value = Value.create(Value.getType(v), this, v);\n  }\n\n  get note() {\n    return this._comment && this._comment.note;\n  }\n\n  set note(note) {\n    this._comment = new Note(note);\n  }\n\n  get text() {\n    return this._value.toString();\n  }\n\n  get html() {\n    return _.escapeHtml(this.text);\n  }\n\n  toString() {\n    return this.text;\n  }\n\n  _upgradeToHyperlink(hyperlink) {\n    // if this cell is a string, turn it into a Hyperlink\n    if (this.type === Cell.Types.String) {\n      this._value = Value.create(Cell.Types.Hyperlink, this, {\n        text: this._value.value,\n        hyperlink,\n      });\n    }\n  }\n\n  // =========================================================================\n  // Formula stuff\n  get formula() {\n    return this._value.formula;\n  }\n\n  get result() {\n    return this._value.result;\n  }\n\n  get formulaType() {\n    return this._value.formulaType;\n  }\n\n  // =========================================================================\n  // Name stuff\n  get fullAddress() {\n    const {worksheet} = this._row;\n    return {\n      sheetName: worksheet.name,\n      address: this.address,\n      row: this.row,\n      col: this.col,\n    };\n  }\n\n  get name() {\n    return this.names[0];\n  }\n\n  set name(value) {\n    this.names = [value];\n  }\n\n  get names() {\n    return this.workbook.definedNames.getNamesEx(this.fullAddress);\n  }\n\n  set names(value) {\n    const {definedNames} = this.workbook;\n    definedNames.removeAllNames(this.fullAddress);\n    value.forEach(name => {\n      definedNames.addEx(this.fullAddress, name);\n    });\n  }\n\n  addName(name) {\n    this.workbook.definedNames.addEx(this.fullAddress, name);\n  }\n\n  removeName(name) {\n    this.workbook.definedNames.removeEx(this.fullAddress, name);\n  }\n\n  removeAllNames() {\n    this.workbook.definedNames.removeAllNames(this.fullAddress);\n  }\n\n  // =========================================================================\n  // Data Validation stuff\n  get _dataValidations() {\n    return this.worksheet.dataValidations;\n  }\n\n  get dataValidation() {\n    return this._dataValidations.find(this.address);\n  }\n\n  set dataValidation(value) {\n    this._dataValidations.add(this.address, value);\n  }\n\n  // =========================================================================\n  // Model stuff\n\n  get model() {\n    const {model} = this._value;\n    model.style = this.style;\n    if (this._comment) {\n      model.comment = this._comment.model;\n    }\n    return model;\n  }\n\n  set model(value) {\n    this._value.release();\n    this._value = Value.create(value.type, this);\n    this._value.model = value;\n\n    if (value.comment) {\n      switch (value.comment.type) {\n        case 'note':\n          this._comment = Note.fromModel(value.comment);\n          break;\n      }\n    }\n\n    if (value.style) {\n      this.style = value.style;\n    } else {\n      this.style = {};\n    }\n  }\n}\nCell.Types = Enums.ValueType;\n\n// =============================================================================\n// Internal Value Types\n\nclass NullValue {\n  constructor(cell) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Null,\n    };\n  }\n\n  get value() {\n    return null;\n  }\n\n  set value(value) {\n    // nothing to do\n  }\n\n  get type() {\n    return Cell.Types.Null;\n  }\n\n  get effectiveType() {\n    return Cell.Types.Null;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return '';\n  }\n\n  release() {}\n\n  toString() {\n    return '';\n  }\n}\n\nclass NumberValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Number,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  get type() {\n    return Cell.Types.Number;\n  }\n\n  get effectiveType() {\n    return Cell.Types.Number;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.model.value.toString();\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value.toString();\n  }\n}\n\nclass StringValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.String,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  get type() {\n    return Cell.Types.String;\n  }\n\n  get effectiveType() {\n    return Cell.Types.String;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return `\"${this.model.value.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value;\n  }\n}\n\nclass RichTextValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.String,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  toString() {\n    return this.model.value.richText.map(t => t.text).join('');\n  }\n\n  get type() {\n    return Cell.Types.RichText;\n  }\n\n  get effectiveType() {\n    return Cell.Types.RichText;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return `\"${this.text.replace(/\"/g, '\"\"')}\"`;\n  }\n\n  release() {}\n}\n\nclass DateValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Date,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  get type() {\n    return Cell.Types.Date;\n  }\n\n  get effectiveType() {\n    return Cell.Types.Date;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.model.value.toISOString();\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value.toString();\n  }\n}\n\nclass HyperlinkValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Hyperlink,\n      text: value ? value.text : undefined,\n      hyperlink: value ? value.hyperlink : undefined,\n    };\n    if (value && value.tooltip) {\n      this.model.tooltip = value.tooltip;\n    }\n  }\n\n  get value() {\n    const v = {\n      text: this.model.text,\n      hyperlink: this.model.hyperlink,\n    };\n    if (this.model.tooltip) {\n      v.tooltip = this.model.tooltip;\n    }\n    return v;\n  }\n\n  set value(value) {\n    this.model = {\n      text: value.text,\n      hyperlink: value.hyperlink,\n    };\n    if (value.tooltip) {\n      this.model.tooltip = value.tooltip;\n    }\n  }\n\n  get text() {\n    return this.model.text;\n  }\n\n  set text(value) {\n    this.model.text = value;\n  }\n\n  /*\n  get tooltip() {\n    return this.model.tooltip;\n  }\n\n  set tooltip(value) {\n    this.model.tooltip = value;\n  } */\n\n  get hyperlink() {\n    return this.model.hyperlink;\n  }\n\n  set hyperlink(value) {\n    this.model.hyperlink = value;\n  }\n\n  get type() {\n    return Cell.Types.Hyperlink;\n  }\n\n  get effectiveType() {\n    return Cell.Types.Hyperlink;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.model.hyperlink;\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.text;\n  }\n}\n\nclass MergeValue {\n  constructor(cell, master) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Merge,\n      master: master ? master.address : undefined,\n    };\n    this._master = master;\n    if (master) {\n      master.addMergeRef();\n    }\n  }\n\n  get value() {\n    return this._master.value;\n  }\n\n  set value(value) {\n    if (value instanceof Cell) {\n      if (this._master) {\n        this._master.releaseMergeRef();\n      }\n      value.addMergeRef();\n      this._master = value;\n    } else {\n      this._master.value = value;\n    }\n  }\n\n  isMergedTo(master) {\n    return master === this._master;\n  }\n\n  get master() {\n    return this._master;\n  }\n\n  get type() {\n    return Cell.Types.Merge;\n  }\n\n  get effectiveType() {\n    return this._master.effectiveType;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return '';\n  }\n\n  release() {\n    this._master.releaseMergeRef();\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n}\n\nclass FormulaValue {\n  constructor(cell, value) {\n    this.cell = cell;\n\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Formula,\n      shareType: value ? value.shareType : undefined,\n      ref: value ? value.ref : undefined,\n      formula: value ? value.formula : undefined,\n      sharedFormula: value ? value.sharedFormula : undefined,\n      result: value ? value.result : undefined,\n    };\n  }\n\n  _copyModel(model) {\n    const copy = {};\n    const cp = name => {\n      const value = model[name];\n      if (value) {\n        copy[name] = value;\n      }\n    };\n    cp('formula');\n    cp('result');\n    cp('ref');\n    cp('shareType');\n    cp('sharedFormula');\n    return copy;\n  }\n\n  get value() {\n    return this._copyModel(this.model);\n  }\n\n  set value(value) {\n    this.model = this._copyModel(value);\n  }\n\n  validate(value) {\n    switch (Value.getType(value)) {\n      case Cell.Types.Null:\n      case Cell.Types.String:\n      case Cell.Types.Number:\n      case Cell.Types.Date:\n        break;\n      case Cell.Types.Hyperlink:\n      case Cell.Types.Formula:\n      default:\n        throw new Error('Cannot process that type of result value');\n    }\n  }\n\n  get dependencies() {\n    // find all the ranges and cells mentioned in the formula\n    const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\\d{1,4}:[A-Z]{1,3}\\d{1,4}/g);\n    const cells = this.formula\n      .replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\\d{1,4}:[A-Z]{1,3}\\d{1,4}/g, '')\n      .match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\\d{1,4}/g);\n    return {\n      ranges,\n      cells,\n    };\n  }\n\n  get formula() {\n    return this.model.formula || this._getTranslatedFormula();\n  }\n\n  set formula(value) {\n    this.model.formula = value;\n  }\n\n  get formulaType() {\n    if (this.model.formula) {\n      return Enums.FormulaType.Master;\n    }\n    if (this.model.sharedFormula) {\n      return Enums.FormulaType.Shared;\n    }\n    return Enums.FormulaType.None;\n  }\n\n  get result() {\n    return this.model.result;\n  }\n\n  set result(value) {\n    this.model.result = value;\n  }\n\n  get type() {\n    return Cell.Types.Formula;\n  }\n\n  get effectiveType() {\n    const v = this.model.result;\n    if (v === null || v === undefined) {\n      return Enums.ValueType.Null;\n    }\n    if (v instanceof String || typeof v === 'string') {\n      return Enums.ValueType.String;\n    }\n    if (typeof v === 'number') {\n      return Enums.ValueType.Number;\n    }\n    if (v instanceof Date) {\n      return Enums.ValueType.Date;\n    }\n    if (v.text && v.hyperlink) {\n      return Enums.ValueType.Hyperlink;\n    }\n    if (v.formula) {\n      return Enums.ValueType.Formula;\n    }\n\n    return Enums.ValueType.Null;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  _getTranslatedFormula() {\n    if (!this._translatedFormula && this.model.sharedFormula) {\n      const {worksheet} = this.cell;\n      const master = worksheet.findCell(this.model.sharedFormula);\n      this._translatedFormula =\n        master && slideFormula(master.formula, master.address, this.model.address);\n    }\n    return this._translatedFormula;\n  }\n\n  toCsvString() {\n    return `${this.model.result || ''}`;\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.result ? this.model.result.toString() : '';\n  }\n}\n\nclass SharedStringValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.SharedString,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  get type() {\n    return Cell.Types.SharedString;\n  }\n\n  get effectiveType() {\n    return Cell.Types.SharedString;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.model.value.toString();\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value.toString();\n  }\n}\n\nclass BooleanValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Boolean,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  get type() {\n    return Cell.Types.Boolean;\n  }\n\n  get effectiveType() {\n    return Cell.Types.Boolean;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.model.value ? 1 : 0;\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value.toString();\n  }\n}\n\nclass ErrorValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.Error,\n      value,\n    };\n  }\n\n  get value() {\n    return this.model.value;\n  }\n\n  set value(value) {\n    this.model.value = value;\n  }\n\n  get type() {\n    return Cell.Types.Error;\n  }\n\n  get effectiveType() {\n    return Cell.Types.Error;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.toString();\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value.error.toString();\n  }\n}\n\nclass JSONValue {\n  constructor(cell, value) {\n    this.model = {\n      address: cell.address,\n      type: Cell.Types.String,\n      value: JSON.stringify(value),\n      rawValue: value,\n    };\n  }\n\n  get value() {\n    return this.model.rawValue;\n  }\n\n  set value(value) {\n    this.model.rawValue = value;\n    this.model.value = JSON.stringify(value);\n  }\n\n  get type() {\n    return Cell.Types.String;\n  }\n\n  get effectiveType() {\n    return Cell.Types.String;\n  }\n\n  get address() {\n    return this.model.address;\n  }\n\n  set address(value) {\n    this.model.address = value;\n  }\n\n  toCsvString() {\n    return this.model.value;\n  }\n\n  release() {}\n\n  toString() {\n    return this.model.value;\n  }\n}\n\n// Value is a place to hold common static Value type functions\nconst Value = {\n  getType(value) {\n    if (value === null || value === undefined) {\n      return Cell.Types.Null;\n    }\n    if (value instanceof String || typeof value === 'string') {\n      return Cell.Types.String;\n    }\n    if (typeof value === 'number') {\n      return Cell.Types.Number;\n    }\n    if (typeof value === 'boolean') {\n      return Cell.Types.Boolean;\n    }\n    if (value instanceof Date) {\n      return Cell.Types.Date;\n    }\n    if (value.text && value.hyperlink) {\n      return Cell.Types.Hyperlink;\n    }\n    if (value.formula || value.sharedFormula) {\n      return Cell.Types.Formula;\n    }\n    if (value.richText) {\n      return Cell.Types.RichText;\n    }\n    if (value.sharedString) {\n      return Cell.Types.SharedString;\n    }\n    if (value.error) {\n      return Cell.Types.Error;\n    }\n    return Cell.Types.JSON;\n  },\n\n  // map valueType to constructor\n  types: [\n    {t: Cell.Types.Null, f: NullValue},\n    {t: Cell.Types.Number, f: NumberValue},\n    {t: Cell.Types.String, f: StringValue},\n    {t: Cell.Types.Date, f: DateValue},\n    {t: Cell.Types.Hyperlink, f: HyperlinkValue},\n    {t: Cell.Types.Formula, f: FormulaValue},\n    {t: Cell.Types.Merge, f: MergeValue},\n    {t: Cell.Types.JSON, f: JSONValue},\n    {t: Cell.Types.SharedString, f: SharedStringValue},\n    {t: Cell.Types.RichText, f: RichTextValue},\n    {t: Cell.Types.Boolean, f: BooleanValue},\n    {t: Cell.Types.Error, f: ErrorValue},\n  ].reduce((p, t) => {\n    p[t.t] = t.f;\n    return p;\n  }, []),\n\n  create(type, cell, value) {\n    const T = this.types[type];\n    if (!T) {\n      throw new Error(`Could not create Value of type ${type}`);\n    }\n    return new T(cell, value);\n  },\n};\n\nmodule.exports = Cell;\n","const colCache = require('./col-cache');\n\n// const cellRefRegex = /(([a-z_\\-0-9]*)!)?[$]?([a-z]+)[$]?([1-9][0-9]*)/i;\nconst replacementCandidateRx = /(([a-z_\\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;\nconst CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;\n\nfunction slideFormula(formula, fromCell, toCell) {\n  const offset = colCache.decode(fromCell);\n  const to = colCache.decode(toCell);\n  return formula.replace(\n    replacementCandidateRx,\n    (refMatch, sheet, sheetMaybe, addrPart, trailingParen) => {\n      if (trailingParen) {\n        return refMatch;\n      }\n      const match = CRrx.exec(addrPart);\n      if (match) {\n        const colDollar = match[1];\n        const colStr = match[2].toUpperCase();\n        const rowDollar = match[3];\n        const rowStr = match[4];\n        if (colStr.length > 3 || (colStr.length === 3 && colStr > 'XFD')) {\n          // > XFD is the highest col number in excel 2007 and beyond, so this is a named range\n          return refMatch;\n        }\n        let col = colCache.l2n(colStr);\n        let row = parseInt(rowStr, 10);\n        if (!colDollar) {\n          col += to.col - offset.col;\n        }\n        if (!rowDollar) {\n          row += to.row - offset.row;\n        }\n        const res = (sheet || '') + (colDollar || '') + colCache.n2l(col) + (rowDollar || '') + row;\n        return res;\n      }\n      return refMatch;\n    }\n  );\n}\n\nmodule.exports = {\n  slideFormula,\n};\n","const _ = require('../utils/under-dash');\n\nclass Note {\n  constructor(note) {\n    this.note = note;\n  }\n\n  get model() {\n    let value = null;\n    switch (typeof this.note) {\n      case 'string':\n        value = {\n          type: 'note',\n          note: {\n            texts: [\n              {\n                text: this.note,\n              },\n            ],\n          },\n        };\n        break;\n      default:\n        value = {\n          type: 'note',\n          note: this.note,\n        };\n        break;\n    }\n    // Suitable for all cell comments\n    return _.deepMerge({}, Note.DEFAULT_CONFIGS, value);\n  }\n\n  set model(value) {\n    const {note} = value;\n    const {texts} = note;\n    if (texts.length === 1 && Object.keys(texts[0]).length === 1) {\n      this.note = texts[0].text;\n    } else {\n      this.note = note;\n    }\n  }\n\n  static fromModel(model) {\n    const note = new Note();\n    note.model = model;\n    return note;\n  }\n}\n\nNote.DEFAULT_CONFIGS = {\n  note: {\n    margins: {\n      insetmode: 'auto',\n      inset: [0.13, 0.13, 0.25, 0.25],\n    },\n    protection: {\n      locked: 'True',\n      lockText: 'True',\n    },\n    editAs: 'absolute',\n  },\n};\n\nmodule.exports = Note;\n","\n\nconst _ = require('../utils/under-dash');\n\nconst Enums = require('./enums');\nconst colCache = require('../utils/col-cache');\n\nconst DEFAULT_COLUMN_WIDTH = 9;\n\n// Column defines the column properties for 1 column.\n// This includes header rows, widths, key, (style), etc.\n// Worksheet will condense the columns as appropriate during serialization\nclass Column {\n  constructor(worksheet, number, defn) {\n    this._worksheet = worksheet;\n    this._number = number;\n    if (defn !== false) {\n      // sometimes defn will follow\n      this.defn = defn;\n    }\n  }\n\n  get number() {\n    return this._number;\n  }\n\n  get worksheet() {\n    return this._worksheet;\n  }\n\n  get letter() {\n    return colCache.n2l(this._number);\n  }\n\n  get isCustomWidth() {\n    return this.width !== undefined && this.width !== DEFAULT_COLUMN_WIDTH;\n  }\n\n  get defn() {\n    return {\n      header: this._header,\n      key: this.key,\n      width: this.width,\n      style: this.style,\n      hidden: this.hidden,\n      outlineLevel: this.outlineLevel,\n    };\n  }\n\n  set defn(value) {\n    if (value) {\n      this.key = value.key;\n      this.width = value.width !== undefined ? value.width : DEFAULT_COLUMN_WIDTH;\n      this.outlineLevel = value.outlineLevel;\n      if (value.style) {\n        this.style = value.style;\n      } else {\n        this.style = {};\n      }\n\n      // headers must be set after style\n      this.header = value.header;\n      this._hidden = !!value.hidden;\n    } else {\n      delete this._header;\n      delete this._key;\n      delete this.width;\n      this.style = {};\n      this.outlineLevel = 0;\n    }\n  }\n\n  get headers() {\n    return this._header && this._header instanceof Array ? this._header : [this._header];\n  }\n\n  get header() {\n    return this._header;\n  }\n\n  set header(value) {\n    if (value !== undefined) {\n      this._header = value;\n      this.headers.forEach((text, index) => {\n        this._worksheet.getCell(index + 1, this.number).value = text;\n      });\n    } else {\n      this._header = undefined;\n    }\n  }\n\n  get key() {\n    return this._key;\n  }\n\n  set key(value) {\n    const column = this._key && this._worksheet.getColumnKey(this._key);\n    if (column === this) {\n      this._worksheet.deleteColumnKey(this._key);\n    }\n\n    this._key = value;\n    if (value) {\n      this._worksheet.setColumnKey(this._key, this);\n    }\n  }\n\n  get hidden() {\n    return !!this._hidden;\n  }\n\n  set hidden(value) {\n    this._hidden = value;\n  }\n\n  get outlineLevel() {\n    return this._outlineLevel || 0;\n  }\n\n  set outlineLevel(value) {\n    this._outlineLevel = value;\n  }\n\n  get collapsed() {\n    return !!(\n      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol\n    );\n  }\n\n  toString() {\n    return JSON.stringify({\n      key: this.key,\n      width: this.width,\n      headers: this.headers.length ? this.headers : undefined,\n    });\n  }\n\n  equivalentTo(other) {\n    return (\n      this.width === other.width &&\n      this.hidden === other.hidden &&\n      this.outlineLevel === other.outlineLevel &&\n      _.isEqual(this.style, other.style)\n    );\n  }\n\n  get isDefault() {\n    if (this.isCustomWidth) {\n      return false;\n    }\n    if (this.hidden) {\n      return false;\n    }\n    if (this.outlineLevel) {\n      return false;\n    }\n    const s = this.style;\n    if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {\n      return false;\n    }\n    return true;\n  }\n\n  get headerCount() {\n    return this.headers.length;\n  }\n\n  eachCell(options, iteratee) {\n    const colNumber = this.number;\n    if (!iteratee) {\n      iteratee = options;\n      options = null;\n    }\n    this._worksheet.eachRow(options, (row, rowNumber) => {\n      iteratee(row.getCell(colNumber), rowNumber);\n    });\n  }\n\n  get values() {\n    const v = [];\n    this.eachCell((cell, rowNumber) => {\n      if (cell && cell.type !== Enums.ValueType.Null) {\n        v[rowNumber] = cell.value;\n      }\n    });\n    return v;\n  }\n\n  set values(v) {\n    if (!v) {\n      return;\n    }\n    const colNumber = this.number;\n    let offset = 0;\n    if (v.hasOwnProperty('0')) {\n      // assume contiguous array, start at row 1\n      offset = 1;\n    }\n    v.forEach((value, index) => {\n      this._worksheet.getCell(index + offset, colNumber).value = value;\n    });\n  }\n\n  // =========================================================================\n  // styles\n  _applyStyle(name, value) {\n    this.style[name] = value;\n    this.eachCell(cell => {\n      cell[name] = value;\n    });\n    return value;\n  }\n\n  get numFmt() {\n    return this.style.numFmt;\n  }\n\n  set numFmt(value) {\n    this._applyStyle('numFmt', value);\n  }\n\n  get font() {\n    return this.style.font;\n  }\n\n  set font(value) {\n    this._applyStyle('font', value);\n  }\n\n  get alignment() {\n    return this.style.alignment;\n  }\n\n  set alignment(value) {\n    this._applyStyle('alignment', value);\n  }\n\n  get protection() {\n    return this.style.protection;\n  }\n\n  set protection(value) {\n    this._applyStyle('protection', value);\n  }\n\n  get border() {\n    return this.style.border;\n  }\n\n  set border(value) {\n    this._applyStyle('border', value);\n  }\n\n  get fill() {\n    return this.style.fill;\n  }\n\n  set fill(value) {\n    this._applyStyle('fill', value);\n  }\n\n  // =============================================================================\n  // static functions\n\n  static toModel(columns) {\n    // Convert array of Column into compressed list cols\n    const cols = [];\n    let col = null;\n    if (columns) {\n      columns.forEach((column, index) => {\n        if (column.isDefault) {\n          if (col) {\n            col = null;\n          }\n        } else if (!col || !column.equivalentTo(col)) {\n          col = {\n            min: index + 1,\n            max: index + 1,\n            width: column.width !== undefined ? column.width : DEFAULT_COLUMN_WIDTH,\n            style: column.style,\n            isCustomWidth: column.isCustomWidth,\n            hidden: column.hidden,\n            outlineLevel: column.outlineLevel,\n            collapsed: column.collapsed,\n          };\n          cols.push(col);\n        } else {\n          col.max = index + 1;\n        }\n      });\n    }\n    return cols.length ? cols : undefined;\n  }\n\n  static fromModel(worksheet, cols) {\n    cols = cols || [];\n    const columns = [];\n    let count = 1;\n    let index = 0;\n    /**\n     * sort cols by min\n     * If it is not sorted, the subsequent column configuration will be overwritten\n     * */\n    cols = cols.sort(function(pre, next)  {\n      return pre.min - next.min;\n    });\n    while (index < cols.length) {\n      const col = cols[index++];\n      while (count < col.min) {\n        columns.push(new Column(worksheet, count++));\n      }\n      while (count <= col.max) {\n        columns.push(new Column(worksheet, count++, col));\n      }\n    }\n    return columns.length ? columns : null;\n  }\n}\n\nmodule.exports = Column;\n","const colCache = require('../utils/col-cache');\nconst Anchor = require('./anchor');\n\nclass Image {\n  constructor(worksheet, model) {\n    this.worksheet = worksheet;\n    this.model = model;\n  }\n\n  get model() {\n    switch (this.type) {\n      case 'background':\n        return {\n          type: this.type,\n          imageId: this.imageId,\n        };\n      case 'image':\n        return {\n          type: this.type,\n          imageId: this.imageId,\n          hyperlinks: this.range.hyperlinks,\n          range: {\n            tl: this.range.tl.model,\n            br: this.range.br && this.range.br.model,\n            ext: this.range.ext,\n            editAs: this.range.editAs,\n          },\n        };\n      default:\n        throw new Error('Invalid Image Type');\n    }\n  }\n\n  set model({type, imageId, range, hyperlinks}) {\n    this.type = type;\n    this.imageId = imageId;\n\n    if (type === 'image') {\n      if (typeof range === 'string') {\n        const decoded = colCache.decode(range);\n        this.range = {\n          tl: new Anchor(this.worksheet, {col: decoded.left, row: decoded.top}, -1),\n          br: new Anchor(this.worksheet, {col: decoded.right, row: decoded.bottom}, 0),\n          editAs: 'oneCell',\n        };\n      } else {\n        this.range = {\n          tl: new Anchor(this.worksheet, range.tl, 0),\n          br: range.br && new Anchor(this.worksheet, range.br, 0),\n          ext: range.ext,\n          editAs: range.editAs,\n          hyperlinks: hyperlinks || range.hyperlinks,\n        };\n      }\n    }\n  }\n}\n\nmodule.exports = Image;\n","\n\nconst colCache = require('../utils/col-cache');\n\nclass Anchor {\n  constructor(worksheet, address, offset = 0) {\n    this.worksheet = worksheet;\n\n    if (!address) {\n      this.nativeCol = 0;\n      this.nativeColOff = 0;\n      this.nativeRow = 0;\n      this.nativeRowOff = 0;\n    } else if (typeof address === 'string') {\n      const decoded = colCache.decodeAddress(address);\n      this.nativeCol = decoded.col + offset;\n      this.nativeColOff = 0;\n      this.nativeRow = decoded.row + offset;\n      this.nativeRowOff = 0;\n    } else if (address.nativeCol !== undefined) {\n      this.nativeCol = address.nativeCol || 0;\n      this.nativeColOff = address.nativeColOff || 0;\n      this.nativeRow = address.nativeRow || 0;\n      this.nativeRowOff = address.nativeRowOff || 0;\n    } else if (address.col !== undefined) {\n      this.col = address.col + offset;\n      this.row = address.row + offset;\n    } else {\n      this.nativeCol = 0;\n      this.nativeColOff = 0;\n      this.nativeRow = 0;\n      this.nativeRowOff = 0;\n    }\n  }\n\n  static asInstance(model) {\n    return model instanceof Anchor || model == null ? model : new Anchor(model);\n  }\n\n  get col() {\n    return this.nativeCol + (Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth);\n  }\n\n  set col(v) {\n    this.nativeCol = Math.floor(v);\n    this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);\n  }\n\n  get row() {\n    return this.nativeRow + (Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight);\n  }\n\n  set row(v) {\n    this.nativeRow = Math.floor(v);\n    this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);\n  }\n\n  get colWidth() {\n    return this.worksheet &&\n      this.worksheet.getColumn(this.nativeCol + 1) &&\n      this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth\n      ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 10000)\n      : 640000;\n  }\n\n  get rowHeight() {\n    return this.worksheet &&\n      this.worksheet.getRow(this.nativeRow + 1) &&\n      this.worksheet.getRow(this.nativeRow + 1).height\n      ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 10000)\n      : 180000;\n  }\n\n  get model() {\n    return {\n      nativeCol: this.nativeCol,\n      nativeColOff: this.nativeColOff,\n      nativeRow: this.nativeRow,\n      nativeRowOff: this.nativeRowOff,\n    };\n  }\n\n  set model(value) {\n    this.nativeCol = value.nativeCol;\n    this.nativeColOff = value.nativeColOff;\n    this.nativeRow = value.nativeRow;\n    this.nativeRowOff = value.nativeRowOff;\n  }\n}\n\nmodule.exports = Anchor;\n","/* eslint-disable max-classes-per-file */\nconst colCache = require('../utils/col-cache');\n\nclass Column {\n  // wrapper around column model, allowing access and manipulation\n  constructor(table, column, index) {\n    this.table = table;\n    this.column = column;\n    this.index = index;\n  }\n\n  _set(name, value) {\n    this.table.cacheState();\n    this.column[name] = value;\n  }\n\n  /* eslint-disable lines-between-class-members */\n  get name() {\n    return this.column.name;\n  }\n  set name(value) {\n    this._set('name', value);\n  }\n\n  get filterButton() {\n    return this.column.filterButton;\n  }\n  set filterButton(value) {\n    this.column.filterButton = value;\n  }\n\n  get style() {\n    return this.column.style;\n  }\n  set style(value) {\n    this.column.style = value;\n  }\n\n  get totalsRowLabel() {\n    return this.column.totalsRowLabel;\n  }\n  set totalsRowLabel(value) {\n    this._set('totalsRowLabel', value);\n  }\n\n  get totalsRowFunction() {\n    return this.column.totalsRowFunction;\n  }\n  set totalsRowFunction(value) {\n    this._set('totalsRowFunction', value);\n  }\n\n  get totalsRowResult() {\n    return this.column.totalsRowResult;\n  }\n  set totalsRowResult(value) {\n    this._set('totalsRowResult', value);\n  }\n\n  get totalsRowFormula() {\n    return this.column.totalsRowFormula;\n  }\n  set totalsRowFormula(value) {\n    this._set('totalsRowFormula', value);\n  }\n  /* eslint-enable lines-between-class-members */\n}\n\nclass Table {\n  constructor(worksheet, table) {\n    this.worksheet = worksheet;\n    if (table) {\n      this.table = table;\n      // check things are ok first\n      this.validate();\n\n      this.store();\n    }\n  }\n\n  getFormula(column) {\n    // get the correct formula to apply to the totals row\n    switch (column.totalsRowFunction) {\n      case 'none':\n        return null;\n      case 'average':\n        return `SUBTOTAL(101,${this.table.name}[${column.name}])`;\n      case 'countNums':\n        return `SUBTOTAL(102,${this.table.name}[${column.name}])`;\n      case 'count':\n        return `SUBTOTAL(103,${this.table.name}[${column.name}])`;\n      case 'max':\n        return `SUBTOTAL(104,${this.table.name}[${column.name}])`;\n      case 'min':\n        return `SUBTOTAL(105,${this.table.name}[${column.name}])`;\n      case 'stdDev':\n        return `SUBTOTAL(106,${this.table.name}[${column.name}])`;\n      case 'var':\n        return `SUBTOTAL(107,${this.table.name}[${column.name}])`;\n      case 'sum':\n        return `SUBTOTAL(109,${this.table.name}[${column.name}])`;\n      case 'custom':\n        return column.totalsRowFormula;\n      default:\n        throw new Error(`Invalid Totals Row Function: ${column.totalsRowFunction}`);\n    }\n  }\n\n  get width() {\n    // width of the table\n    return this.table.columns.length;\n  }\n\n  get height() {\n    // height of the table data\n    return this.table.rows.length;\n  }\n\n  get filterHeight() {\n    // height of the table data plus optional header row\n    return this.height + (this.table.headerRow ? 1 : 0);\n  }\n\n  get tableHeight() {\n    // full height of the table on the sheet\n    return this.filterHeight + (this.table.totalsRow ? 1 : 0);\n  }\n\n  validate() {\n    const {table} = this;\n    // set defaults and check is valid\n    const assign = (o, name, dflt) => {\n      if (o[name] === undefined) {\n        o[name] = dflt;\n      }\n    };\n    assign(table, 'headerRow', true);\n    assign(table, 'totalsRow', false);\n\n    assign(table, 'style', {});\n    assign(table.style, 'theme', 'TableStyleMedium2');\n    assign(table.style, 'showFirstColumn', false);\n    assign(table.style, 'showLastColumn', false);\n    assign(table.style, 'showRowStripes', false);\n    assign(table.style, 'showColumnStripes', false);\n\n    const assert = (test, message) => {\n      if (!test) {\n        throw new Error(message);\n      }\n    };\n    assert(table.ref, 'Table must have ref');\n    assert(table.columns, 'Table must have column definitions');\n    assert(table.rows, 'Table must have row definitions');\n\n    table.tl = colCache.decodeAddress(table.ref);\n    const {row, col} = table.tl;\n    assert(row > 0, 'Table must be on valid row');\n    assert(col > 0, 'Table must be on valid col');\n\n    const {width, filterHeight, tableHeight} = this;\n\n    // autoFilterRef is a range that includes optional headers only\n    table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width - 1);\n\n    // tableRef is a range that includes optional headers and totals\n    table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width - 1);\n\n    table.columns.forEach((column, i) => {\n      assert(column.name, `Column ${i} must have a name`);\n      if (i === 0) {\n        assign(column, 'totalsRowLabel', 'Total');\n      } else {\n        assign(column, 'totalsRowFunction', 'none');\n        column.totalsRowFormula = this.getFormula(column);\n      }\n    });\n  }\n\n  store() {\n    // where the table needs to store table data, headers, footers in\n    // the sheet...\n    const assignStyle = (cell, style) => {\n      if (style) {\n        Object.keys(style).forEach(key => {\n          cell[key] = style[key];\n        });\n      }\n    };\n\n    const {worksheet, table} = this;\n    const {row, col} = table.tl;\n    let count = 0;\n    if (table.headerRow) {\n      const r = worksheet.getRow(row + count++);\n      table.columns.forEach((column, j) => {\n        const {style, name} = column;\n        const cell = r.getCell(col + j);\n        cell.value = name;\n        assignStyle(cell, style);\n      });\n    }\n    table.rows.forEach(data => {\n      const r = worksheet.getRow(row + count++);\n      data.forEach((value, j) => {\n        const cell = r.getCell(col + j);\n        cell.value = value;\n\n        assignStyle(cell, table.columns[j].style);\n      });\n    });\n\n    if (table.totalsRow) {\n      const r = worksheet.getRow(row + count++);\n      table.columns.forEach((column, j) => {\n        const cell = r.getCell(col + j);\n        if (j === 0) {\n          cell.value = column.totalsRowLabel;\n        } else {\n          const formula = this.getFormula(column);\n          if (formula) {\n            cell.value = {\n              formula: column.totalsRowFormula,\n              result: column.totalsRowResult,\n            };\n          } else {\n            cell.value = null;\n          }\n        }\n\n        assignStyle(cell, column.style);\n      });\n    }\n  }\n\n  load(worksheet) {\n    // where the table will read necessary features from a loaded sheet\n    const {table} = this;\n    const {row, col} = table.tl;\n    let count = 0;\n    if (table.headerRow) {\n      const r = worksheet.getRow(row + count++);\n      table.columns.forEach((column, j) => {\n        const cell = r.getCell(col + j);\n        cell.value = column.name;\n      });\n    }\n    table.rows.forEach(data => {\n      const r = worksheet.getRow(row + count++);\n      data.forEach((value, j) => {\n        const cell = r.getCell(col + j);\n        cell.value = value;\n      });\n    });\n\n    if (table.totalsRow) {\n      const r = worksheet.getRow(row + count++);\n      table.columns.forEach((column, j) => {\n        const cell = r.getCell(col + j);\n        if (j === 0) {\n          cell.value = column.totalsRowLabel;\n        } else {\n          const formula = this.getFormula(column);\n          if (formula) {\n            cell.value = {\n              formula: column.totalsRowFormula,\n              result: column.totalsRowResult,\n            };\n          }\n        }\n      });\n    }\n  }\n\n  get model() {\n    return this.table;\n  }\n\n  set model(value) {\n    this.table = value;\n  }\n\n  // ================================================================\n  // TODO: Mutating methods\n  cacheState() {\n    if (!this._cache) {\n      this._cache = {\n        ref: this.ref,\n        width: this.width,\n        tableHeight: this.tableHeight,\n      };\n    }\n  }\n\n  commit() {\n    // changes may have been made that might have on-sheet effects\n    if (!this._cache) {\n      return;\n    }\n\n    // check things are ok first\n    this.validate();\n\n    const ref = colCache.decodeAddress(this._cache.ref);\n    if (this.ref !== this._cache.ref) {\n      // wipe out whole table footprint at previous location\n      for (let i = 0; i < this._cache.tableHeight; i++) {\n        const row = this.worksheet.getRow(ref.row + i);\n        for (let j = 0; j < this._cache.width; j++) {\n          const cell = row.getCell(ref.col + j);\n          cell.value = null;\n        }\n      }\n    } else {\n      // clear out below table if it has shrunk\n      for (let i = this.tableHeight; i < this._cache.tableHeight; i++) {\n        const row = this.worksheet.getRow(ref.row + i);\n        for (let j = 0; j < this._cache.width; j++) {\n          const cell = row.getCell(ref.col + j);\n          cell.value = null;\n        }\n      }\n\n      // clear out to right of table if it has lost columns\n      for (let i = 0; i < this.tableHeight; i++) {\n        const row = this.worksheet.getRow(ref.row + i);\n        for (let j = this.width; j < this._cache.width; j++) {\n          const cell = row.getCell(ref.col + j);\n          cell.value = null;\n        }\n      }\n    }\n\n    this.store();\n  }\n\n  addRow(values, rowNumber) {\n    // Add a row of data, either insert at rowNumber or append\n    this.cacheState();\n\n    if (rowNumber === undefined) {\n      this.table.rows.push(values);\n    } else {\n      this.table.rows.splice(rowNumber, 0, values);\n    }\n  }\n\n  removeRows(rowIndex, count = 1) {\n    // Remove a rows of data\n    this.cacheState();\n    this.table.rows.splice(rowIndex, count);\n  }\n\n  getColumn(colIndex) {\n    const column = this.table.columns[colIndex];\n    return new Column(this, column, colIndex);\n  }\n\n  addColumn(column, values, colIndex) {\n    // Add a new column, including column defn and values\n    // Inserts at colNumber or adds to the right\n    this.cacheState();\n\n    if (colIndex === undefined) {\n      this.table.columns.push(column);\n      this.table.rows.forEach((row, i) => {\n        row.push(values[i]);\n      });\n    } else {\n      this.table.columns.splice(colIndex, 0, column);\n      this.table.rows.forEach((row, i) => {\n        row.splice(colIndex, 0, values[i]);\n      });\n    }\n  }\n\n  removeColumns(colIndex, count = 1) {\n    // Remove a column with data\n    this.cacheState();\n\n    this.table.columns.splice(colIndex, count);\n    this.table.rows.forEach(row => {\n      row.splice(colIndex, count);\n    });\n  }\n\n  _assign(target, prop, value) {\n    this.cacheState();\n    target[prop] = value;\n  }\n\n  /* eslint-disable lines-between-class-members */\n  get ref() {\n    return this.table.ref;\n  }\n  set ref(value) {\n    this._assign(this.table, 'ref', value);\n  }\n\n  get name() {\n    return this.table.name;\n  }\n  set name(value) {\n    this.table.name = value;\n  }\n\n  get displayName() {\n    return this.table.displyName || this.table.name;\n  }\n  set displayNamename(value) {\n    this.table.displayName = value;\n  }\n\n  get headerRow() {\n    return this.table.headerRow;\n  }\n  set headerRow(value) {\n    this._assign(this.table, 'headerRow', value);\n  }\n\n  get totalsRow() {\n    return this.table.totalsRow;\n  }\n  set totalsRow(value) {\n    this._assign(this.table, 'totalsRow', value);\n  }\n\n  get theme() {\n    return this.table.style.name;\n  }\n  set theme(value) {\n    this.table.style.name = value;\n  }\n\n  get showFirstColumn() {\n    return this.table.style.showFirstColumn;\n  }\n  set showFirstColumn(value) {\n    this.table.style.showFirstColumn = value;\n  }\n\n  get showLastColumn() {\n    return this.table.style.showLastColumn;\n  }\n  set showLastColumn(value) {\n    this.table.style.showLastColumn = value;\n  }\n\n  get showRowStripes() {\n    return this.table.style.showRowStripes;\n  }\n  set showRowStripes(value) {\n    this.table.style.showRowStripes = value;\n  }\n\n  get showColumnStripes() {\n    return this.table.style.showColumnStripes;\n  }\n  set showColumnStripes(value) {\n    this.table.style.showColumnStripes = value;\n  }\n  /* eslint-enable lines-between-class-members */\n}\n\nmodule.exports = Table;\n","class DataValidations {\n  constructor(model) {\n    this.model = model || {};\n  }\n\n  add(address, validation) {\n    return (this.model[address] = validation);\n  }\n\n  find(address) {\n    return this.model[address];\n  }\n\n  remove(address) {\n    this.model[address] = undefined;\n  }\n}\n\nmodule.exports = DataValidations;\n","\n\nconst crypto = require('crypto');\n\nconst Encryptor = {\n  /**\n   * Calculate a hash of the concatenated buffers with the given algorithm.\n   * @param {string} algorithm - The hash algorithm.\n   * @returns {Buffer} The hash\n   */\n  hash(algorithm, ...buffers) {\n    const hash = crypto.createHash(algorithm);\n    hash.update(Buffer.concat(buffers));\n    return hash.digest();\n  },\n  /**\n   * Convert a password into an encryption key\n   * @param {string} password - The password\n   * @param {string} hashAlgorithm - The hash algoritm\n   * @param {string} saltValue - The salt value\n   * @param {number} spinCount - The spin count\n   * @param {number} keyBits - The length of the key in bits\n   * @param {Buffer} blockKey - The block key\n   * @returns {Buffer} The encryption key\n   */\n  convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {\n    hashAlgorithm = hashAlgorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(hashAlgorithm) < 0) {\n      throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);\n    }\n\n    // Password must be in unicode buffer\n    const passwordBuffer = Buffer.from(password, 'utf16le');\n    // Generate the initial hash\n    let key = this.hash(hashAlgorithm, Buffer.from(saltValue, 'base64'), passwordBuffer);\n    // Now regenerate until spin count\n    for (let i = 0; i < spinCount; i++) {\n      const iterator = Buffer.alloc(4);\n      // this is the 'special' element of Excel password hashing\n      // that stops us from using crypto.pbkdf2()\n      iterator.writeUInt32LE(i, 0);\n      key = this.hash(hashAlgorithm, key, iterator);\n    }\n    return key.toString('base64');\n  },\n  /**\n   * Generates cryptographically strong pseudo-random data.\n   * @param size The size argument is a number indicating the number of bytes to generate.\n   */\n  randomBytes(size) {\n    return crypto.randomBytes(size);\n  },\n};\nmodule.exports = Encryptor;\n","const oneDepthCopy = (obj, nestKeys) => ({\n  ...obj,\n  ...nestKeys.reduce((memo, key) => {\n    if (obj[key]) memo[key] = {...obj[key]};\n    return memo;\n  }, {}),\n});\n\nconst setIfExists = (src, dst, key, nestKeys = []) => {\n  if (src[key]) dst[key] = oneDepthCopy(src[key], nestKeys);\n};\n\nconst isEmptyObj = obj => Object.keys(obj).length === 0;\n\nconst copyStyle = style => {\n  if (!style) return style;\n  if (isEmptyObj(style)) return {};\n\n  const copied = {...style};\n\n  setIfExists(style, copied, 'font', ['color']);\n  setIfExists(style, copied, 'alignment');\n  setIfExists(style, copied, 'protection');\n  if (style.border) {\n    setIfExists(style, copied, 'border');\n    setIfExists(style.border, copied.border, 'top', ['color']);\n    setIfExists(style.border, copied.border, 'left', ['color']);\n    setIfExists(style.border, copied.border, 'bottom', ['color']);\n    setIfExists(style.border, copied.border, 'right', ['color']);\n    setIfExists(style.border, copied.border, 'diagonal', ['color']);\n  }\n\n  if (style.fill) {\n    setIfExists(style, copied, 'fill', ['fgColor', 'bgColor', 'center']);\n    if (style.fill.stops) {\n      copied.fill.stops = style.fill.stops.map(s => oneDepthCopy(s, ['color']));\n    }\n  }\n\n  return copied;\n};\n\nexports.copyStyle = copyStyle;\n","\n\nconst _ = require('../utils/under-dash');\nconst colCache = require('../utils/col-cache');\nconst CellMatrix = require('../utils/cell-matrix');\nconst Range = require('./range');\n\nconst rangeRegexp = /[$](\\w+)[$](\\d+)(:[$](\\w+)[$](\\d+))?/;\n\nclass DefinedNames {\n  constructor() {\n    this.matrixMap = {};\n  }\n\n  getMatrix(name) {\n    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());\n    return matrix;\n  }\n\n  // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2\n  add(locStr, name) {\n    const location = colCache.decodeEx(locStr);\n    this.addEx(location, name);\n  }\n\n  addEx(location, name) {\n    const matrix = this.getMatrix(name);\n    if (location.top) {\n      for (let col = location.left; col <= location.right; col++) {\n        for (let row = location.top; row <= location.bottom; row++) {\n          const address = {\n            sheetName: location.sheetName,\n            address: colCache.n2l(col) + row,\n            row,\n            col,\n          };\n\n          matrix.addCellEx(address);\n        }\n      }\n    } else {\n      matrix.addCellEx(location);\n    }\n  }\n\n  remove(locStr, name) {\n    const location = colCache.decodeEx(locStr);\n    this.removeEx(location, name);\n  }\n\n  removeEx(location, name) {\n    const matrix = this.getMatrix(name);\n    matrix.removeCellEx(location);\n  }\n\n  removeAllNames(location) {\n    _.each(this.matrixMap, matrix => {\n      matrix.removeCellEx(location);\n    });\n  }\n\n  forEach(callback) {\n    _.each(this.matrixMap, (matrix, name) => {\n      matrix.forEach(cell => {\n        callback(name, cell);\n      });\n    });\n  }\n\n  // get all the names of a cell\n  getNames(addressStr) {\n    return this.getNamesEx(colCache.decodeEx(addressStr));\n  }\n\n  getNamesEx(address) {\n    return _.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(\n      Boolean\n    );\n  }\n\n  _explore(matrix, cell) {\n    cell.mark = false;\n    const {sheetName} = cell;\n\n    const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);\n    let x;\n    let y;\n\n    // grow vertical - only one col to worry about\n    function vGrow(yy, edge) {\n      const c = matrix.findCellAt(sheetName, yy, cell.col);\n      if (!c || !c.mark) {\n        return false;\n      }\n      range[edge] = yy;\n      c.mark = false;\n      return true;\n    }\n    for (y = cell.row - 1; vGrow(y, 'top'); y--);\n    for (y = cell.row + 1; vGrow(y, 'bottom'); y++);\n\n    // grow horizontal - ensure all rows can grow\n    function hGrow(xx, edge) {\n      const cells = [];\n      for (y = range.top; y <= range.bottom; y++) {\n        const c = matrix.findCellAt(sheetName, y, xx);\n        if (c && c.mark) {\n          cells.push(c);\n        } else {\n          return false;\n        }\n      }\n      range[edge] = xx;\n      for (let i = 0; i < cells.length; i++) {\n        cells[i].mark = false;\n      }\n      return true;\n    }\n    for (x = cell.col - 1; hGrow(x, 'left'); x--);\n    for (x = cell.col + 1; hGrow(x, 'right'); x++);\n\n    return range;\n  }\n\n  getRanges(name, matrix) {\n    matrix = matrix || this.matrixMap[name];\n\n    if (!matrix) {\n      return {name, ranges: []};\n    }\n\n    // mark and sweep!\n    matrix.forEach(cell => {\n      cell.mark = true;\n    });\n    const ranges = matrix\n      .map(cell => cell.mark && this._explore(matrix, cell))\n      .filter(Boolean)\n      .map(range => range.$shortRange);\n\n    return {\n      name,\n      ranges,\n    };\n  }\n\n  normaliseMatrix(matrix, sheetName) {\n    // some of the cells might have shifted on specified sheet\n    // need to reassign rows, cols\n    matrix.forEachInSheet(sheetName, (cell, row, col) => {\n      if (cell) {\n        if (cell.row !== row || cell.col !== col) {\n          cell.row = row;\n          cell.col = col;\n          cell.address = colCache.n2l(col) + row;\n        }\n      }\n    });\n  }\n\n  spliceRows(sheetName, start, numDelete, numInsert) {\n    _.each(this.matrixMap, matrix => {\n      matrix.spliceRows(sheetName, start, numDelete, numInsert);\n      this.normaliseMatrix(matrix, sheetName);\n    });\n  }\n\n  spliceColumns(sheetName, start, numDelete, numInsert) {\n    _.each(this.matrixMap, matrix => {\n      matrix.spliceColumns(sheetName, start, numDelete, numInsert);\n      this.normaliseMatrix(matrix, sheetName);\n    });\n  }\n\n  get model() {\n    // To get names per cell - just iterate over all names finding cells if they exist\n    return _.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(\n      definedName => definedName.ranges.length\n    );\n  }\n\n  set model(value) {\n    // value is [ { name, ranges }, ... ]\n    const matrixMap = (this.matrixMap = {});\n    value.forEach(definedName => {\n      const matrix = (matrixMap[definedName.name] = new CellMatrix());\n      definedName.ranges.forEach(rangeStr => {\n        if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {\n          matrix.addCell(rangeStr);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = DefinedNames;\n","const _ = require('./under-dash');\nconst colCache = require('./col-cache');\n\nclass CellMatrix {\n  constructor(template) {\n    this.template = template;\n    this.sheets = {};\n  }\n\n  addCell(addressStr) {\n    this.addCellEx(colCache.decodeEx(addressStr));\n  }\n\n  getCell(addressStr) {\n    return this.findCellEx(colCache.decodeEx(addressStr), true);\n  }\n\n  findCell(addressStr) {\n    return this.findCellEx(colCache.decodeEx(addressStr), false);\n  }\n\n  findCellAt(sheetName, rowNumber, colNumber) {\n    const sheet = this.sheets[sheetName];\n    const row = sheet && sheet[rowNumber];\n    return row && row[colNumber];\n  }\n\n  addCellEx(address) {\n    if (address.top) {\n      for (let row = address.top; row <= address.bottom; row++) {\n        for (let col = address.left; col <= address.right; col++) {\n          this.getCellAt(address.sheetName, row, col);\n        }\n      }\n    } else {\n      this.findCellEx(address, true);\n    }\n  }\n\n  getCellEx(address) {\n    return this.findCellEx(address, true);\n  }\n\n  findCellEx(address, create) {\n    const sheet = this.findSheet(address, create);\n    const row = this.findSheetRow(sheet, address, create);\n    return this.findRowCell(row, address, create);\n  }\n\n  getCellAt(sheetName, rowNumber, colNumber) {\n    const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);\n    const row = sheet[rowNumber] || (sheet[rowNumber] = []);\n    const cell =\n      row[colNumber] ||\n      (row[colNumber] = {\n        sheetName,\n        address: colCache.n2l(colNumber) + rowNumber,\n        row: rowNumber,\n        col: colNumber,\n      });\n    return cell;\n  }\n\n  removeCellEx(address) {\n    const sheet = this.findSheet(address);\n    if (!sheet) {\n      return;\n    }\n    const row = this.findSheetRow(sheet, address);\n    if (!row) {\n      return;\n    }\n    delete row[address.col];\n  }\n\n  forEachInSheet(sheetName, callback) {\n    const sheet = this.sheets[sheetName];\n    if (sheet) {\n      sheet.forEach((row, rowNumber) => {\n        if (row) {\n          row.forEach((cell, colNumber) => {\n            if (cell) {\n              callback(cell, rowNumber, colNumber);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  forEach(callback) {\n    _.each(this.sheets, (sheet, sheetName) => {\n      this.forEachInSheet(sheetName, callback);\n    });\n  }\n\n  map(callback) {\n    const results = [];\n    this.forEach(cell => {\n      results.push(callback(cell));\n    });\n    return results;\n  }\n\n  findSheet(address, create) {\n    const name = address.sheetName;\n    if (this.sheets[name]) {\n      return this.sheets[name];\n    }\n    if (create) {\n      return (this.sheets[name] = []);\n    }\n    return undefined;\n  }\n\n  findSheetRow(sheet, address, create) {\n    const {row} = address;\n    if (sheet && sheet[row]) {\n      return sheet[row];\n    }\n    if (create) {\n      return (sheet[row] = []);\n    }\n    return undefined;\n  }\n\n  findRowCell(row, address, create) {\n    const {col} = address;\n    if (row && row[col]) {\n      return row[col];\n    }\n    if (create) {\n      return (row[col] = this.template\n        ? Object.assign(address, JSON.parse(JSON.stringify(this.template)))\n        : address);\n    }\n    return undefined;\n  }\n\n  spliceRows(sheetName, start, numDelete, numInsert) {\n    const sheet = this.sheets[sheetName];\n    if (sheet) {\n      const inserts = [];\n      for (let i = 0; i < numInsert; i++) {\n        inserts.push([]);\n      }\n      sheet.splice(start, numDelete, ...inserts);\n    }\n  }\n\n  spliceColumns(sheetName, start, numDelete, numInsert) {\n    const sheet = this.sheets[sheetName];\n    if (sheet) {\n      const inserts = [];\n      for (let i = 0; i < numInsert; i++) {\n        inserts.push(null);\n      }\n      _.each(sheet, row => {\n        row.splice(start, numDelete, ...inserts);\n      });\n    }\n  }\n}\n\nmodule.exports = CellMatrix;\n","const fs = require('fs');\nconst JSZip = require('jszip');\nconst {PassThrough} = require('readable-stream');\nconst ZipStream = require('../utils/zip-stream');\nconst StreamBuf = require('../utils/stream-buf');\n\nconst utils = require('../utils/utils');\nconst XmlStream = require('../utils/xml-stream');\nconst {bufferToString} = require('../utils/browser-buffer-decode');\n\nconst StylesXform = require('./xform/style/styles-xform');\n\nconst CoreXform = require('./xform/core/core-xform');\nconst SharedStringsXform = require('./xform/strings/shared-strings-xform');\nconst RelationshipsXform = require('./xform/core/relationships-xform');\nconst ContentTypesXform = require('./xform/core/content-types-xform');\nconst AppXform = require('./xform/core/app-xform');\nconst WorkbookXform = require('./xform/book/workbook-xform');\nconst WorksheetXform = require('./xform/sheet/worksheet-xform');\nconst DrawingXform = require('./xform/drawing/drawing-xform');\nconst TableXform = require('./xform/table/table-xform');\nconst CommentsXform = require('./xform/comment/comments-xform');\nconst VmlNotesXform = require('./xform/comment/vml-notes-xform');\n\nconst theme1Xml = require('./xml/theme1');\n\nfunction fsReadFileAsync(filename, options) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, options, (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nclass XLSX {\n  constructor(workbook) {\n    this.workbook = workbook;\n  }\n\n  // ===============================================================================\n  // Workbook\n  // =========================================================================\n  // Read\n\n  async readFile(filename, options) {\n    if (!(await utils.fs.exists(filename))) {\n      throw new Error(`File not found: ${filename}`);\n    }\n    const stream = fs.createReadStream(filename);\n    try {\n      const workbook = await this.read(stream, options);\n      stream.close();\n      return workbook;\n    } catch (error) {\n      stream.close();\n      throw error;\n    }\n  }\n\n  parseRels(stream) {\n    const xform = new RelationshipsXform();\n    return xform.parseStream(stream);\n  }\n\n  parseWorkbook(stream) {\n    const xform = new WorkbookXform();\n    return xform.parseStream(stream);\n  }\n\n  parseSharedStrings(stream) {\n    const xform = new SharedStringsXform();\n    return xform.parseStream(stream);\n  }\n\n  reconcile(model, options) {\n    const workbookXform = new WorkbookXform();\n    const worksheetXform = new WorksheetXform(options);\n    const drawingXform = new DrawingXform();\n    const tableXform = new TableXform();\n\n    workbookXform.reconcile(model);\n\n    // reconcile drawings with their rels\n    const drawingOptions = {\n      media: model.media,\n      mediaIndex: model.mediaIndex,\n    };\n    Object.keys(model.drawings).forEach(name => {\n      const drawing = model.drawings[name];\n      const drawingRel = model.drawingRels[name];\n      if (drawingRel) {\n        drawingOptions.rels = drawingRel.reduce((o, rel) => {\n          o[rel.Id] = rel;\n          return o;\n        }, {});\n        (drawing.anchors || []).forEach(anchor => {\n          const hyperlinks = anchor.picture && anchor.picture.hyperlinks;\n          if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {\n            hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;\n            delete hyperlinks.rId;\n          }\n        });\n        drawingXform.reconcile(drawing, drawingOptions);\n      }\n    });\n\n    // reconcile tables with the default styles\n    const tableOptions = {\n      styles: model.styles,\n    };\n    Object.values(model.tables).forEach(table => {\n      tableXform.reconcile(table, tableOptions);\n    });\n\n    const sheetOptions = {\n      styles: model.styles,\n      sharedStrings: model.sharedStrings,\n      media: model.media,\n      mediaIndex: model.mediaIndex,\n      date1904: model.properties && model.properties.date1904,\n      drawings: model.drawings,\n      comments: model.comments,\n      tables: model.tables,\n      vmlDrawings: model.vmlDrawings,\n    };\n    model.worksheets.forEach(worksheet => {\n      worksheet.relationships = model.worksheetRels[worksheet.sheetNo];\n      worksheetXform.reconcile(worksheet, sheetOptions);\n    });\n\n    // delete unnecessary parts\n    delete model.worksheetHash;\n    delete model.worksheetRels;\n    delete model.globalRels;\n    delete model.sharedStrings;\n    delete model.workbookRels;\n    delete model.sheetDefs;\n    delete model.styles;\n    delete model.mediaIndex;\n    delete model.drawings;\n    delete model.drawingRels;\n    delete model.vmlDrawings;\n  }\n\n  async _processWorksheetEntry(stream, model, sheetNo, options, path) {\n    const xform = new WorksheetXform(options);\n    const worksheet = await xform.parseStream(stream);\n    worksheet.sheetNo = sheetNo;\n    model.worksheetHash[path] = worksheet;\n    model.worksheets.push(worksheet);\n  }\n\n  async _processCommentEntry(stream, model, name) {\n    const xform = new CommentsXform();\n    const comments = await xform.parseStream(stream);\n    model.comments[`../${name}.xml`] = comments;\n  }\n\n  async _processTableEntry(stream, model, name) {\n    const xform = new TableXform();\n    const table = await xform.parseStream(stream);\n    model.tables[`../tables/${name}.xml`] = table;\n  }\n\n  async _processWorksheetRelsEntry(stream, model, sheetNo) {\n    const xform = new RelationshipsXform();\n    const relationships = await xform.parseStream(stream);\n    model.worksheetRels[sheetNo] = relationships;\n  }\n\n  async _processMediaEntry(entry, model, filename) {\n    const lastDot = filename.lastIndexOf('.');\n    // if we can't determine extension, ignore it\n    if (lastDot >= 1) {\n      const extension = filename.substr(lastDot + 1);\n      const name = filename.substr(0, lastDot);\n      await new Promise((resolve, reject) => {\n        const streamBuf = new StreamBuf();\n        streamBuf.on('finish', () => {\n          model.mediaIndex[filename] = model.media.length;\n          model.mediaIndex[name] = model.media.length;\n          const medium = {\n            type: 'image',\n            name,\n            extension,\n            buffer: streamBuf.toBuffer(),\n          };\n          model.media.push(medium);\n          resolve();\n        });\n        entry.on('error', error => {\n          reject(error);\n        });\n        entry.pipe(streamBuf);\n      });\n    }\n  }\n\n  async _processDrawingEntry(entry, model, name) {\n    const xform = new DrawingXform();\n    const drawing = await xform.parseStream(entry);\n    model.drawings[name] = drawing;\n  }\n\n  async _processDrawingRelsEntry(entry, model, name) {\n    const xform = new RelationshipsXform();\n    const relationships = await xform.parseStream(entry);\n    model.drawingRels[name] = relationships;\n  }\n\n  async _processVmlDrawingEntry(entry, model, name) {\n    const xform = new VmlNotesXform();\n    const vmlDrawing = await xform.parseStream(entry);\n    model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;\n  }\n\n  async _processThemeEntry(entry, model, name) {\n    await new Promise((resolve, reject) => {\n      // TODO: stream entry into buffer and store the xml in the model.themes[]\n      const stream = new StreamBuf();\n      entry.on('error', reject);\n      stream.on('error', reject);\n      stream.on('finish', () => {\n        model.themes[name] = stream.read().toString();\n        resolve();\n      });\n      entry.pipe(stream);\n    });\n  }\n\n  /**\n   * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md\n   */\n  createInputStream() {\n    throw new Error(\n      '`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md'\n    );\n  }\n\n  async read(stream, options) {\n    // TODO: Remove once node v8 is deprecated\n    // Detect and upgrade old streams\n    if (!stream[Symbol.asyncIterator] && stream.pipe) {\n      stream = stream.pipe(new PassThrough());\n    }\n    const chunks = [];\n    for await (const chunk of stream) {\n      chunks.push(chunk);\n    }\n    return this.load(Buffer.concat(chunks), options);\n  }\n\n  async load(data, options) {\n    let buffer;\n    if (options && options.base64) {\n      buffer = Buffer.from(data.toString(), 'base64');\n    } else {\n      buffer = data;\n    }\n\n    const model = {\n      worksheets: [],\n      worksheetHash: {},\n      worksheetRels: [],\n      themes: {},\n      media: [],\n      mediaIndex: {},\n      drawings: {},\n      drawingRels: {},\n      comments: {},\n      tables: {},\n      vmlDrawings: {},\n    };\n\n    const zip = await JSZip.loadAsync(buffer);\n    for (const entry of Object.values(zip.files)) {\n      /* eslint-disable no-await-in-loop */\n      if (!entry.dir) {\n        let entryName = entry.name;\n        if (entryName[0] === '/') {\n          entryName = entryName.substr(1);\n        }\n        let stream;\n        if (\n          entryName.match(/xl\\/media\\//) ||\n          // themes are not parsed as stream\n          entryName.match(/xl\\/theme\\/([a-zA-Z0-9]+)[.]xml/)\n        ) {\n          stream = new PassThrough();\n          stream.write(await entry.async('nodebuffer'));\n        } else {\n          // use object mode to avoid buffer-string convention\n          stream = new PassThrough({\n            writableObjectMode: true,\n            readableObjectMode: true,\n          });\n          let content;\n          // https://www.npmjs.com/package/process\n          if (process.browser) {\n            // running in browser, use TextDecoder if possible\n            content = bufferToString(await entry.async('nodebuffer'));\n          } else {\n            // running in node.js\n            content = await entry.async('string');\n          }\n          const chunkSize = 16 * 1024;\n          for (let i = 0; i < content.length; i += chunkSize) {\n            stream.write(content.substring(i, i + chunkSize));\n          }\n        }\n        stream.end();\n        switch (entryName) {\n          case '_rels/.rels':\n            model.globalRels = await this.parseRels(stream);\n            break;\n\n          case 'xl/workbook.xml': {\n            const workbook = await this.parseWorkbook(stream);\n            model.sheets = workbook.sheets;\n            model.definedNames = workbook.definedNames;\n            model.views = workbook.views;\n            model.properties = workbook.properties;\n            model.calcProperties = workbook.calcProperties;\n            break;\n          }\n\n          case 'xl/_rels/workbook.xml.rels':\n            model.workbookRels = await this.parseRels(stream);\n            break;\n\n          case 'xl/sharedStrings.xml':\n            model.sharedStrings = new SharedStringsXform();\n            await model.sharedStrings.parseStream(stream);\n            break;\n\n          case 'xl/styles.xml':\n            model.styles = new StylesXform();\n            await model.styles.parseStream(stream);\n            break;\n\n          case 'docProps/app.xml': {\n            const appXform = new AppXform();\n            const appProperties = await appXform.parseStream(stream);\n            model.company = appProperties.company;\n            model.manager = appProperties.manager;\n            break;\n          }\n\n          case 'docProps/core.xml': {\n            const coreXform = new CoreXform();\n            const coreProperties = await coreXform.parseStream(stream);\n            Object.assign(model, coreProperties);\n            break;\n          }\n\n          default: {\n            let match = entryName.match(/xl\\/worksheets\\/sheet(\\d+)[.]xml/);\n            if (match) {\n              await this._processWorksheetEntry(stream, model, match[1], options, entryName);\n              break;\n            }\n            match = entryName.match(/xl\\/worksheets\\/_rels\\/sheet(\\d+)[.]xml.rels/);\n            if (match) {\n              await this._processWorksheetRelsEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/theme\\/([a-zA-Z0-9]+)[.]xml/);\n            if (match) {\n              await this._processThemeEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/media\\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);\n            if (match) {\n              await this._processMediaEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/drawings\\/([a-zA-Z0-9]+)[.]xml/);\n            if (match) {\n              await this._processDrawingEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/(comments\\d+)[.]xml/);\n            if (match) {\n              await this._processCommentEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/tables\\/(table\\d+)[.]xml/);\n            if (match) {\n              await this._processTableEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/drawings\\/_rels\\/([a-zA-Z0-9]+)[.]xml[.]rels/);\n            if (match) {\n              await this._processDrawingRelsEntry(stream, model, match[1]);\n              break;\n            }\n            match = entryName.match(/xl\\/drawings\\/(vmlDrawing\\d+)[.]vml/);\n            if (match) {\n              await this._processVmlDrawingEntry(stream, model, match[1]);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    this.reconcile(model, options);\n\n    // apply model\n    this.workbook.model = model;\n    return this.workbook;\n  }\n\n  // =========================================================================\n  // Write\n\n  async addMedia(zip, model) {\n    await Promise.all(\n      model.media.map(async medium => {\n        if (medium.type === 'image') {\n          const filename = `xl/media/${medium.name}.${medium.extension}`;\n          if (medium.filename) {\n            const data = await fsReadFileAsync(medium.filename);\n            return zip.append(data, {name: filename});\n          }\n          if (medium.buffer) {\n            return zip.append(medium.buffer, {name: filename});\n          }\n          if (medium.base64) {\n            const dataimg64 = medium.base64;\n            const content = dataimg64.substring(dataimg64.indexOf(',') + 1);\n            return zip.append(content, {name: filename, base64: true});\n          }\n        }\n        throw new Error('Unsupported media');\n      })\n    );\n  }\n\n  addDrawings(zip, model) {\n    const drawingXform = new DrawingXform();\n    const relsXform = new RelationshipsXform();\n\n    model.worksheets.forEach(worksheet => {\n      const {drawing} = worksheet;\n      if (drawing) {\n        drawingXform.prepare(drawing, {});\n        let xml = drawingXform.toXml(drawing);\n        zip.append(xml, {name: `xl/drawings/${drawing.name}.xml`});\n\n        xml = relsXform.toXml(drawing.rels);\n        zip.append(xml, {name: `xl/drawings/_rels/${drawing.name}.xml.rels`});\n      }\n    });\n  }\n\n  addTables(zip, model) {\n    const tableXform = new TableXform();\n\n    model.worksheets.forEach(worksheet => {\n      const {tables} = worksheet;\n      tables.forEach(table => {\n        tableXform.prepare(table, {});\n        const tableXml = tableXform.toXml(table);\n        zip.append(tableXml, {name: `xl/tables/${table.target}`});\n      });\n    });\n  }\n\n  async addContentTypes(zip, model) {\n    const xform = new ContentTypesXform();\n    const xml = xform.toXml(model);\n    zip.append(xml, {name: '[Content_Types].xml'});\n  }\n\n  async addApp(zip, model) {\n    const xform = new AppXform();\n    const xml = xform.toXml(model);\n    zip.append(xml, {name: 'docProps/app.xml'});\n  }\n\n  async addCore(zip, model) {\n    const coreXform = new CoreXform();\n    zip.append(coreXform.toXml(model), {name: 'docProps/core.xml'});\n  }\n\n  async addThemes(zip, model) {\n    const themes = model.themes || {theme1: theme1Xml};\n    Object.keys(themes).forEach(name => {\n      const xml = themes[name];\n      const path = `xl/theme/${name}.xml`;\n      zip.append(xml, {name: path});\n    });\n  }\n\n  async addOfficeRels(zip) {\n    const xform = new RelationshipsXform();\n    const xml = xform.toXml([\n      {Id: 'rId1', Type: XLSX.RelType.OfficeDocument, Target: 'xl/workbook.xml'},\n      {Id: 'rId2', Type: XLSX.RelType.CoreProperties, Target: 'docProps/core.xml'},\n      {Id: 'rId3', Type: XLSX.RelType.ExtenderProperties, Target: 'docProps/app.xml'},\n    ]);\n    zip.append(xml, {name: '_rels/.rels'});\n  }\n\n  async addWorkbookRels(zip, model) {\n    let count = 1;\n    const relationships = [\n      {Id: `rId${count++}`, Type: XLSX.RelType.Styles, Target: 'styles.xml'},\n      {Id: `rId${count++}`, Type: XLSX.RelType.Theme, Target: 'theme/theme1.xml'},\n    ];\n    if (model.sharedStrings.count) {\n      relationships.push({\n        Id: `rId${count++}`,\n        Type: XLSX.RelType.SharedStrings,\n        Target: 'sharedStrings.xml',\n      });\n    }\n    model.worksheets.forEach(worksheet => {\n      worksheet.rId = `rId${count++}`;\n      relationships.push({\n        Id: worksheet.rId,\n        Type: XLSX.RelType.Worksheet,\n        Target: `worksheets/sheet${worksheet.id}.xml`,\n      });\n    });\n    const xform = new RelationshipsXform();\n    const xml = xform.toXml(relationships);\n    zip.append(xml, {name: 'xl/_rels/workbook.xml.rels'});\n  }\n\n  async addSharedStrings(zip, model) {\n    if (model.sharedStrings && model.sharedStrings.count) {\n      zip.append(model.sharedStrings.xml, {name: 'xl/sharedStrings.xml'});\n    }\n  }\n\n  async addStyles(zip, model) {\n    const {xml} = model.styles;\n    if (xml) {\n      zip.append(xml, {name: 'xl/styles.xml'});\n    }\n  }\n\n  async addWorkbook(zip, model) {\n    const xform = new WorkbookXform();\n    zip.append(xform.toXml(model), {name: 'xl/workbook.xml'});\n  }\n\n  async addWorksheets(zip, model) {\n    // preparation phase\n    const worksheetXform = new WorksheetXform();\n    const relationshipsXform = new RelationshipsXform();\n    const commentsXform = new CommentsXform();\n    const vmlNotesXform = new VmlNotesXform();\n\n    // write sheets\n    model.worksheets.forEach(worksheet => {\n      let xmlStream = new XmlStream();\n      worksheetXform.render(xmlStream, worksheet);\n      zip.append(xmlStream.xml, {name: `xl/worksheets/sheet${worksheet.id}.xml`});\n\n      if (worksheet.rels && worksheet.rels.length) {\n        xmlStream = new XmlStream();\n        relationshipsXform.render(xmlStream, worksheet.rels);\n        zip.append(xmlStream.xml, {name: `xl/worksheets/_rels/sheet${worksheet.id}.xml.rels`});\n      }\n\n      if (worksheet.comments.length > 0) {\n        xmlStream = new XmlStream();\n        commentsXform.render(xmlStream, worksheet);\n        zip.append(xmlStream.xml, {name: `xl/comments${worksheet.id}.xml`});\n\n        xmlStream = new XmlStream();\n        vmlNotesXform.render(xmlStream, worksheet);\n        zip.append(xmlStream.xml, {name: `xl/drawings/vmlDrawing${worksheet.id}.vml`});\n      }\n    });\n  }\n\n  _finalize(zip) {\n    return new Promise((resolve, reject) => {\n      zip.on('finish', () => {\n        resolve(this);\n      });\n      zip.on('error', reject);\n      zip.finalize();\n    });\n  }\n\n  prepareModel(model, options) {\n    // ensure following properties have sane values\n    model.creator = model.creator || 'ExcelJS';\n    model.lastModifiedBy = model.lastModifiedBy || 'ExcelJS';\n    model.created = model.created || new Date();\n    model.modified = model.modified || new Date();\n\n    model.useSharedStrings = options.useSharedStrings !== undefined ? options.useSharedStrings : true;\n    model.useStyles = options.useStyles !== undefined ? options.useStyles : true;\n\n    // Manage the shared strings\n    model.sharedStrings = new SharedStringsXform();\n\n    // add a style manager to handle cell formats, fonts, etc.\n    model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();\n\n    // prepare all of the things before the render\n    const workbookXform = new WorkbookXform();\n    const worksheetXform = new WorksheetXform();\n\n    workbookXform.prepare(model);\n\n    const worksheetOptions = {\n      sharedStrings: model.sharedStrings,\n      styles: model.styles,\n      date1904: model.properties.date1904,\n      drawingsCount: 0,\n      media: model.media,\n    };\n    worksheetOptions.drawings = model.drawings = [];\n    worksheetOptions.commentRefs = model.commentRefs = [];\n    let tableCount = 0;\n    model.tables = [];\n    model.worksheets.forEach(worksheet => {\n      // assign unique filenames to tables\n      worksheet.tables.forEach(table => {\n        tableCount++;\n        table.target = `table${tableCount}.xml`;\n        table.id = tableCount;\n        model.tables.push(table);\n      });\n\n      worksheetXform.prepare(worksheet, worksheetOptions);\n    });\n\n    // TODO: workbook drawing list\n  }\n\n  async write(stream, options) {\n    options = options || {};\n    const {model} = this.workbook;\n    const zip = new ZipStream.ZipWriter(options.zip);\n    zip.pipe(stream);\n\n    this.prepareModel(model, options);\n\n    // render\n    await this.addContentTypes(zip, model);\n    await this.addOfficeRels(zip, model);\n    await this.addWorkbookRels(zip, model);\n    await this.addWorksheets(zip, model);\n    await this.addSharedStrings(zip, model); // always after worksheets\n    await this.addDrawings(zip, model);\n    await this.addTables(zip, model);\n    await Promise.all([this.addThemes(zip, model), this.addStyles(zip, model)]);\n    await this.addMedia(zip, model);\n    await Promise.all([this.addApp(zip, model), this.addCore(zip, model)]);\n    await this.addWorkbook(zip, model);\n    return this._finalize(zip);\n  }\n\n  writeFile(filename, options) {\n    const stream = fs.createWriteStream(filename);\n\n    return new Promise((resolve, reject) => {\n      stream.on('finish', () => {\n        resolve();\n      });\n      stream.on('error', error => {\n        reject(error);\n      });\n\n      this.write(stream, options).then(() => {\n        stream.end();\n      }).catch(err=>{\n        reject(err);\n      });\n    });\n  }\n\n  async writeBuffer(options) {\n    const stream = new StreamBuf();\n    await this.write(stream, options);\n    return stream.read();\n  }\n}\n\nXLSX.RelType = require('./rel-type');\n\nmodule.exports = XLSX;\n","const events = require('events');\nconst JSZip = require('jszip');\n\nconst StreamBuf = require('./stream-buf');\nconst {stringToBuffer} = require('./browser-buffer-encode');\n\n// =============================================================================\n// The ZipWriter class\n// Packs streamed data into an output zip stream\nclass ZipWriter extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.options = Object.assign(\n      {\n        type: 'nodebuffer',\n        compression: 'DEFLATE',\n      },\n      options\n    );\n\n    this.zip = new JSZip();\n    this.stream = new StreamBuf();\n  }\n\n  append(data, options) {\n    if (options.hasOwnProperty('base64') && options.base64) {\n      this.zip.file(options.name, data, {base64: true});\n    } else {\n      // https://www.npmjs.com/package/process\n      if (process.browser && typeof data === 'string') {\n        // use TextEncoder in browser\n        data = stringToBuffer(data);\n      }\n      this.zip.file(options.name, data);\n    }\n  }\n\n  async finalize() {\n    const content = await this.zip.generateAsync(this.options);\n    this.stream.end(content);\n    this.emit('finish');\n  }\n\n  // ==========================================================================\n  // Stream.Readable interface\n  read(size) {\n    return this.stream.read(size);\n  }\n\n  setEncoding(encoding) {\n    return this.stream.setEncoding(encoding);\n  }\n\n  pause() {\n    return this.stream.pause();\n  }\n\n  resume() {\n    return this.stream.resume();\n  }\n\n  isPaused() {\n    return this.stream.isPaused();\n  }\n\n  pipe(destination, options) {\n    return this.stream.pipe(destination, options);\n  }\n\n  unpipe(destination) {\n    return this.stream.unpipe(destination);\n  }\n\n  unshift(chunk) {\n    return this.stream.unshift(chunk);\n  }\n\n  wrap(stream) {\n    return this.stream.wrap(stream);\n  }\n}\n\n// =============================================================================\n\nmodule.exports = {\n  ZipWriter,\n};\n","/* eslint-disable max-classes-per-file */\nconst Stream = require('readable-stream');\n\nconst utils = require('./utils');\nconst StringBuf = require('./string-buf');\n\n// =============================================================================\n// data chunks - encapsulating incoming data\nclass StringChunk {\n  constructor(data, encoding) {\n    this._data = data;\n    this._encoding = encoding;\n  }\n\n  get length() {\n    return this.toBuffer().length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    return this.toBuffer().copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    if (!this._buffer) {\n      this._buffer = Buffer.from(this._data, this._encoding);\n    }\n    return this._buffer;\n  }\n}\n\nclass StringBufChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._data._buf.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data.toBuffer();\n  }\n}\n\nclass BufferChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    this._data.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data;\n  }\n}\n\n// =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\nclass ReadWriteBuf {\n  constructor(size) {\n    this.size = size;\n    // the buffer\n    this.buffer = Buffer.alloc(size);\n    // read index\n    this.iRead = 0;\n    // write index\n    this.iWrite = 0;\n  }\n\n  toBuffer() {\n    if (this.iRead === 0 && this.iWrite === this.size) {\n      return this.buffer;\n    }\n\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n    return buf;\n  }\n\n  get length() {\n    return this.iWrite - this.iRead;\n  }\n\n  get eod() {\n    return this.iRead === this.iWrite;\n  }\n\n  get full() {\n    return this.iWrite === this.size;\n  }\n\n  read(size) {\n    let buf;\n    // read size bytes from buffer and return buffer\n    if (size === 0) {\n      // special case - return null if no data requested\n      return null;\n    }\n\n    if (size === undefined || size >= this.length) {\n      // if no size specified or size is at least what we have then return all of the bytes\n      buf = this.toBuffer();\n      this.iRead = this.iWrite;\n      return buf;\n    }\n\n    // otherwise return a chunk\n    buf = Buffer.alloc(size);\n    this.buffer.copy(buf, 0, this.iRead, size);\n    this.iRead += size;\n    return buf;\n  }\n\n  write(chunk, offset, length) {\n    // write as many bytes from data from optional source offset\n    // and return number of bytes written\n    const size = Math.min(length, this.size - this.iWrite);\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n    this.iWrite += size;\n    return size;\n  }\n}\n\n// =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\n\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\n// integration tests\nconst StreamBuf = function(options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = [];\n\n  // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n  this.batch = options.batch || false;\n\n  this.corked = false;\n  // where in the current writable buffer we're up to\n  this.inPos = 0;\n\n  // where in the current readable buffer we've read up to\n  this.outPos = 0;\n\n  // consuming pipe streams go here\n  this.pipes = [];\n\n  // controls emit('data')\n  this.paused = false;\n\n  this.encoding = null;\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  toBuffer() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n      case 1:\n        return this.buffers[0].toBuffer();\n      default:\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\n    }\n  },\n\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  _getWritableBuffer() {\n    if (this.buffers.length) {\n      const last = this.buffers[this.buffers.length - 1];\n      if (!last.full) {\n        return last;\n      }\n    }\n    const buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n\n  async _pipe(chunk) {\n    const write = function(pipe) {\n      return new Promise(resolve => {\n        pipe.write(chunk.toBuffer(), () => {\n          resolve();\n        });\n      });\n    };\n    await Promise.all(this.pipes.map(write));\n  },\n  _writeToBuffers(chunk) {\n    let inPos = 0;\n    const inLen = chunk.length;\n    while (inPos < inLen) {\n      // find writable buffer\n      const buffer = this._getWritableBuffer();\n\n      // write some data\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n  async write(data, encoding, callback) {\n    if (encoding instanceof Function) {\n      callback = encoding;\n      encoding = 'utf8';\n    }\n    callback = callback || utils.nop;\n\n    // encapsulate data into a chunk\n    let chunk;\n    if (data instanceof StringBuf) {\n      chunk = new StringBufChunk(data);\n    } else if (data instanceof Buffer) {\n      chunk = new BufferChunk(data);\n    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {\n      chunk = new StringChunk(data, encoding);\n    } else {\n      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\n    }\n\n    // now, do something with the chunk\n    if (this.pipes.length) {\n      if (this.batch) {\n        this._writeToBuffers(chunk);\n        while (!this.corked && this.buffers.length > 1) {\n          this._pipe(this.buffers.shift());\n        }\n      } else if (!this.corked) {\n        await this._pipe(chunk);\n        callback();\n      } else {\n        this._writeToBuffers(chunk);\n        process.nextTick(callback);\n      }\n    } else {\n      if (!this.paused) {\n        this.emit('data', chunk.toBuffer());\n      }\n\n      this._writeToBuffers(chunk);\n      this.emit('readable');\n    }\n\n    return true;\n  },\n  cork() {\n    this.corked = true;\n  },\n  _flush(/* destination */) {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n  uncork() {\n    this.corked = false;\n    this._flush();\n  },\n  end(chunk, encoding, callback) {\n    const writeComplete = error => {\n      if (error) {\n        callback(error);\n      } else {\n        this._flush();\n        this.pipes.forEach(pipe => {\n          pipe.end();\n        });\n        this.emit('finish');\n      }\n    };\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read(size) {\n    let buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        const first = this.buffers[0];\n        const buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n  setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    this.paused = false;\n  },\n  isPaused() {\n    return !!this.paused;\n  },\n  pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n  unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\n  },\n  unshift(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  },\n});\n\nmodule.exports = StreamBuf;\n","const fs = require('fs');\n\n// useful stuff\nconst inherits = function(cls, superCtor, statics, prototype) {\n  // eslint-disable-next-line no-underscore-dangle\n  cls.super_ = superCtor;\n\n  if (!prototype) {\n    prototype = statics;\n    statics = null;\n  }\n\n  if (statics) {\n    Object.keys(statics).forEach(i => {\n      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));\n    });\n  }\n\n  const properties = {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    },\n  };\n  if (prototype) {\n    Object.keys(prototype).forEach(i => {\n      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);\n    });\n  }\n\n  cls.prototype = Object.create(superCtor.prototype, properties);\n};\n\n// eslint-disable-next-line no-control-regex\nconst xmlDecodeRegex = /[<>&'\"\\x7F\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/;\nconst utils = {\n  nop() {},\n  promiseImmediate(value) {\n    return new Promise(resolve => {\n      if (global.setImmediate) {\n        setImmediate(() => {\n          resolve(value);\n        });\n      } else {\n        // poorman's setImmediate - must wait at least 1ms\n        setTimeout(() => {\n          resolve(value);\n        }, 1);\n      }\n    });\n  },\n  inherits,\n  dateToExcel(d, date1904) {\n    return 25569 + ( d.getTime() / (24 * 3600 * 1000) ) - (date1904 ? 1462 : 0);\n  },\n  excelToDate(v, date1904) {\n    const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000);\n    return new Date(millisecondSinceEpoch);\n  },\n  parsePath(filepath) {\n    const last = filepath.lastIndexOf('/');\n    return {\n      path: filepath.substring(0, last),\n      name: filepath.substring(last + 1),\n    };\n  },\n  getRelsPath(filepath) {\n    const path = utils.parsePath(filepath);\n    return `${path.path}/_rels/${path.name}.rels`;\n  },\n  xmlEncode(text) {\n    const regexResult = xmlDecodeRegex.exec(text);\n    if (!regexResult) return text;\n\n    let result = '';\n    let escape = '';\n    let lastIndex = 0;\n    let i = regexResult.index;\n    for (; i < text.length; i++) {\n      const charCode = text.charCodeAt(i);\n      switch (charCode) {\n        case 34: // \"\n          escape = '&quot;';\n          break;\n        case 38: // &\n          escape = '&amp;';\n          break;\n        case 39: // '\n          escape = '&apos;';\n          break;\n        case 60: // <\n          escape = '&lt;';\n          break;\n        case 62: // >\n          escape = '&gt;';\n          break;\n        case 127:\n          escape = '';\n          break;\n        default: {\n          if (charCode <= 31 && (charCode <= 8 || (charCode >= 11 && charCode !== 13))) {\n            escape = '';\n            break;\n          }\n          continue;\n        }\n      }\n      if (lastIndex !== i) result += text.substring(lastIndex, i);\n      lastIndex = i + 1;\n      if (escape) result += escape;\n    }\n    if (lastIndex !== i) return result + text.substring(lastIndex, i);\n    return result;\n  },\n  xmlDecode(text) {\n    return text.replace(/&([a-z]*);/g, c => {\n      switch (c) {\n        case '&lt;':\n          return '<';\n        case '&gt;':\n          return '>';\n        case '&amp;':\n          return '&';\n        case '&apos;':\n          return '\\'';\n        case '&quot;':\n          return '\"';\n        default:\n          return c;\n      }\n    });\n  },\n  validInt(value) {\n    const i = parseInt(value, 10);\n    return !Number.isNaN(i) ? i : 0;\n  },\n\n  isDateFmt(fmt) {\n    if (!fmt) {\n      return false;\n    }\n\n    // must remove all chars inside quotes and []\n    fmt = fmt.replace(/\\[[^\\]]*]/g, '');\n    fmt = fmt.replace(/\"[^\"]*\"/g, '');\n    // then check for date formatting chars\n    const result = fmt.match(/[ymdhMsb]+/) !== null;\n    return result;\n  },\n\n  fs: {\n    exists(path) {\n      return new Promise(resolve => {\n        fs.access(path, fs.constants.F_OK, err => {\n          resolve(!err);\n        });\n      });\n    },\n  },\n\n  toIsoDateString(dt) {\n    return dt.toIsoString().subsstr(0, 10);\n  },\n\n  parseBoolean(value) {\n    return value === true || value === 'true' || value === 1 || value === '1';\n  },\n};\n\nmodule.exports = utils;\n","// StringBuf - a way to keep string memory operations to a minimum\n// while building the strings for the xml files\nclass StringBuf {\n  constructor(options) {\n    this._buf = Buffer.alloc((options && options.size) || 16384);\n    this._encoding = (options && options.encoding) || 'utf8';\n\n    // where in the buffer we are at\n    this._inPos = 0;\n\n    // for use by toBuffer()\n    this._buffer = undefined;\n  }\n\n  get length() {\n    return this._inPos;\n  }\n\n  get capacity() {\n    return this._buf.length;\n  }\n\n  get buffer() {\n    return this._buf;\n  }\n\n  toBuffer() {\n    // return the current data as a single enclosing buffer\n    if (!this._buffer) {\n      this._buffer = Buffer.alloc(this.length);\n      this._buf.copy(this._buffer, 0, 0, this.length);\n    }\n    return this._buffer;\n  }\n\n  reset(position) {\n    position = position || 0;\n    this._buffer = undefined;\n    this._inPos = position;\n  }\n\n  _grow(min) {\n    let size = this._buf.length * 2;\n    while (size < min) {\n      size *= 2;\n    }\n    const buf = Buffer.alloc(size);\n    this._buf.copy(buf, 0);\n    this._buf = buf;\n  }\n\n  addText(text) {\n    this._buffer = undefined;\n\n    let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\n\n    // if we've hit (or nearing capacity), grow the buf\n    while (inPos >= this._buf.length - 4) {\n      this._grow(this._inPos + text.length);\n\n      // keep trying to write until we've completely written the text\n      inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\n    }\n\n    this._inPos = inPos;\n  }\n\n  addStringBuf(inBuf) {\n    if (inBuf.length) {\n      this._buffer = undefined;\n\n      if (this.length + inBuf.length > this.capacity) {\n        this._grow(this.length + inBuf.length);\n      }\n      // eslint-disable-next-line no-underscore-dangle\n      inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);\n      this._inPos += inBuf.length;\n    }\n  }\n}\n\nmodule.exports = StringBuf;\n","// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst textEncoder = typeof TextEncoder === 'undefined' ? null : new TextEncoder('utf-8');\nconst {Buffer} = require('buffer');\n\nfunction stringToBuffer(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  if (textEncoder) {\n    return Buffer.from(textEncoder.encode(str).buffer);\n  }\n  return Buffer.from(str);\n}\n\nexports.stringToBuffer = stringToBuffer;\n","const _ = require('./under-dash');\n\nconst utils = require('./utils');\n\n// constants\nconst OPEN_ANGLE = '<';\nconst CLOSE_ANGLE = '>';\nconst OPEN_ANGLE_SLASH = '</';\nconst CLOSE_SLASH_ANGLE = '/>';\n\nfunction pushAttribute(xml, name, value) {\n  xml.push(` ${name}=\"${utils.xmlEncode(value.toString())}\"`);\n}\nfunction pushAttributes(xml, attributes) {\n  if (attributes) {\n    const tmp = [];\n    _.each(attributes, (value, name) => {\n      if (value !== undefined) {\n        pushAttribute(tmp, name, value);\n      }\n    });\n    xml.push(tmp.join(\"\"));\n  }\n}\n\nclass XmlStream {\n  constructor() {\n    this._xml = [];\n    this._stack = [];\n    this._rollbacks = [];\n  }\n\n  get tos() {\n    return this._stack.length ? this._stack[this._stack.length - 1] : undefined;\n  }\n\n  get cursor() {\n    // handy way to track whether anything has been added\n    return this._xml.length;\n  }\n\n  openXml(docAttributes) {\n    const xml = this._xml;\n    // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n    xml.push('<?xml');\n    pushAttributes(xml, docAttributes);\n    xml.push('?>\\n');\n  }\n\n  openNode(name, attributes) {\n    const parent = this.tos;\n    const xml = this._xml;\n    if (parent && this.open) {\n      xml.push(CLOSE_ANGLE);\n    }\n\n    this._stack.push(name);\n\n    // start streaming node\n    xml.push(OPEN_ANGLE);\n    xml.push(name);\n    pushAttributes(xml, attributes);\n    this.leaf = true;\n    this.open = true;\n  }\n\n  addAttribute(name, value) {\n    if (!this.open) {\n      throw new Error('Cannot write attributes to node if it is not open');\n    }\n    if (value !== undefined) {\n      pushAttribute(this._xml, name, value);\n    }\n  }\n\n  addAttributes(attrs) {\n    if (!this.open) {\n      throw new Error('Cannot write attributes to node if it is not open');\n    }\n    pushAttributes(this._xml, attrs);\n  }\n\n  writeText(text) {\n    const xml = this._xml;\n    if (this.open) {\n      xml.push(CLOSE_ANGLE);\n      this.open = false;\n    }\n    this.leaf = false;\n    xml.push(utils.xmlEncode(text.toString()));\n  }\n\n  writeXml(xml) {\n    if (this.open) {\n      this._xml.push(CLOSE_ANGLE);\n      this.open = false;\n    }\n    this.leaf = false;\n    this._xml.push(xml);\n  }\n\n  closeNode() {\n    const node = this._stack.pop();\n    const xml = this._xml;\n    if (this.leaf) {\n      xml.push(CLOSE_SLASH_ANGLE);\n    } else {\n      xml.push(OPEN_ANGLE_SLASH);\n      xml.push(node);\n      xml.push(CLOSE_ANGLE);\n    }\n    this.open = false;\n    this.leaf = false;\n  }\n\n  leafNode(name, attributes, text) {\n    this.openNode(name, attributes);\n    if (text !== undefined) {\n      // zeros need to be written\n      this.writeText(text);\n    }\n    this.closeNode();\n  }\n\n  closeAll() {\n    while (this._stack.length) {\n      this.closeNode();\n    }\n  }\n\n  addRollback() {\n    this._rollbacks.push({\n      xml: this._xml.length,\n      stack: this._stack.length,\n      leaf: this.leaf,\n      open: this.open,\n    });\n    return this.cursor;\n  }\n\n  commit() {\n    this._rollbacks.pop();\n  }\n\n  rollback() {\n    const r = this._rollbacks.pop();\n    if (this._xml.length > r.xml) {\n      this._xml.splice(r.xml, this._xml.length - r.xml);\n    }\n    if (this._stack.length > r.stack) {\n      this._stack.splice(r.stack, this._stack.length - r.stack);\n    }\n    this.leaf = r.leaf;\n    this.open = r.open;\n  }\n\n  get xml() {\n    this.closeAll();\n    return this._xml.join('');\n  }\n}\n\nXmlStream.StdDocAttributes = {\n  version: '1.0',\n  encoding: 'UTF-8',\n  standalone: 'yes',\n};\n\nmodule.exports = XmlStream;\n","// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst textDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');\n\nfunction bufferToString(chunk) {\n  if (typeof chunk === 'string') {\n    return chunk;\n  }\n  if (textDecoder) {\n    return textDecoder.decode(chunk);\n  }\n  return chunk.toString();\n}\n\nexports.bufferToString = bufferToString;\n","/* eslint-disable max-classes-per-file */\nconst Enums = require('../../../doc/enums');\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\nconst StaticXform = require('../static-xform');\nconst ListXform = require('../list-xform');\nconst FontXform = require('./font-xform');\nconst FillXform = require('./fill-xform');\nconst BorderXform = require('./border-xform');\nconst NumFmtXform = require('./numfmt-xform');\nconst StyleXform = require('./style-xform');\nconst DxfXform = require('./dxf-xform');\n\n// custom numfmt ids start here\nconst NUMFMT_BASE = 164;\n\n// =============================================================================\n// StylesXform is used to generate and parse the styles.xml file\n// it manages the collections of fonts, number formats, alignments, etc\nclass StylesXform extends BaseXform {\n  constructor(initialise) {\n    super();\n\n    this.map = {\n      numFmts: new ListXform({tag: 'numFmts', count: true, childXform: new NumFmtXform()}),\n      fonts: new ListXform({\n        tag: 'fonts',\n        count: true,\n        childXform: new FontXform(),\n        $: {'x14ac:knownFonts': 1},\n      }),\n      fills: new ListXform({tag: 'fills', count: true, childXform: new FillXform()}),\n      borders: new ListXform({tag: 'borders', count: true, childXform: new BorderXform()}),\n      cellStyleXfs: new ListXform({tag: 'cellStyleXfs', count: true, childXform: new StyleXform()}),\n      cellXfs: new ListXform({\n        tag: 'cellXfs',\n        count: true,\n        childXform: new StyleXform({xfId: true}),\n      }),\n      dxfs: new ListXform({tag: 'dxfs', always: true, count: true, childXform: new DxfXform()}),\n\n      // for style manager\n      numFmt: new NumFmtXform(),\n      font: new FontXform(),\n      fill: new FillXform(),\n      border: new BorderXform(),\n      style: new StyleXform({xfId: true}),\n\n      cellStyles: StylesXform.STATIC_XFORMS.cellStyles,\n      tableStyles: StylesXform.STATIC_XFORMS.tableStyles,\n      extLst: StylesXform.STATIC_XFORMS.extLst,\n    };\n\n    if (initialise) {\n      // StylesXform also acts as style manager and is used to build up styles-model during worksheet processing\n      this.init();\n    }\n  }\n\n  initIndex() {\n    this.index = {\n      style: {},\n      numFmt: {},\n      numFmtNextId: 164, // start custom format ids here\n      font: {},\n      border: {},\n      fill: {},\n    };\n  }\n\n  init() {\n    // Prepare for Style Manager role\n    this.model = {\n      styles: [],\n      numFmts: [],\n      fonts: [],\n      borders: [],\n      fills: [],\n      dxfs: [],\n    };\n\n    this.initIndex();\n\n    // default (zero) border\n    this._addBorder({});\n\n    // add default (all zero) style\n    this._addStyle({numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0});\n\n    // add default fills\n    this._addFill({type: 'pattern', pattern: 'none'});\n    this._addFill({type: 'pattern', pattern: 'gray125'});\n\n    this.weakMap = new WeakMap();\n  }\n\n  render(xmlStream, model) {\n    model = model || this.model;\n    //\n    //   <fonts count=\"2\" x14ac:knownFonts=\"1\">\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n\n    xmlStream.openNode('styleSheet', StylesXform.STYLESHEET_ATTRIBUTES);\n\n    if (this.index) {\n      // model has been built by style manager role (contains xml)\n      if (model.numFmts && model.numFmts.length) {\n        xmlStream.openNode('numFmts', {count: model.numFmts.length});\n        model.numFmts.forEach(numFmtXml => {\n          xmlStream.writeXml(numFmtXml);\n        });\n        xmlStream.closeNode();\n      }\n\n      if (!model.fonts.length) {\n        // default (zero) font\n        this._addFont({size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'});\n      }\n      xmlStream.openNode('fonts', {count: model.fonts.length, 'x14ac:knownFonts': 1});\n      model.fonts.forEach(fontXml => {\n        xmlStream.writeXml(fontXml);\n      });\n      xmlStream.closeNode();\n\n      xmlStream.openNode('fills', {count: model.fills.length});\n      model.fills.forEach(fillXml => {\n        xmlStream.writeXml(fillXml);\n      });\n      xmlStream.closeNode();\n\n      xmlStream.openNode('borders', {count: model.borders.length});\n      model.borders.forEach(borderXml => {\n        xmlStream.writeXml(borderXml);\n      });\n      xmlStream.closeNode();\n\n      this.map.cellStyleXfs.render(xmlStream, [{numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0}]);\n\n      xmlStream.openNode('cellXfs', {count: model.styles.length});\n      model.styles.forEach(styleXml => {\n        xmlStream.writeXml(styleXml);\n      });\n      xmlStream.closeNode();\n    } else {\n      // model is plain JSON and needs to be xformed\n      this.map.numFmts.render(xmlStream, model.numFmts);\n      this.map.fonts.render(xmlStream, model.fonts);\n      this.map.fills.render(xmlStream, model.fills);\n      this.map.borders.render(xmlStream, model.borders);\n      this.map.cellStyleXfs.render(xmlStream, [{numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0}]);\n      this.map.cellXfs.render(xmlStream, model.styles);\n    }\n\n    StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream);\n\n    this.map.dxfs.render(xmlStream, model.dxfs);\n\n    StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream);\n    StylesXform.STATIC_XFORMS.extLst.render(xmlStream);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'styleSheet':\n        this.initIndex();\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        return true;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'styleSheet': {\n        this.model = {};\n        const add = (propName, xform) => {\n          if (xform.model && xform.model.length) {\n            this.model[propName] = xform.model;\n          }\n        };\n        add('numFmts', this.map.numFmts);\n        add('fonts', this.map.fonts);\n        add('fills', this.map.fills);\n        add('borders', this.map.borders);\n        add('styles', this.map.cellXfs);\n        add('dxfs', this.map.dxfs);\n\n        // index numFmts\n        this.index = {\n          model: [],\n          numFmt: [],\n        };\n        if (this.model.numFmts) {\n          const numFmtIndex = this.index.numFmt;\n          this.model.numFmts.forEach(numFmt => {\n            numFmtIndex[numFmt.id] = numFmt.formatCode;\n          });\n        }\n\n        return false;\n      }\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n\n  // add a cell's style model to the collection\n  // each style property is processed and cross-referenced, etc.\n  // the styleId is returned. Note: cellType is used when numFmt not defined\n  addStyleModel(model, cellType) {\n    if (!model) {\n      return 0;\n    }\n\n    // if we have no default font, add it here now\n    if (!this.model.fonts.length) {\n      // default (zero) font\n      this._addFont({size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'});\n    }\n\n    // if we have seen this style object before, assume it has the same styleId\n    if (this.weakMap && this.weakMap.has(model)) {\n      return this.weakMap.get(model);\n    }\n\n    const style = {};\n    cellType = cellType || Enums.ValueType.Number;\n\n    if (model.numFmt) {\n      style.numFmtId = this._addNumFmtStr(model.numFmt);\n    } else {\n      switch (cellType) {\n        case Enums.ValueType.Number:\n          style.numFmtId = this._addNumFmtStr('General');\n          break;\n        case Enums.ValueType.Date:\n          style.numFmtId = this._addNumFmtStr('mm-dd-yy');\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (model.font) {\n      style.fontId = this._addFont(model.font);\n    }\n\n    if (model.border) {\n      style.borderId = this._addBorder(model.border);\n    }\n\n    if (model.fill) {\n      style.fillId = this._addFill(model.fill);\n    }\n\n    if (model.alignment) {\n      style.alignment = model.alignment;\n    }\n\n    if (model.protection) {\n      style.protection = model.protection;\n    }\n\n    const styleId = this._addStyle(style);\n    if (this.weakMap) {\n      this.weakMap.set(model, styleId);\n    }\n    return styleId;\n  }\n\n  // given a styleId (i.e. s=\"n\"), get the cell's style model\n  // objects are shared where possible.\n  getStyleModel(id) {\n    // if the style doesn't exist return null\n    const style = this.model.styles[id];\n    if (!style) return null;\n\n    // have we built this model before?\n    let model = this.index.model[id];\n    if (model) return model;\n\n    // build a new model\n    model = this.index.model[id] = {};\n\n    // -------------------------------------------------------\n    // number format\n    if (style.numFmtId) {\n      const numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);\n      if (numFmt) {\n        model.numFmt = numFmt;\n      }\n    }\n\n    function addStyle(name, group, styleId) {\n      if (styleId || styleId === 0) {\n        const part = group[styleId];\n        if (part) {\n          model[name] = part;\n        }\n      }\n    }\n\n    addStyle('font', this.model.fonts, style.fontId);\n    addStyle('border', this.model.borders, style.borderId);\n    addStyle('fill', this.model.fills, style.fillId);\n\n    // -------------------------------------------------------\n    // alignment\n    if (style.alignment) {\n      model.alignment = style.alignment;\n    }\n\n    // -------------------------------------------------------\n    // protection\n    if (style.protection) {\n      model.protection = style.protection;\n    }\n\n    return model;\n  }\n\n  addDxfStyle(style) {\n    if (style.numFmt) {\n      // register numFmtId to use it during dxf-xform rendering\n      style.numFmtId = this._addNumFmtStr(style.numFmt);\n    }\n\n    this.model.dxfs.push(style);\n    return this.model.dxfs.length - 1;\n  }\n\n  getDxfStyle(id) {\n    return this.model.dxfs[id];\n  }\n\n  // =========================================================================\n  // Private Interface\n  _addStyle(style) {\n    const xml = this.map.style.toXml(style);\n    let index = this.index.style[xml];\n    if (index === undefined) {\n      index = this.index.style[xml] = this.model.styles.length;\n      this.model.styles.push(xml);\n    }\n    return index;\n  }\n\n  // =========================================================================\n  // Number Formats\n  _addNumFmtStr(formatCode) {\n    // check if default format\n    let index = NumFmtXform.getDefaultFmtId(formatCode);\n    if (index !== undefined) return index;\n\n    // check if already in\n    index = this.index.numFmt[formatCode];\n    if (index !== undefined) return index;\n\n    index = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;\n    const xml = this.map.numFmt.toXml({id: index, formatCode});\n    this.model.numFmts.push(xml);\n    return index;\n  }\n\n  // =========================================================================\n  // Fonts\n  _addFont(font) {\n    const xml = this.map.font.toXml(font);\n    let index = this.index.font[xml];\n    if (index === undefined) {\n      index = this.index.font[xml] = this.model.fonts.length;\n      this.model.fonts.push(xml);\n    }\n    return index;\n  }\n\n  // =========================================================================\n  // Borders\n  _addBorder(border) {\n    const xml = this.map.border.toXml(border);\n    let index = this.index.border[xml];\n    if (index === undefined) {\n      index = this.index.border[xml] = this.model.borders.length;\n      this.model.borders.push(xml);\n    }\n    return index;\n  }\n\n  // =========================================================================\n  // Fills\n  _addFill(fill) {\n    const xml = this.map.fill.toXml(fill);\n    let index = this.index.fill[xml];\n    if (index === undefined) {\n      index = this.index.fill[xml] = this.model.fills.length;\n      this.model.fills.push(xml);\n    }\n    return index;\n  }\n\n  // =========================================================================\n}\n\nStylesXform.STYLESHEET_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'x14ac x16r2',\n  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',\n  'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main',\n};\nStylesXform.STATIC_XFORMS = {\n  cellStyles: new StaticXform({\n    tag: 'cellStyles',\n    $: {count: 1},\n    c: [{tag: 'cellStyle', $: {name: 'Normal', xfId: 0, builtinId: 0}}],\n  }),\n  dxfs: new StaticXform({tag: 'dxfs', $: {count: 0}}),\n  tableStyles: new StaticXform({\n    tag: 'tableStyles',\n    $: {count: 0, defaultTableStyle: 'TableStyleMedium2', defaultPivotStyle: 'PivotStyleLight16'},\n  }),\n  extLst: new StaticXform({\n    tag: 'extLst',\n    c: [\n      {\n        tag: 'ext',\n        $: {\n          uri: '{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}',\n          'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',\n        },\n        c: [{tag: 'x14:slicerStyles', $: {defaultSlicerStyle: 'SlicerStyleLight1'}}],\n      },\n      {\n        tag: 'ext',\n        $: {\n          uri: '{9260A510-F301-46a8-8635-F512D64BE5F5}',\n          'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',\n        },\n        c: [{tag: 'x15:timelineStyles', $: {defaultTimelineStyle: 'TimeSlicerStyleLight1'}}],\n      },\n    ],\n  }),\n};\n\n// the stylemanager mock acts like StyleManager except that it always returns 0 or {}\nclass StylesXformMock extends StylesXform {\n  constructor() {\n    super();\n\n    this.model = {\n      styles: [{numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0}],\n      numFmts: [],\n      fonts: [{size: 11, color: {theme: 1}, name: 'Calibri', family: 2, scheme: 'minor'}],\n      borders: [{}],\n      fills: [\n        {type: 'pattern', pattern: 'none'},\n        {type: 'pattern', pattern: 'gray125'},\n      ],\n    };\n  }\n\n  // =========================================================================\n  // Style Manager Interface\n\n  // override normal behaviour - consume and dispose\n  parseStream(stream) {\n    stream.autodrain();\n    return Promise.resolve();\n  }\n\n  // add a cell's style model to the collection\n  // each style property is processed and cross-referenced, etc.\n  // the styleId is returned. Note: cellType is used when numFmt not defined\n  addStyleModel(model, cellType) {\n    switch (cellType) {\n      case Enums.ValueType.Date:\n        return this.dateStyleId;\n      default:\n        return 0;\n    }\n  }\n\n  get dateStyleId() {\n    if (!this._dateStyleId) {\n      const dateStyle = {\n        numFmtId: NumFmtXform.getDefaultFmtId('mm-dd-yy'),\n      };\n      this._dateStyleId = this.model.styles.length;\n      this.model.styles.push(dateStyle);\n    }\n    return this._dateStyleId;\n  }\n\n  // given a styleId (i.e. s=\"n\"), get the cell's style model\n  // objects are shared where possible.\n  getStyleModel(/* id */) {\n    return {};\n  }\n}\n\nStylesXform.Mock = StylesXformMock;\n\nmodule.exports = StylesXform;\n","const parseSax = require('../../utils/parse-sax');\nconst XmlStream = require('../../utils/xml-stream');\n\n/* 'virtual' methods used as a form of documentation */\n/* eslint-disable class-methods-use-this */\n\n// Base class for Xforms\nclass BaseXform {\n  // constructor(/* model, name */) {}\n\n  // ============================================================\n  // Virtual Interface\n  prepare(/* model, options */) {\n    // optional preparation (mutation) of model so it is ready for write\n  }\n\n  render(/* xmlStream, model */) {\n    // convert model to xml\n  }\n\n  parseOpen(node) {\n    // XML node opened\n  }\n\n  parseText(text) {\n    // chunk of text encountered for current node\n  }\n\n  parseClose(name) {\n    // XML node closed\n  }\n\n  reconcile(model, options) {\n    // optional post-parse step (opposite to prepare)\n  }\n\n  // ============================================================\n  reset() {\n    // to make sure parses don't bleed to next iteration\n    this.model = null;\n\n    // if we have a map - reset them too\n    if (this.map) {\n      Object.values(this.map).forEach(xform => {\n        if (xform instanceof BaseXform) {\n          xform.reset();\n        } else if (xform.xform) {\n          xform.xform.reset();\n        }\n      });\n    }\n  }\n\n  mergeModel(obj) {\n    // set obj's props to this.model\n    this.model = Object.assign(this.model || {}, obj);\n  }\n\n  async parse(saxParser) {\n    for await (const events of saxParser) {\n      for (const {eventType, value} of events) {\n        if (eventType === 'opentag') {\n          this.parseOpen(value);\n        } else if (eventType === 'text') {\n          this.parseText(value);\n        } else if (eventType === 'closetag') {\n          if (!this.parseClose(value.name)) {\n            return this.model;\n          }\n        }\n      }\n    }\n    return this.model;\n  }\n\n  async parseStream(stream) {\n    return this.parse(parseSax(stream));\n  }\n\n  get xml() {\n    // convenience function to get the xml of this.model\n    // useful for manager types that are built during the prepare phase\n    return this.toXml(this.model);\n  }\n\n  toXml(model) {\n    const xmlStream = new XmlStream();\n    this.render(xmlStream, model);\n    return xmlStream.xml;\n  }\n\n  // ============================================================\n  // Useful Utilities\n  static toAttribute(value, dflt, always = false) {\n    if (value === undefined) {\n      if (always) {\n        return dflt;\n      }\n    } else if (always || value !== dflt) {\n      return value.toString();\n    }\n    return undefined;\n  }\n\n  static toStringAttribute(value, dflt, always = false) {\n    return BaseXform.toAttribute(value, dflt, always);\n  }\n\n  static toStringValue(attr, dflt) {\n    return attr === undefined ? dflt : attr;\n  }\n\n  static toBoolAttribute(value, dflt, always = false) {\n    if (value === undefined) {\n      if (always) {\n        return dflt;\n      }\n    } else if (always || value !== dflt) {\n      return value ? '1' : '0';\n    }\n    return undefined;\n  }\n\n  static toBoolValue(attr, dflt) {\n    return attr === undefined ? dflt : attr === '1';\n  }\n\n  static toIntAttribute(value, dflt, always = false) {\n    return BaseXform.toAttribute(value, dflt, always);\n  }\n\n  static toIntValue(attr, dflt) {\n    return attr === undefined ? dflt : parseInt(attr, 10);\n  }\n\n  static toFloatAttribute(value, dflt, always = false) {\n    return BaseXform.toAttribute(value, dflt, always);\n  }\n\n  static toFloatValue(attr, dflt) {\n    return attr === undefined ? dflt : parseFloat(attr);\n  }\n}\n\nmodule.exports = BaseXform;\n","const {SaxesParser} = require('saxes');\nconst {PassThrough} = require('readable-stream');\nconst {bufferToString} = require('./browser-buffer-decode');\n\nmodule.exports = async function* (iterable) {\n  // TODO: Remove once node v8 is deprecated\n  // Detect and upgrade old streams\n  if (iterable.pipe && !iterable[Symbol.asyncIterator]) {\n    iterable = iterable.pipe(new PassThrough());\n  }\n  const saxesParser = new SaxesParser();\n  let error;\n  saxesParser.on('error', err => {\n    error = err;\n  });\n  let events = [];\n  saxesParser.on('opentag', value => events.push({eventType: 'opentag', value}));\n  saxesParser.on('text', value => events.push({eventType: 'text', value}));\n  saxesParser.on('closetag', value => events.push({eventType: 'closetag', value}));\n  for await (const chunk of iterable) {\n    saxesParser.write(bufferToString(chunk));\n    // saxesParser.write and saxesParser.on() are synchronous,\n    // so we can only reach the below line once all events have been emitted\n    if (error) throw error;\n    // As a performance optimization, we gather all events instead of passing\n    // them one by one, which would cause each event to go through the event queue\n    yield events;\n    events = [];\n  }\n};\n","const BaseXform = require('./base-xform');\nconst XmlStream = require('../../utils/xml-stream');\n\n// const model = {\n//   tag: 'name',\n//   $: {attr: 'value'},\n//   c: [\n//     { tag: 'child' }\n//   ],\n//   t: 'some text'\n// };\n\nfunction build(xmlStream, model) {\n  xmlStream.openNode(model.tag, model.$);\n  if (model.c) {\n    model.c.forEach(child => {\n      build(xmlStream, child);\n    });\n  }\n  if (model.t) {\n    xmlStream.writeText(model.t);\n  }\n  xmlStream.closeNode();\n}\n\nclass StaticXform extends BaseXform {\n  constructor(model) {\n    super();\n\n    // This class is an optimisation for static (unimportant and unchanging) xml\n    // It is stateless - apart from its static model and so can be used as a singleton\n    // Being stateless - it will only track entry to and exit from it's root xml tag during parsing and nothing else\n    // Known issues:\n    //    since stateless - parseOpen always returns true. Parent xform must know when to start using this xform\n    //    if the root tag is recursive, the parsing will behave unpredictably\n    this._model = model;\n  }\n\n  render(xmlStream) {\n    if (!this._xml) {\n      const stream = new XmlStream();\n      build(stream, this._model);\n      this._xml = stream.xml;\n    }\n    xmlStream.writeXml(this._xml);\n  }\n\n  parseOpen() {\n    return true;\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    switch (name) {\n      case this._model.tag:\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = StaticXform;\n","const BaseXform = require('./base-xform');\n\nclass ListXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.always = !!options.always;\n    this.count = options.count;\n    this.empty = options.empty;\n    this.$count = options.$count || 'count';\n    this.$ = options.$;\n    this.childXform = options.childXform;\n    this.maxItems = options.maxItems;\n  }\n\n  prepare(model, options) {\n    const {childXform} = this;\n    if (model) {\n      model.forEach((childModel, index) => {\n        options.index = index;\n        childXform.prepare(childModel, options);\n      });\n    }\n  }\n\n  render(xmlStream, model) {\n    if (this.always || (model && model.length)) {\n      xmlStream.openNode(this.tag, this.$);\n      if (this.count) {\n        xmlStream.addAttribute(this.$count, (model && model.length) || 0);\n      }\n\n      const {childXform} = this;\n      (model || []).forEach((childModel, index) => {\n        childXform.render(xmlStream, childModel, index);\n      });\n\n      xmlStream.closeNode();\n    } else if (this.empty) {\n      xmlStream.leafNode(this.tag);\n    }\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.model = [];\n        return true;\n      default:\n        if (this.childXform.parseOpen(node)) {\n          this.parser = this.childXform;\n          return true;\n        }\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.push(this.parser.model);\n        this.parser = undefined;\n\n        if (this.maxItems && this.model.length > this.maxItems) {\n          throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);\n        }\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  reconcile(model, options) {\n    if (model) {\n      const {childXform} = this;\n      model.forEach(childModel => {\n        childXform.reconcile(childModel, options);\n      });\n    }\n  }\n}\n\nmodule.exports = ListXform;\n","\n\nconst ColorXform = require('./color-xform');\nconst BooleanXform = require('../simple/boolean-xform');\nconst IntegerXform = require('../simple/integer-xform');\nconst StringXform = require('../simple/string-xform');\nconst UnderlineXform = require('./underline-xform');\n\nconst _ = require('../../../utils/under-dash');\nconst BaseXform = require('../base-xform');\n\n// Font encapsulates translation from font model to xlsx\nclass FontXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.options = options || FontXform.OPTIONS;\n\n    this.map = {\n      b: {prop: 'bold', xform: new BooleanXform({tag: 'b', attr: 'val'})},\n      i: {prop: 'italic', xform: new BooleanXform({tag: 'i', attr: 'val'})},\n      u: {prop: 'underline', xform: new UnderlineXform()},\n      charset: {prop: 'charset', xform: new IntegerXform({tag: 'charset', attr: 'val'})},\n      color: {prop: 'color', xform: new ColorXform()},\n      condense: {prop: 'condense', xform: new BooleanXform({tag: 'condense', attr: 'val'})},\n      extend: {prop: 'extend', xform: new BooleanXform({tag: 'extend', attr: 'val'})},\n      family: {prop: 'family', xform: new IntegerXform({tag: 'family', attr: 'val'})},\n      outline: {prop: 'outline', xform: new BooleanXform({tag: 'outline', attr: 'val'})},\n      vertAlign: {prop: 'vertAlign', xform: new StringXform({tag: 'vertAlign', attr: 'val'})},\n      scheme: {prop: 'scheme', xform: new StringXform({tag: 'scheme', attr: 'val'})},\n      shadow: {prop: 'shadow', xform: new BooleanXform({tag: 'shadow', attr: 'val'})},\n      strike: {prop: 'strike', xform: new BooleanXform({tag: 'strike', attr: 'val'})},\n      sz: {prop: 'size', xform: new IntegerXform({tag: 'sz', attr: 'val'})},\n    };\n    this.map[this.options.fontNameTag] = {\n      prop: 'name',\n      xform: new StringXform({tag: this.options.fontNameTag, attr: 'val'}),\n    };\n  }\n\n  get tag() {\n    return this.options.tagName;\n  }\n\n  render(xmlStream, model) {\n    const {map} = this;\n\n    xmlStream.openNode(this.options.tagName);\n    _.each(this.map, (defn, tag) => {\n      map[tag].xform.render(xmlStream, model[defn.prop]);\n    });\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    if (this.map[node.name]) {\n      this.parser = this.map[node.name].xform;\n      return this.parser.parseOpen(node);\n    }\n    switch (node.name) {\n      case this.options.tagName:\n        this.model = {};\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser && !this.parser.parseClose(name)) {\n      const item = this.map[name];\n      if (this.parser.model) {\n        this.model[item.prop] = this.parser.model;\n      }\n      this.parser = undefined;\n      return true;\n    }\n    switch (name) {\n      case this.options.tagName:\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nFontXform.OPTIONS = {\n  tagName: 'font',\n  fontNameTag: 'name',\n};\n\nmodule.exports = FontXform;\n","const BaseXform = require('../base-xform');\n\n// Color encapsulates translation from color model to/from xlsx\nclass ColorXform extends BaseXform {\n  constructor(name) {\n    super();\n\n    // this.name controls the xm node name\n    this.name = name || 'color';\n  }\n\n  get tag() {\n    return this.name;\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.openNode(this.name);\n      if (model.argb) {\n        xmlStream.addAttribute('rgb', model.argb);\n      } else if (model.theme !== undefined) {\n        xmlStream.addAttribute('theme', model.theme);\n        if (model.tint !== undefined) {\n          xmlStream.addAttribute('tint', model.tint);\n        }\n      } else if (model.indexed !== undefined) {\n        xmlStream.addAttribute('indexed', model.indexed);\n      } else {\n        xmlStream.addAttribute('auto', '1');\n      }\n      xmlStream.closeNode();\n      return true;\n    }\n    return false;\n  }\n\n  parseOpen(node) {\n    if (node.name === this.name) {\n      if (node.attributes.rgb) {\n        this.model = {argb: node.attributes.rgb};\n      } else if (node.attributes.theme) {\n        this.model = {theme: parseInt(node.attributes.theme, 10)};\n        if (node.attributes.tint) {\n          this.model.tint = parseFloat(node.attributes.tint);\n        }\n      } else if (node.attributes.indexed) {\n        this.model = {indexed: parseInt(node.attributes.indexed, 10)};\n      } else {\n        this.model = undefined;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = ColorXform;\n","const BaseXform = require('../base-xform');\n\nclass BooleanXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.attr = options.attr;\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.openNode(this.tag);\n      xmlStream.closeNode();\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      this.model = true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = BooleanXform;\n","const BaseXform = require('../base-xform');\n\nclass IntegerXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.attr = options.attr;\n    this.attrs = options.attrs;\n\n    // option to render zero\n    this.zero = options.zero;\n  }\n\n  render(xmlStream, model) {\n    // int is different to float in that zero is not rendered\n    if (model || this.zero) {\n      xmlStream.openNode(this.tag);\n      if (this.attrs) {\n        xmlStream.addAttributes(this.attrs);\n      }\n      if (this.attr) {\n        xmlStream.addAttribute(this.attr, model);\n      } else {\n        xmlStream.writeText(model);\n      }\n      xmlStream.closeNode();\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      if (this.attr) {\n        this.model = parseInt(node.attributes[this.attr], 10);\n      } else {\n        this.text = [];\n      }\n      return true;\n    }\n    return false;\n  }\n\n  parseText(text) {\n    if (!this.attr) {\n      this.text.push(text);\n    }\n  }\n\n  parseClose() {\n    if (!this.attr) {\n      this.model = parseInt(this.text.join('') || 0, 10);\n    }\n    return false;\n  }\n}\n\nmodule.exports = IntegerXform;\n","const BaseXform = require('../base-xform');\n\nclass StringXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.attr = options.attr;\n    this.attrs = options.attrs;\n  }\n\n  render(xmlStream, model) {\n    if (model !== undefined) {\n      xmlStream.openNode(this.tag);\n      if (this.attrs) {\n        xmlStream.addAttributes(this.attrs);\n      }\n      if (this.attr) {\n        xmlStream.addAttribute(this.attr, model);\n      } else {\n        xmlStream.writeText(model);\n      }\n      xmlStream.closeNode();\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      if (this.attr) {\n        this.model = node.attributes[this.attr];\n      } else {\n        this.text = [];\n      }\n    }\n  }\n\n  parseText(text) {\n    if (!this.attr) {\n      this.text.push(text);\n    }\n  }\n\n  parseClose() {\n    if (!this.attr) {\n      this.model = this.text.join('');\n    }\n    return false;\n  }\n}\n\nmodule.exports = StringXform;\n","const BaseXform = require('../base-xform');\n\nclass UnderlineXform extends BaseXform {\n  constructor(model) {\n    super();\n\n    this.model = model;\n  }\n\n  get tag() {\n    return 'u';\n  }\n\n  render(xmlStream, model) {\n    model = model || this.model;\n\n    if (model === true) {\n      xmlStream.leafNode('u');\n    } else {\n      const attr = UnderlineXform.Attributes[model];\n      if (attr) {\n        xmlStream.leafNode('u', attr);\n      }\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === 'u') {\n      this.model = node.attributes.val || true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nUnderlineXform.Attributes = {\n  single: {},\n  double: {val: 'double'},\n  singleAccounting: {val: 'singleAccounting'},\n  doubleAccounting: {val: 'doubleAccounting'},\n};\n\nmodule.exports = UnderlineXform;\n","/* eslint-disable max-classes-per-file */\nconst BaseXform = require('../base-xform');\n\nconst ColorXform = require('./color-xform');\n\nclass StopXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      color: new ColorXform(),\n    };\n  }\n\n  get tag() {\n    return 'stop';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('stop');\n    xmlStream.addAttribute('position', model.position);\n    this.map.color.render(xmlStream, model.color);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'stop':\n        this.model = {\n          position: parseFloat(node.attributes.position),\n        };\n        return true;\n      case 'color':\n        this.parser = this.map.color;\n        this.parser.parseOpen(node);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.color = this.parser.model;\n        this.parser = undefined;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nclass PatternFillXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      fgColor: new ColorXform('fgColor'),\n      bgColor: new ColorXform('bgColor'),\n    };\n  }\n\n  get name() {\n    return 'pattern';\n  }\n\n  get tag() {\n    return 'patternFill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('patternFill');\n    xmlStream.addAttribute('patternType', model.pattern);\n    if (model.fgColor) {\n      this.map.fgColor.render(xmlStream, model.fgColor);\n    }\n    if (model.bgColor) {\n      this.map.bgColor.render(xmlStream, model.bgColor);\n    }\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'patternFill':\n        this.model = {\n          type: 'pattern',\n          pattern: node.attributes.patternType,\n        };\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        if (this.parser.model) {\n          this.model[name] = this.parser.model;\n        }\n        this.parser = undefined;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nclass GradientFillXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      stop: new StopXform(),\n    };\n    // if (model) {\n    //   this.gradient = model.gradient;\n    //   if (model.center) {\n    //     this.center = model.center;\n    //   }\n    //   if (model.degree !== undefined) {\n    //     this.degree = model.degree;\n    //   }\n    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });\n    // } else {\n    //   this.stops = [];\n    // }\n  }\n\n  get name() {\n    return 'gradient';\n  }\n\n  get tag() {\n    return 'gradientFill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('gradientFill');\n    switch (model.gradient) {\n      case 'angle':\n        xmlStream.addAttribute('degree', model.degree);\n        break;\n      case 'path':\n        xmlStream.addAttribute('type', 'path');\n        if (model.center.left) {\n          xmlStream.addAttribute('left', model.center.left);\n          if (model.center.right === undefined) {\n            xmlStream.addAttribute('right', model.center.left);\n          }\n        }\n        if (model.center.right) {\n          xmlStream.addAttribute('right', model.center.right);\n        }\n        if (model.center.top) {\n          xmlStream.addAttribute('top', model.center.top);\n          if (model.center.bottom === undefined) {\n            xmlStream.addAttribute('bottom', model.center.top);\n          }\n        }\n        if (model.center.bottom) {\n          xmlStream.addAttribute('bottom', model.center.bottom);\n        }\n        break;\n\n      default:\n        break;\n    }\n\n    const stopXform = this.map.stop;\n    model.stops.forEach(stopModel => {\n      stopXform.render(xmlStream, stopModel);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'gradientFill': {\n        const model = (this.model = {\n          stops: [],\n        });\n        if (node.attributes.degree) {\n          model.gradient = 'angle';\n          model.degree = parseInt(node.attributes.degree, 10);\n        } else if (node.attributes.type === 'path') {\n          model.gradient = 'path';\n          model.center = {\n            left: node.attributes.left ? parseFloat(node.attributes.left) : 0,\n            top: node.attributes.top ? parseFloat(node.attributes.top) : 0,\n          };\n          if (node.attributes.right !== node.attributes.left) {\n            model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;\n          }\n          if (node.attributes.bottom !== node.attributes.top) {\n            model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;\n          }\n        }\n        return true;\n      }\n\n      case 'stop':\n        this.parser = this.map.stop;\n        this.parser.parseOpen(node);\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.stops.push(this.parser.model);\n        this.parser = undefined;\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\n// Fill encapsulates translation from fill model to/from xlsx\nclass FillXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      patternFill: new PatternFillXform(),\n      gradientFill: new GradientFillXform(),\n    };\n  }\n\n  get tag() {\n    return 'fill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.addRollback();\n    xmlStream.openNode('fill');\n    switch (model.type) {\n      case 'pattern':\n        this.map.patternFill.render(xmlStream, model);\n        break;\n      case 'gradient':\n        this.map.gradientFill.render(xmlStream, model);\n        break;\n      default:\n        xmlStream.rollback();\n        return;\n    }\n    xmlStream.closeNode();\n    xmlStream.commit();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'fill':\n        this.model = {};\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model = this.parser.model;\n        this.model.type = this.parser.name;\n        this.parser = undefined;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  validStyle(value) {\n    return FillXform.validPatternValues[value];\n  }\n}\n\nFillXform.validPatternValues = [\n  'none',\n  'solid',\n  'darkVertical',\n  'darkGray',\n  'mediumGray',\n  'lightGray',\n  'gray125',\n  'gray0625',\n  'darkHorizontal',\n  'darkVertical',\n  'darkDown',\n  'darkUp',\n  'darkGrid',\n  'darkTrellis',\n  'lightHorizontal',\n  'lightVertical',\n  'lightDown',\n  'lightUp',\n  'lightGrid',\n  'lightTrellis',\n  'lightGrid',\n].reduce((p, v) => {\n  p[v] = true;\n  return p;\n}, {});\n\nFillXform.StopXform = StopXform;\nFillXform.PatternFillXform = PatternFillXform;\nFillXform.GradientFillXform = GradientFillXform;\n\nmodule.exports = FillXform;\n","/* eslint-disable max-classes-per-file */\nconst BaseXform = require('../base-xform');\nconst utils = require('../../../utils/utils');\n\nconst ColorXform = require('./color-xform');\n\nclass EdgeXform extends BaseXform {\n  constructor(name) {\n    super();\n\n    this.name = name;\n    this.map = {\n      color: new ColorXform(),\n    };\n  }\n\n  get tag() {\n    return this.name;\n  }\n\n  render(xmlStream, model, defaultColor) {\n    const color = (model && model.color) || defaultColor || this.defaultColor;\n    xmlStream.openNode(this.name);\n    if (model && model.style) {\n      xmlStream.addAttribute('style', model.style);\n      if (color) {\n        this.map.color.render(xmlStream, color);\n      }\n    }\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.name: {\n        const {style} = node.attributes;\n        if (style) {\n          this.model = {\n            style,\n          };\n        } else {\n          this.model = undefined;\n        }\n        return true;\n      }\n      case 'color':\n        this.parser = this.map.color;\n        this.parser.parseOpen(node);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n\n    if (name === this.name) {\n      if (this.map.color.model) {\n        if (!this.model) {\n          this.model = {};\n        }\n        this.model.color = this.map.color.model;\n      }\n    }\n\n    return false;\n  }\n\n  validStyle(value) {\n    return EdgeXform.validStyleValues[value];\n  }\n}\n\nEdgeXform.validStyleValues = [\n  'thin',\n  'dashed',\n  'dotted',\n  'dashDot',\n  'hair',\n  'dashDotDot',\n  'slantDashDot',\n  'mediumDashed',\n  'mediumDashDotDot',\n  'mediumDashDot',\n  'medium',\n  'double',\n  'thick',\n].reduce((p, v) => {\n  p[v] = true;\n  return p;\n}, {});\n\n// Border encapsulates translation from border model to/from xlsx\nclass BorderXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      top: new EdgeXform('top'),\n      left: new EdgeXform('left'),\n      bottom: new EdgeXform('bottom'),\n      right: new EdgeXform('right'),\n      diagonal: new EdgeXform('diagonal'),\n    };\n  }\n\n  render(xmlStream, model) {\n    const {color} = model;\n    xmlStream.openNode('border');\n    if (model.diagonal && model.diagonal.style) {\n      if (model.diagonal.up) {\n        xmlStream.addAttribute('diagonalUp', '1');\n      }\n      if (model.diagonal.down) {\n        xmlStream.addAttribute('diagonalDown', '1');\n      }\n    }\n    function add(edgeModel, edgeXform) {\n      if (edgeModel && !edgeModel.color && model.color) {\n        // don't mess with incoming models\n        edgeModel = {\n          ...edgeModel,\n          color: model.color,\n        };\n      }\n      edgeXform.render(xmlStream, edgeModel, color);\n    }\n    add(model.left, this.map.left);\n    add(model.right, this.map.right);\n    add(model.top, this.map.top);\n    add(model.bottom, this.map.bottom);\n    add(model.diagonal, this.map.diagonal);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'border':\n        this.reset();\n        this.diagonalUp = utils.parseBoolean(node.attributes.diagonalUp);\n        this.diagonalDown = utils.parseBoolean(node.attributes.diagonalDown);\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    if (name === 'border') {\n      const model = (this.model = {});\n      const add = function(key, edgeModel, extensions) {\n        if (edgeModel) {\n          if (extensions) {\n            Object.assign(edgeModel, extensions);\n          }\n          model[key] = edgeModel;\n        }\n      };\n      add('left', this.map.left.model);\n      add('right', this.map.right.model);\n      add('top', this.map.top.model);\n      add('bottom', this.map.bottom.model);\n      add('diagonal', this.map.diagonal.model, {up: this.diagonalUp, down: this.diagonalDown});\n    }\n    return false;\n  }\n}\n\nmodule.exports = BorderXform;\n","const _ = require('../../../utils/under-dash');\nconst defaultNumFormats = require('../../defaultnumformats');\n\nconst BaseXform = require('../base-xform');\n\nfunction hashDefaultFormats() {\n  const hash = {};\n  _.each(defaultNumFormats, (dnf, id) => {\n    if (dnf.f) {\n      hash[dnf.f] = parseInt(id, 10);\n    }\n    // at some point, add the other cultures here...\n  });\n  return hash;\n}\nconst defaultFmtHash = hashDefaultFormats();\n\n// NumFmt encapsulates translation between number format and xlsx\nclass NumFmtXform extends BaseXform {\n  constructor(id, formatCode) {\n    super();\n\n    this.id = id;\n    this.formatCode = formatCode;\n  }\n\n  get tag() {\n    return 'numFmt';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode('numFmt', {numFmtId: model.id, formatCode: model.formatCode});\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'numFmt':\n        this.model = {\n          id: parseInt(node.attributes.numFmtId, 10),\n          formatCode: node.attributes.formatCode.replace(/[\\\\](.)/g, '$1'),\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nNumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {\n  return defaultFmtHash[formatCode];\n};\n\nNumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {\n  return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;\n};\n\nmodule.exports = NumFmtXform;\n","module.exports = {\n  0: {f: 'General'},\n  1: {f: '0'},\n  2: {f: '0.00'},\n  3: {f: '#,##0'},\n  4: {f: '#,##0.00'},\n  9: {f: '0%'},\n  10: {f: '0.00%'},\n  11: {f: '0.00E+00'},\n  12: {f: '# ?/?'},\n  13: {f: '# ??/??'},\n  14: {f: 'mm-dd-yy'},\n  15: {f: 'd-mmm-yy'},\n  16: {f: 'd-mmm'},\n  17: {f: 'mmm-yy'},\n  18: {f: 'h:mm AM/PM'},\n  19: {f: 'h:mm:ss AM/PM'},\n  20: {f: 'h:mm'},\n  21: {f: 'h:mm:ss'},\n  22: {f: 'm/d/yy \"h\":mm'},\n\n  27: {\n    'zh-tw': '[$-404]e/m/d',\n    'zh-cn': 'yyyy\"\"m\"\"',\n    'ja-jp': '[$-411]ge.m.d',\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\n  },\n  28: {\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\n    'zh-cn': 'm\"\"d\"\"',\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\n    'ko-kr': 'mm-dd',\n  },\n  29: {\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\n    'zh-cn': 'm\"\"d\"\"',\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\n    'ko-kr': 'mm-dd',\n  },\n  30: {'zh-tw': 'm/d/yy ', 'zh-cn': 'm-d-yy', 'ja-jp': 'm/d/yy', 'ko-kr': 'mm-dd-yy'},\n  31: {\n    'zh-tw': 'yyyy\"\"m\"\"d\"\"',\n    'zh-cn': 'yyyy\"\"m\"\"d\"\"',\n    'ja-jp': 'yyyy\"\"m\"\"d\"\"',\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\n  },\n  32: {\n    'zh-tw': 'hh\"\"mm\"\"',\n    'zh-cn': 'h\"\"mm\"\"',\n    'ja-jp': 'h\"\"mm\"\"',\n    'ko-kr': 'h\"\" mm\"\"',\n  },\n  33: {\n    'zh-tw': 'hh\"\"mm\"\"ss\"\"',\n    'zh-cn': 'h\"\"mm\"\"ss\"\"',\n    'ja-jp': 'h\"\"mm\"\"ss\"\"',\n    'ko-kr': 'h\"\" mm\"\" ss\"\"',\n  },\n  34: {\n    'zh-tw': '/ hh\"\"mm\"\"',\n    'zh-cn': '/ h\"\"mm\"\"',\n    'ja-jp': 'yyyy\"\"m\"\"',\n    'ko-kr': 'yyyy-mm-dd',\n  },\n  35: {\n    'zh-tw': '/ hh\"\"mm\"\"ss\"\"',\n    'zh-cn': '/ h\"\"mm\"\"ss\"\"',\n    'ja-jp': 'm\"\"d\"\"',\n    'ko-kr': 'yyyy-mm-dd',\n  },\n  36: {\n    'zh-tw': '[$-404]e/m/d',\n    'zh-cn': 'yyyy\"\"m\"\"',\n    'ja-jp': '[$-411]ge.m.d',\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\n  },\n\n  37: {f: '#,##0 ;(#,##0)'},\n  38: {f: '#,##0 ;[Red](#,##0)'},\n  39: {f: '#,##0.00 ;(#,##0.00)'},\n  40: {f: '#,##0.00 ;[Red](#,##0.00)'},\n  45: {f: 'mm:ss'},\n  46: {f: '[h]:mm:ss'},\n  47: {f: 'mmss.0'},\n  48: {f: '##0.0E+0'},\n  49: {f: '@'},\n\n  50: {\n    'zh-tw': '[$-404]e/m/d',\n    'zh-cn': 'yyyy\"\"m\"\"',\n    'ja-jp': '[$-411]ge.m.d',\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\n  },\n  51: {\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\n    'zh-cn': 'm\"\"d\"\"',\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\n    'ko-kr': 'mm-dd',\n  },\n  52: {\n    'zh-tw': '/ hh\"\"mm\"\"',\n    'zh-cn': 'yyyy\"\"m\"\"',\n    'ja-jp': 'yyyy\"\"m\"\"',\n    'ko-kr': 'yyyy-mm-dd',\n  },\n  53: {\n    'zh-tw': '/ hh\"\"mm\"\"ss\"\"',\n    'zh-cn': 'm\"\"d\"\"',\n    'ja-jp': 'm\"\"d\"\"',\n    'ko-kr': 'yyyy-mm-dd',\n  },\n  54: {\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\n    'zh-cn': 'm\"\"d\"\"',\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\n    'ko-kr': 'mm-dd',\n  },\n  55: {\n    'zh-tw': '/ hh\"\"mm\"\"',\n    'zh-cn': '/ h\"\"mm\"\"',\n    'ja-jp': 'yyyy\"\"m\"\"',\n    'ko-kr': 'yyyy-mm-dd',\n  },\n  56: {\n    'zh-tw': '/ hh\"\"mm\"\"ss\"\"',\n    'zh-cn': '/ h\"\"mm\"\"ss\"\"',\n    'ja-jp': 'm\"\"d\"\"',\n    'ko-kr': 'yyyy-mm-dd',\n  },\n  57: {\n    'zh-tw': '[$-404]e/m/d',\n    'zh-cn': 'yyyy\"\"m\"\"',\n    'ja-jp': '[$-411]ge.m.d',\n    'ko-kr': 'yyyy\"\" mm\"\" dd\"\"',\n  },\n  58: {\n    'zh-tw': '[$-404]e\"\"m\"\"d\"\"',\n    'zh-cn': 'm\"\"d\"\"',\n    'ja-jp': '[$-411]ggge\"\"m\"\"d\"\"',\n    'ko-kr': 'mm-dd',\n  },\n\n  59: {'th-th': 't0'},\n  60: {'th-th': 't0.00'},\n  61: {'th-th': 't#,##0'},\n  62: {'th-th': 't#,##0.00'},\n  67: {'th-th': 't0%'},\n  68: {'th-th': 't0.00%'},\n  69: {'th-th': 't# ?/?'},\n  70: {'th-th': 't# ??/??'},\n\n  81: {'th-th': 'd/m/bb'},\n};\n","const BaseXform = require('../base-xform');\n\nconst AlignmentXform = require('./alignment-xform');\nconst ProtectionXform = require('./protection-xform');\n\n// <xf numFmtId=\"[numFmtId]\" fontId=\"[fontId]\" fillId=\"[fillId]\" borderId=\"[xf.borderId]\" xfId=\"[xfId]\">\n//   Optional <alignment>\n//   Optional <protection>\n// </xf>\n\n// Style assists translation from style model to/from xlsx\nclass StyleXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.xfId = !!(options && options.xfId);\n    this.map = {\n      alignment: new AlignmentXform(),\n      protection: new ProtectionXform(),\n    };\n  }\n\n  get tag() {\n    return 'xf';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('xf', {\n      numFmtId: model.numFmtId || 0,\n      fontId: model.fontId || 0,\n      fillId: model.fillId || 0,\n      borderId: model.borderId || 0,\n    });\n    if (this.xfId) {\n      xmlStream.addAttribute('xfId', model.xfId || 0);\n    }\n\n    if (model.numFmtId) {\n      xmlStream.addAttribute('applyNumberFormat', '1');\n    }\n    if (model.fontId) {\n      xmlStream.addAttribute('applyFont', '1');\n    }\n    if (model.fillId) {\n      xmlStream.addAttribute('applyFill', '1');\n    }\n    if (model.borderId) {\n      xmlStream.addAttribute('applyBorder', '1');\n    }\n    if (model.alignment) {\n      xmlStream.addAttribute('applyAlignment', '1');\n    }\n    if (model.protection) {\n      xmlStream.addAttribute('applyProtection', '1');\n    }\n\n    /**\n     * Rendering tags causes close of XML stream.\n     * Therefore adding attributes must be done before rendering tags.\n     */\n\n    if (model.alignment) {\n      this.map.alignment.render(xmlStream, model.alignment);\n    }\n    if (model.protection) {\n      this.map.protection.render(xmlStream, model.protection);\n    }\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    // used during sax parsing of xml to build font object\n    switch (node.name) {\n      case 'xf':\n        this.model = {\n          numFmtId: parseInt(node.attributes.numFmtId, 10),\n          fontId: parseInt(node.attributes.fontId, 10),\n          fillId: parseInt(node.attributes.fillId, 10),\n          borderId: parseInt(node.attributes.borderId, 10),\n        };\n        if (this.xfId) {\n          this.model.xfId = parseInt(node.attributes.xfId, 10);\n        }\n        return true;\n      case 'alignment':\n        this.parser = this.map.alignment;\n        this.parser.parseOpen(node);\n        return true;\n      case 'protection':\n        this.parser = this.map.protection;\n        this.parser.parseOpen(node);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        if (this.map.protection === this.parser) {\n          this.model.protection = this.parser.model;\n        } else {\n          this.model.alignment = this.parser.model;\n        }\n        this.parser = undefined;\n      }\n      return true;\n    }\n    return name !== 'xf';\n  }\n}\n\nmodule.exports = StyleXform;\n","const Enums = require('../../../doc/enums');\n\nconst utils = require('../../../utils/utils');\nconst BaseXform = require('../base-xform');\n\nconst validation = {\n  horizontalValues: [\n    'left',\n    'center',\n    'right',\n    'fill',\n    'centerContinuous',\n    'distributed',\n    'justify',\n  ].reduce((p, v) => {\n    p[v] = true;\n    return p;\n  }, {}),\n  horizontal(value) {\n    return this.horizontalValues[value] ? value : undefined;\n  },\n\n  verticalValues: ['top', 'middle', 'bottom', 'distributed', 'justify'].reduce((p, v) => {\n    p[v] = true;\n    return p;\n  }, {}),\n  vertical(value) {\n    if (value === 'middle') return 'center';\n    return this.verticalValues[value] ? value : undefined;\n  },\n  wrapText(value) {\n    return value ? true : undefined;\n  },\n  shrinkToFit(value) {\n    return value ? true : undefined;\n  },\n  textRotation(value) {\n    switch (value) {\n      case 'vertical':\n        return value;\n      default:\n        value = utils.validInt(value);\n        return value >= -90 && value <= 90 ? value : undefined;\n    }\n  },\n  indent(value) {\n    value = utils.validInt(value);\n    return Math.max(0, value);\n  },\n  readingOrder(value) {\n    switch (value) {\n      case 'ltr':\n        return Enums.ReadingOrder.LeftToRight;\n      case 'rtl':\n        return Enums.ReadingOrder.RightToLeft;\n      default:\n        return undefined;\n    }\n  },\n};\n\nconst textRotationXform = {\n  toXml(textRotation) {\n    textRotation = validation.textRotation(textRotation);\n    if (textRotation) {\n      if (textRotation === 'vertical') {\n        return 255;\n      }\n\n      const tr = Math.round(textRotation);\n      if (tr >= 0 && tr <= 90) {\n        return tr;\n      }\n\n      if (tr < 0 && tr >= -90) {\n        return 90 - tr;\n      }\n    }\n    return undefined;\n  },\n  toModel(textRotation) {\n    const tr = utils.validInt(textRotation);\n    if (tr !== undefined) {\n      if (tr === 255) {\n        return 'vertical';\n      }\n      if (tr >= 0 && tr <= 90) {\n        return tr;\n      }\n      if (tr > 90 && tr <= 180) {\n        return 90 - tr;\n      }\n    }\n    return undefined;\n  },\n};\n\n// Alignment encapsulates translation from style.alignment model to/from xlsx\nclass AlignmentXform extends BaseXform {\n  get tag() {\n    return 'alignment';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.addRollback();\n    xmlStream.openNode('alignment');\n\n    let isValid = false;\n    function add(name, value) {\n      if (value) {\n        xmlStream.addAttribute(name, value);\n        isValid = true;\n      }\n    }\n    add('horizontal', validation.horizontal(model.horizontal));\n    add('vertical', validation.vertical(model.vertical));\n    add('wrapText', validation.wrapText(model.wrapText) ? '1' : false);\n    add('shrinkToFit', validation.shrinkToFit(model.shrinkToFit) ? '1' : false);\n    add('indent', validation.indent(model.indent));\n    add('textRotation', textRotationXform.toXml(model.textRotation));\n    add('readingOrder', validation.readingOrder(model.readingOrder));\n\n    xmlStream.closeNode();\n\n    if (isValid) {\n      xmlStream.commit();\n    } else {\n      xmlStream.rollback();\n    }\n  }\n\n  parseOpen(node) {\n    const model = {};\n\n    let valid = false;\n    function add(truthy, name, value) {\n      if (truthy) {\n        model[name] = value;\n        valid = true;\n      }\n    }\n    add(node.attributes.horizontal, 'horizontal', node.attributes.horizontal);\n    add(\n      node.attributes.vertical,\n      'vertical',\n      node.attributes.vertical === 'center' ? 'middle' : node.attributes.vertical\n    );\n    add(node.attributes.wrapText, 'wrapText', utils.parseBoolean(node.attributes.wrapText));\n    add(node.attributes.shrinkToFit, 'shrinkToFit', utils.parseBoolean(node.attributes.shrinkToFit));\n    add(node.attributes.indent, 'indent', parseInt(node.attributes.indent, 10));\n    add(\n      node.attributes.textRotation,\n      'textRotation',\n      textRotationXform.toModel(node.attributes.textRotation)\n    );\n    add(\n      node.attributes.readingOrder,\n      'readingOrder',\n      node.attributes.readingOrder === '2' ? 'rtl' : 'ltr'\n    );\n\n    this.model = valid ? model : null;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = AlignmentXform;\n","const BaseXform = require('../base-xform');\n\nconst validation = {\n  boolean(value, dflt) {\n    if (value === undefined) {\n      return dflt;\n    }\n    return value;\n  },\n};\n\n// Protection encapsulates translation from style.protection model to/from xlsx\nclass ProtectionXform extends BaseXform {\n  get tag() {\n    return 'protection';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.addRollback();\n    xmlStream.openNode('protection');\n\n    let isValid = false;\n    function add(name, value) {\n      if (value !== undefined) {\n        xmlStream.addAttribute(name, value);\n        isValid = true;\n      }\n    }\n    add('locked', validation.boolean(model.locked, true) ? undefined : '0');\n    add('hidden', validation.boolean(model.hidden, false) ? '1' : undefined);\n\n    xmlStream.closeNode();\n\n    if (isValid) {\n      xmlStream.commit();\n    } else {\n      xmlStream.rollback();\n    }\n  }\n\n  parseOpen(node) {\n    const model = {\n      locked: !(node.attributes.locked === '0'),\n      hidden: node.attributes.hidden === '1',\n    };\n\n    // only want to record models that differ from defaults\n    const isSignificant = !model.locked || model.hidden;\n\n    this.model = isSignificant ? model : null;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = ProtectionXform;\n","const BaseXform = require('../base-xform');\n\nconst AlignmentXform = require('./alignment-xform');\nconst BorderXform = require('./border-xform');\nconst FillXform = require('./fill-xform');\nconst FontXform = require('./font-xform');\nconst NumFmtXform = require('./numfmt-xform');\nconst ProtectionXform = require('./protection-xform');\n\n// <xf numFmtId=\"[numFmtId]\" fontId=\"[fontId]\" fillId=\"[fillId]\" borderId=\"[xf.borderId]\" xfId=\"[xfId]\">\n//   Optional <alignment>\n//   Optional <protection>\n// </xf>\n\n// Style assists translation from style model to/from xlsx\nclass DxfXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      alignment: new AlignmentXform(),\n      border: new BorderXform(),\n      fill: new FillXform(),\n      font: new FontXform(),\n      numFmt: new NumFmtXform(),\n      protection: new ProtectionXform(),\n    };\n  }\n\n  get tag() {\n    return 'dxf';\n  }\n\n  // how do we generate dxfid?\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    if (model.font) {\n      this.map.font.render(xmlStream, model.font);\n    }\n    if (model.numFmt && model.numFmtId) {\n      const numFmtModel = {id: model.numFmtId, formatCode: model.numFmt};\n      this.map.numFmt.render(xmlStream, numFmtModel);\n    }\n    if (model.fill) {\n      this.map.fill.render(xmlStream, model.fill);\n    }\n    if (model.alignment) {\n      this.map.alignment.render(xmlStream, model.alignment);\n    }\n    if (model.border) {\n      this.map.border.render(xmlStream, model.border);\n    }\n    if (model.protection) {\n      this.map.protection.render(xmlStream, model.protection);\n    }\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case this.tag:\n        // this node is often repeated. Need to reset children\n        this.reset();\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        return true;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    if (name === this.tag) {\n      this.model = {\n        alignment: this.map.alignment.model,\n        border: this.map.border.model,\n        fill: this.map.fill.model,\n        font: this.map.font.model,\n        numFmt: this.map.numFmt.model,\n        protection: this.map.protection.model,\n      };\n      return false;\n    }\n\n    return true;\n  }\n}\n\nmodule.exports = DxfXform;\n","const XmlStream = require('../../../utils/xml-stream');\nconst BaseXform = require('../base-xform');\nconst DateXform = require('../simple/date-xform');\nconst StringXform = require('../simple/string-xform');\nconst IntegerXform = require('../simple/integer-xform');\n\nclass CoreXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'dc:creator': new StringXform({tag: 'dc:creator'}),\n      'dc:title': new StringXform({tag: 'dc:title'}),\n      'dc:subject': new StringXform({tag: 'dc:subject'}),\n      'dc:description': new StringXform({tag: 'dc:description'}),\n      'dc:identifier': new StringXform({tag: 'dc:identifier'}),\n      'dc:language': new StringXform({tag: 'dc:language'}),\n      'cp:keywords': new StringXform({tag: 'cp:keywords'}),\n      'cp:category': new StringXform({tag: 'cp:category'}),\n      'cp:lastModifiedBy': new StringXform({tag: 'cp:lastModifiedBy'}),\n      'cp:lastPrinted': new DateXform({tag: 'cp:lastPrinted', format: CoreXform.DateFormat}),\n      'cp:revision': new IntegerXform({tag: 'cp:revision'}),\n      'cp:version': new StringXform({tag: 'cp:version'}),\n      'cp:contentStatus': new StringXform({tag: 'cp:contentStatus'}),\n      'cp:contentType': new StringXform({tag: 'cp:contentType'}),\n      'dcterms:created': new DateXform({\n        tag: 'dcterms:created',\n        attrs: CoreXform.DateAttrs,\n        format: CoreXform.DateFormat,\n      }),\n      'dcterms:modified': new DateXform({\n        tag: 'dcterms:modified',\n        attrs: CoreXform.DateAttrs,\n        format: CoreXform.DateFormat,\n      }),\n    };\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n\n    xmlStream.openNode('cp:coreProperties', CoreXform.CORE_PROPERTY_ATTRIBUTES);\n\n    this.map['dc:creator'].render(xmlStream, model.creator);\n    this.map['dc:title'].render(xmlStream, model.title);\n    this.map['dc:subject'].render(xmlStream, model.subject);\n    this.map['dc:description'].render(xmlStream, model.description);\n    this.map['dc:identifier'].render(xmlStream, model.identifier);\n    this.map['dc:language'].render(xmlStream, model.language);\n    this.map['cp:keywords'].render(xmlStream, model.keywords);\n    this.map['cp:category'].render(xmlStream, model.category);\n    this.map['cp:lastModifiedBy'].render(xmlStream, model.lastModifiedBy);\n    this.map['cp:lastPrinted'].render(xmlStream, model.lastPrinted);\n    this.map['cp:revision'].render(xmlStream, model.revision);\n    this.map['cp:version'].render(xmlStream, model.version);\n    this.map['cp:contentStatus'].render(xmlStream, model.contentStatus);\n    this.map['cp:contentType'].render(xmlStream, model.contentType);\n    this.map['dcterms:created'].render(xmlStream, model.created);\n    this.map['dcterms:modified'].render(xmlStream, model.modified);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'cp:coreProperties':\n      case 'coreProperties':\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'cp:coreProperties':\n      case 'coreProperties':\n        this.model = {\n          creator: this.map['dc:creator'].model,\n          title: this.map['dc:title'].model,\n          subject: this.map['dc:subject'].model,\n          description: this.map['dc:description'].model,\n          identifier: this.map['dc:identifier'].model,\n          language: this.map['dc:language'].model,\n          keywords: this.map['cp:keywords'].model,\n          category: this.map['cp:category'].model,\n          lastModifiedBy: this.map['cp:lastModifiedBy'].model,\n          lastPrinted: this.map['cp:lastPrinted'].model,\n          revision: this.map['cp:revision'].model,\n          contentStatus: this.map['cp:contentStatus'].model,\n          contentType: this.map['cp:contentType'].model,\n          created: this.map['dcterms:created'].model,\n          modified: this.map['dcterms:modified'].model,\n        };\n        return false;\n      default:\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\n    }\n  }\n}\n\nCoreXform.DateFormat = function(dt) {\n  return dt.toISOString().replace(/[.]\\d{3}/, '');\n};\nCoreXform.DateAttrs = {'xsi:type': 'dcterms:W3CDTF'};\n\nCoreXform.CORE_PROPERTY_ATTRIBUTES = {\n  'xmlns:cp': 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',\n  'xmlns:dc': 'http://purl.org/dc/elements/1.1/',\n  'xmlns:dcterms': 'http://purl.org/dc/terms/',\n  'xmlns:dcmitype': 'http://purl.org/dc/dcmitype/',\n  'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n};\n\nmodule.exports = CoreXform;\n","const BaseXform = require('../base-xform');\n\nclass DateXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.attr = options.attr;\n    this.attrs = options.attrs;\n    this._format =\n      options.format ||\n      function(dt) {\n        try {\n          if (Number.isNaN(dt.getTime())) return '';\n          return dt.toISOString();\n        } catch (e) {\n          return '';\n        }\n      };\n    this._parse =\n      options.parse ||\n      function(str) {\n        return new Date(str);\n      };\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.openNode(this.tag);\n      if (this.attrs) {\n        xmlStream.addAttributes(this.attrs);\n      }\n      if (this.attr) {\n        xmlStream.addAttribute(this.attr, this._format(model));\n      } else {\n        xmlStream.writeText(this._format(model));\n      }\n      xmlStream.closeNode();\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      if (this.attr) {\n        this.model = this._parse(node.attributes[this.attr]);\n      } else {\n        this.text = [];\n      }\n    }\n  }\n\n  parseText(text) {\n    if (!this.attr) {\n      this.text.push(text);\n    }\n  }\n\n  parseClose() {\n    if (!this.attr) {\n      this.model = this._parse(this.text.join(''));\n    }\n    return false;\n  }\n}\n\nmodule.exports = DateXform;\n","const XmlStream = require('../../../utils/xml-stream');\nconst BaseXform = require('../base-xform');\nconst SharedStringXform = require('./shared-string-xform');\n\nclass SharedStringsXform extends BaseXform {\n  constructor(model) {\n    super();\n\n    this.model = model || {\n      values: [],\n      count: 0,\n    };\n    this.hash = Object.create(null);\n    this.rich = Object.create(null);\n  }\n\n  get sharedStringXform() {\n    return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());\n  }\n\n  get values() {\n    return this.model.values;\n  }\n\n  get uniqueCount() {\n    return this.model.values.length;\n  }\n\n  get count() {\n    return this.model.count;\n  }\n\n  getString(index) {\n    return this.model.values[index];\n  }\n\n  add(value) {\n    return value.richText ? this.addRichText(value) : this.addText(value);\n  }\n\n  addText(value) {\n    let index = this.hash[value];\n    if (index === undefined) {\n      index = this.hash[value] = this.model.values.length;\n      this.model.values.push(value);\n    }\n    this.model.count++;\n    return index;\n  }\n\n  addRichText(value) {\n    // TODO: add WeakMap here\n    const xml = this.sharedStringXform.toXml(value);\n    let index = this.rich[xml];\n    if (index === undefined) {\n      index = this.rich[xml] = this.model.values.length;\n      this.model.values.push(value);\n    }\n    this.model.count++;\n    return index;\n  }\n\n  // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n  // <sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"<%=totalRefs%>\" uniqueCount=\"<%=count%>\">\n  //   <si><t><%=text%></t></si>\n  //   <si><r><rPr></rPr><t></t></r></si>\n  // </sst>\n\n  render(xmlStream, model) {\n    model = model || this._values;\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n\n    xmlStream.openNode('sst', {\n      xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n      count: model.count,\n      uniqueCount: model.values.length,\n    });\n\n    const sx = this.sharedStringXform;\n    model.values.forEach(sharedString => {\n      sx.render(xmlStream, sharedString);\n    });\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'sst':\n        return true;\n      case 'si':\n        this.parser = this.sharedStringXform;\n        this.parser.parseOpen(node);\n        return true;\n      default:\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.values.push(this.parser.model);\n        this.model.count++;\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'sst':\n        return false;\n      default:\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\n    }\n  }\n}\n\nmodule.exports = SharedStringsXform;\n","const TextXform = require('./text-xform');\nconst RichTextXform = require('./rich-text-xform');\nconst PhoneticTextXform = require('./phonetic-text-xform');\n\nconst BaseXform = require('../base-xform');\n\n// <si>\n//   <r></r><r></r>...\n// </si>\n// <si>\n//   <t></t>\n// </si>\n\nclass SharedStringXform extends BaseXform {\n  constructor(model) {\n    super();\n\n    this.model = model;\n\n    this.map = {\n      r: new RichTextXform(),\n      t: new TextXform(),\n      rPh: new PhoneticTextXform(),\n    };\n  }\n\n  get tag() {\n    return 'si';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n    if (model && model.hasOwnProperty('richText') && model.richText) {\n      if (model.richText.length) {\n        model.richText.forEach(text => {\n          this.map.r.render(xmlStream, text);\n        });\n      } else {\n        this.map.t.render(xmlStream, '');\n      }\n    } else if (model !== undefined && model !== null) {\n      this.map.t.render(xmlStream, model);\n    }\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    const {name} = node;\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    if (name === this.tag) {\n      this.model = {};\n      return true;\n    }\n    this.parser = this.map[name];\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    return false;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        switch (name) {\n          case 'r': {\n            let rt = this.model.richText;\n            if (!rt) {\n              rt = this.model.richText = [];\n            }\n            rt.push(this.parser.model);\n            break;\n          }\n          case 't':\n            this.model = this.parser.model;\n            break;\n          default:\n            break;\n        }\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = SharedStringXform;\n","const BaseXform = require('../base-xform');\n\n//   <t xml:space=\"preserve\"> is </t>\n\nclass TextXform extends BaseXform {\n  get tag() {\n    return 't';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('t');\n    if (/^\\s|\\n|\\s$/.test(model)) {\n      xmlStream.addAttribute('xml:space', 'preserve');\n    }\n    xmlStream.writeText(model);\n    xmlStream.closeNode();\n  }\n\n  get model() {\n    return this._text\n      .join('')\n      .replace(/_x([0-9A-F]{4})_/g, ($0, $1) => String.fromCharCode(parseInt($1, 16)));\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 't':\n        this._text = [];\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    this._text.push(text);\n  }\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = TextXform;\n","const TextXform = require('./text-xform');\nconst FontXform = require('../style/font-xform');\n\nconst BaseXform = require('../base-xform');\n\n// <r>\n//   <rPr>\n//     <sz val=\"11\"/>\n//     <color theme=\"1\" tint=\"5\"/>\n//     <rFont val=\"Calibri\"/>\n//     <family val=\"2\"/>\n//     <scheme val=\"minor\"/>\n//   </rPr>\n//   <t xml:space=\"preserve\"> is </t>\n// </r>\n\nclass RichTextXform extends BaseXform {\n  constructor(model) {\n    super();\n\n    this.model = model;\n  }\n\n  get tag() {\n    return 'r';\n  }\n\n  get textXform() {\n    return this._textXform || (this._textXform = new TextXform());\n  }\n\n  get fontXform() {\n    return this._fontXform || (this._fontXform = new FontXform(RichTextXform.FONT_OPTIONS));\n  }\n\n  render(xmlStream, model) {\n    model = model || this.model;\n\n    xmlStream.openNode('r');\n    if (model.font) {\n      this.fontXform.render(xmlStream, model.font);\n    }\n    this.textXform.render(xmlStream, model.text);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'r':\n        this.model = {};\n        return true;\n      case 't':\n        this.parser = this.textXform;\n        this.parser.parseOpen(node);\n        return true;\n      case 'rPr':\n        this.parser = this.fontXform;\n        this.parser.parseOpen(node);\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    switch (name) {\n      case 'r':\n        return false;\n      case 't':\n        this.model.text = this.parser.model;\n        this.parser = undefined;\n        return true;\n      case 'rPr':\n        this.model.font = this.parser.model;\n        this.parser = undefined;\n        return true;\n      default:\n        if (this.parser) {\n          this.parser.parseClose(name);\n        }\n        return true;\n    }\n  }\n}\n\nRichTextXform.FONT_OPTIONS = {\n  tagName: 'rPr',\n  fontNameTag: 'rFont',\n};\n\nmodule.exports = RichTextXform;\n","const TextXform = require('./text-xform');\nconst RichTextXform = require('./rich-text-xform');\n\nconst BaseXform = require('../base-xform');\n\n// <rPh sb=\"0\" eb=\"1\">\n//   <t>(its pronounciation in KATAKANA)</t>\n// </rPh>\n\nclass PhoneticTextXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      r: new RichTextXform(),\n      t: new TextXform(),\n    };\n  }\n\n  get tag() {\n    return 'rPh';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      sb: model.sb || 0,\n      eb: model.eb || 0,\n    });\n    if (model && model.hasOwnProperty('richText') && model.richText) {\n      const {r} = this.map;\n      model.richText.forEach(text => {\n        r.render(xmlStream, text);\n      });\n    } else if (model) {\n      this.map.t.render(xmlStream, model.text);\n    }\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    const {name} = node;\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    if (name === this.tag) {\n      this.model = {\n        sb: parseInt(node.attributes.sb, 10),\n        eb: parseInt(node.attributes.eb, 10),\n      };\n      return true;\n    }\n    this.parser = this.map[name];\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    return false;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        switch (name) {\n          case 'r': {\n            let rt = this.model.richText;\n            if (!rt) {\n              rt = this.model.richText = [];\n            }\n            rt.push(this.parser.model);\n            break;\n          }\n          case 't':\n            this.model.text = this.parser.model;\n            break;\n          default:\n            break;\n        }\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = PhoneticTextXform;\n","const XmlStream = require('../../../utils/xml-stream');\nconst BaseXform = require('../base-xform');\n\nconst RelationshipXform = require('./relationship-xform');\n\nclass RelationshipsXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      Relationship: new RelationshipXform(),\n    };\n  }\n\n  render(xmlStream, model) {\n    model = model || this._values;\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode('Relationships', RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);\n\n    model.forEach(relationship => {\n      this.map.Relationship.render(xmlStream, relationship);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'Relationships':\n        this.model = [];\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.push(this.parser.model);\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'Relationships':\n        return false;\n      default:\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\n    }\n  }\n}\n\nRelationshipsXform.RELATIONSHIPS_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/package/2006/relationships',\n};\n\nmodule.exports = RelationshipsXform;\n","const BaseXform = require('../base-xform');\n\nclass RelationshipXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.leafNode('Relationship', model);\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'Relationship':\n        this.model = node.attributes;\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = RelationshipXform;\n","const XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\n\n// used for rendering the [Content_Types].xml file\n// not used for parsing\nclass ContentTypesXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n\n    xmlStream.openNode('Types', ContentTypesXform.PROPERTY_ATTRIBUTES);\n\n    const mediaHash = {};\n    (model.media || []).forEach(medium => {\n      if (medium.type === 'image') {\n        const imageType = medium.extension;\n        if (!mediaHash[imageType]) {\n          mediaHash[imageType] = true;\n          xmlStream.leafNode('Default', {Extension: imageType, ContentType: `image/${imageType}`});\n        }\n      }\n    });\n\n    xmlStream.leafNode('Default', {\n      Extension: 'rels',\n      ContentType: 'application/vnd.openxmlformats-package.relationships+xml',\n    });\n    xmlStream.leafNode('Default', {Extension: 'xml', ContentType: 'application/xml'});\n\n    xmlStream.leafNode('Override', {\n      PartName: '/xl/workbook.xml',\n      ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',\n    });\n\n    model.worksheets.forEach(worksheet => {\n      const name = `/xl/worksheets/sheet${worksheet.id}.xml`;\n      xmlStream.leafNode('Override', {\n        PartName: name,\n        ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',\n      });\n    });\n\n    xmlStream.leafNode('Override', {\n      PartName: '/xl/theme/theme1.xml',\n      ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',\n    });\n    xmlStream.leafNode('Override', {\n      PartName: '/xl/styles.xml',\n      ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',\n    });\n\n    const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;\n    if (hasSharedStrings) {\n      xmlStream.leafNode('Override', {\n        PartName: '/xl/sharedStrings.xml',\n        ContentType:\n          'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',\n      });\n    }\n\n    if (model.tables) {\n      model.tables.forEach(table => {\n        xmlStream.leafNode('Override', {\n          PartName: `/xl/tables/${table.target}`,\n          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',\n        });\n      });\n    }\n\n    if (model.drawings) {\n      model.drawings.forEach(drawing => {\n        xmlStream.leafNode('Override', {\n          PartName: `/xl/drawings/${drawing.name}.xml`,\n          ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml',\n        });\n      });\n    }\n\n    if (model.commentRefs) {\n      xmlStream.leafNode('Default', {\n        Extension: 'vml',\n        ContentType: 'application/vnd.openxmlformats-officedocument.vmlDrawing',\n      });\n\n      model.commentRefs.forEach(({commentName}) => {\n        xmlStream.leafNode('Override', {\n          PartName: `/xl/${commentName}.xml`,\n          ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',\n        });\n      });\n    }\n\n    xmlStream.leafNode('Override', {\n      PartName: '/docProps/core.xml',\n      ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',\n    });\n    xmlStream.leafNode('Override', {\n      PartName: '/docProps/app.xml',\n      ContentType: 'application/vnd.openxmlformats-officedocument.extended-properties+xml',\n    });\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen() {\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nContentTypesXform.PROPERTY_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/package/2006/content-types',\n};\n\nmodule.exports = ContentTypesXform;\n","const XmlStream = require('../../../utils/xml-stream');\nconst BaseXform = require('../base-xform');\nconst StringXform = require('../simple/string-xform');\n\nconst AppHeadingPairsXform = require('./app-heading-pairs-xform');\nconst AppTitleOfPartsXform = require('./app-titles-of-parts-xform');\n\nclass AppXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      Company: new StringXform({tag: 'Company'}),\n      Manager: new StringXform({tag: 'Manager'}),\n      HeadingPairs: new AppHeadingPairsXform(),\n      TitleOfParts: new AppTitleOfPartsXform(),\n    };\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n\n    xmlStream.openNode('Properties', AppXform.PROPERTY_ATTRIBUTES);\n\n    xmlStream.leafNode('Application', undefined, 'Microsoft Excel');\n    xmlStream.leafNode('DocSecurity', undefined, '0');\n    xmlStream.leafNode('ScaleCrop', undefined, 'false');\n\n    this.map.HeadingPairs.render(xmlStream, model.worksheets);\n    this.map.TitleOfParts.render(xmlStream, model.worksheets);\n    this.map.Company.render(xmlStream, model.company || '');\n    this.map.Manager.render(xmlStream, model.manager);\n\n    xmlStream.leafNode('LinksUpToDate', undefined, 'false');\n    xmlStream.leafNode('SharedDoc', undefined, 'false');\n    xmlStream.leafNode('HyperlinksChanged', undefined, 'false');\n    xmlStream.leafNode('AppVersion', undefined, '16.0300');\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'Properties':\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n          return true;\n        }\n\n        // there's a lot we don't bother to parse\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'Properties':\n        this.model = {\n          worksheets: this.map.TitleOfParts.model,\n          company: this.map.Company.model,\n          manager: this.map.Manager.model,\n        };\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nAppXform.DateFormat = function(dt) {\n  return dt.toISOString().replace(/[.]\\d{3,6}/, '');\n};\n\nAppXform.DateAttrs = {'xsi:type': 'dcterms:W3CDTF'};\n\nAppXform.PROPERTY_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',\n  'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',\n};\n\nmodule.exports = AppXform;\n","const BaseXform = require('../base-xform');\n\nclass AppHeadingPairsXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.openNode('HeadingPairs');\n    xmlStream.openNode('vt:vector', {size: 2, baseType: 'variant'});\n\n    xmlStream.openNode('vt:variant');\n    xmlStream.leafNode('vt:lpstr', undefined, 'Worksheets');\n    xmlStream.closeNode();\n\n    xmlStream.openNode('vt:variant');\n    xmlStream.leafNode('vt:i4', undefined, model.length);\n    xmlStream.closeNode();\n\n    xmlStream.closeNode();\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    // no parsing\n    return node.name === 'HeadingPairs';\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    return name !== 'HeadingPairs';\n  }\n}\n\nmodule.exports = AppHeadingPairsXform;\n","const BaseXform = require('../base-xform');\n\nclass AppTitlesOfPartsXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.openNode('TitlesOfParts');\n    xmlStream.openNode('vt:vector', {size: model.length, baseType: 'lpstr'});\n\n    model.forEach(sheet => {\n      xmlStream.leafNode('vt:lpstr', undefined, sheet.name);\n    });\n\n    xmlStream.closeNode();\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    // no parsing\n    return node.name === 'TitlesOfParts';\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    return name !== 'TitlesOfParts';\n  }\n}\n\nmodule.exports = AppTitlesOfPartsXform;\n","const _ = require('../../../utils/under-dash');\n\nconst colCache = require('../../../utils/col-cache');\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\nconst StaticXform = require('../static-xform');\nconst ListXform = require('../list-xform');\nconst DefinedNameXform = require('./defined-name-xform');\nconst SheetXform = require('./sheet-xform');\nconst WorkbookViewXform = require('./workbook-view-xform');\nconst WorkbookPropertiesXform = require('./workbook-properties-xform');\nconst WorkbookCalcPropertiesXform = require('./workbook-calc-properties-xform');\n\nclass WorkbookXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,\n      workbookPr: new WorkbookPropertiesXform(),\n      bookViews: new ListXform({\n        tag: 'bookViews',\n        count: false,\n        childXform: new WorkbookViewXform(),\n      }),\n      sheets: new ListXform({tag: 'sheets', count: false, childXform: new SheetXform()}),\n      definedNames: new ListXform({\n        tag: 'definedNames',\n        count: false,\n        childXform: new DefinedNameXform(),\n      }),\n      calcPr: new WorkbookCalcPropertiesXform(),\n    };\n  }\n\n  prepare(model) {\n    model.sheets = model.worksheets;\n\n    // collate all the print areas from all of the sheets and add them to the defined names\n    const printAreas = [];\n    let index = 0; // sheets is sparse array - calc index manually\n    model.sheets.forEach(sheet => {\n      if (sheet.pageSetup && sheet.pageSetup.printArea) {\n        sheet.pageSetup.printArea.split('&&').forEach(printArea => {\n          const printAreaComponents = printArea.split(':');\n          const definedName = {\n            name: '_xlnm.Print_Area',\n            ranges: [`'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`],\n            localSheetId: index,\n          };\n          printAreas.push(definedName);\n        });\n      }\n\n      if (\n        sheet.pageSetup &&\n        (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)\n      ) {\n        const ranges = [];\n\n        if (sheet.pageSetup.printTitlesColumn) {\n          const titlesColumns = sheet.pageSetup.printTitlesColumn.split(':');\n          ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);\n        }\n\n        if (sheet.pageSetup.printTitlesRow) {\n          const titlesRows = sheet.pageSetup.printTitlesRow.split(':');\n          ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);\n        }\n\n        const definedName = {\n          name: '_xlnm.Print_Titles',\n          ranges,\n          localSheetId: index,\n        };\n\n        printAreas.push(definedName);\n      }\n      index++;\n    });\n    if (printAreas.length) {\n      model.definedNames = model.definedNames.concat(printAreas);\n    }\n\n    (model.media || []).forEach((medium, i) => {\n      // assign name\n      medium.name = medium.type + (i + 1);\n    });\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode('workbook', WorkbookXform.WORKBOOK_ATTRIBUTES);\n\n    this.map.fileVersion.render(xmlStream);\n    this.map.workbookPr.render(xmlStream, model.properties);\n    this.map.bookViews.render(xmlStream, model.views);\n    this.map.sheets.render(xmlStream, model.sheets);\n    this.map.definedNames.render(xmlStream, model.definedNames);\n    this.map.calcPr.render(xmlStream, model.calcProperties);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'workbook':\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        return true;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'workbook':\n        this.model = {\n          sheets: this.map.sheets.model,\n          properties: this.map.workbookPr.model || {},\n          views: this.map.bookViews.model,\n          calcProperties: {},\n        };\n        if (this.map.definedNames.model) {\n          this.model.definedNames = this.map.definedNames.model;\n        }\n\n        return false;\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n\n  reconcile(model) {\n    const rels = (model.workbookRels || []).reduce((map, rel) => {\n      map[rel.Id] = rel;\n      return map;\n    }, {});\n\n    // reconcile sheet ids, rIds and names\n    const worksheets = [];\n    let worksheet;\n    let index = 0;\n\n    (model.sheets || []).forEach(sheet => {\n      const rel = rels[sheet.rId];\n      if (!rel) {\n        return;\n      }\n      // if rel.Target start with `[space]/xl/` or `/xl/` , then it will be replaced with `''` and spliced behind `xl/`,\n      // otherwise it will be spliced directly behind `xl/`. i.g.\n      worksheet = model.worksheetHash[`xl/${rel.Target.replace(/^(\\s|\\/xl\\/)+/, '')}`];\n      // If there are \"chartsheets\" in the file, rel.Target will\n      // come out as chartsheets/sheet1.xml or similar here, and\n      // that won't be in model.worksheetHash.\n      // As we don't have the infrastructure to support chartsheets,\n      // we will ignore them for now:\n      if (worksheet) {\n        worksheet.name = sheet.name;\n        worksheet.id = sheet.id;\n        worksheet.state = sheet.state;\n        worksheets[index++] = worksheet;\n      }\n    });\n\n    // reconcile print areas\n    const definedNames = [];\n    _.each(model.definedNames, definedName => {\n      if (definedName.name === '_xlnm.Print_Area') {\n        worksheet = worksheets[definedName.localSheetId];\n        if (worksheet) {\n          if (!worksheet.pageSetup) {\n            worksheet.pageSetup = {};\n          }\n          const range = colCache.decodeEx(definedName.ranges[0]);\n          worksheet.pageSetup.printArea = worksheet.pageSetup.printArea\n            ? `${worksheet.pageSetup.printArea}&&${range.dimensions}`\n            : range.dimensions;\n        }\n      } else if (definedName.name === '_xlnm.Print_Titles') {\n        worksheet = worksheets[definedName.localSheetId];\n        if (worksheet) {\n          if (!worksheet.pageSetup) {\n            worksheet.pageSetup = {};\n          }\n\n          const rangeString = definedName.ranges.join(',');\n\n          const dollarRegex = /\\$/g;\n\n          const rowRangeRegex = /\\$\\d+:\\$\\d+/;\n          const rowRangeMatches = rangeString.match(rowRangeRegex);\n\n          if (rowRangeMatches && rowRangeMatches.length) {\n            const range = rowRangeMatches[0];\n            worksheet.pageSetup.printTitlesRow = range.replace(dollarRegex, '');\n          }\n\n          const columnRangeRegex = /\\$[A-Z]+:\\$[A-Z]+/;\n          const columnRangeMatches = rangeString.match(columnRangeRegex);\n\n          if (columnRangeMatches && columnRangeMatches.length) {\n            const range = columnRangeMatches[0];\n            worksheet.pageSetup.printTitlesColumn = range.replace(dollarRegex, '');\n          }\n        }\n      } else {\n        definedNames.push(definedName);\n      }\n    });\n    model.definedNames = definedNames;\n\n    // used by sheets to build their image models\n    model.media.forEach((media, i) => {\n      media.index = i;\n    });\n  }\n}\n\nWorkbookXform.WORKBOOK_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'x15',\n  'xmlns:x15': 'http://schemas.microsoft.com/office/spreadsheetml/2010/11/main',\n};\nWorkbookXform.STATIC_XFORMS = {\n  fileVersion: new StaticXform({\n    tag: 'fileVersion',\n    $: {appName: 'xl', lastEdited: 5, lowestEdited: 5, rupBuild: 9303},\n  }),\n};\n\nmodule.exports = WorkbookXform;\n","const BaseXform = require('../base-xform');\nconst colCache = require('../../../utils/col-cache');\n\nclass DefinedNamesXform extends BaseXform {\n  render(xmlStream, model) {\n    // <definedNames>\n    //   <definedName name=\"name\">name.ranges.join(',')</definedName>\n    //   <definedName name=\"_xlnm.Print_Area\" localSheetId=\"0\">name.ranges.join(',')</definedName>\n    // </definedNames>\n    xmlStream.openNode('definedName', {\n      name: model.name,\n      localSheetId: model.localSheetId,\n    });\n    xmlStream.writeText(model.ranges.join(','));\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'definedName':\n        this._parsedName = node.attributes.name;\n        this._parsedLocalSheetId = node.attributes.localSheetId;\n        this._parsedText = [];\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    this._parsedText.push(text);\n  }\n\n  parseClose() {\n    this.model = {\n      name: this._parsedName,\n      ranges: extractRanges(this._parsedText.join('')),\n    };\n    if (this._parsedLocalSheetId !== undefined) {\n      this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);\n    }\n    return false;\n  }\n}\n\nfunction isValidRange(range) {\n  try {\n    colCache.decodeEx(range);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction extractRanges(parsedText) {\n  const ranges = [];\n  let quotesOpened = false;\n  let last = '';\n  parsedText.split(',').forEach(item => {\n    if (!item) {\n      return;\n    }\n    const quotes = (item.match(/'/g) || []).length;\n\n    if (!quotes) {\n      if (quotesOpened) {\n        last += `${item},`;\n      } else if (isValidRange(item)) {\n        ranges.push(item);\n      }\n      return;\n    }\n    const quotesEven = quotes % 2 === 0;\n\n    if (!quotesOpened && quotesEven && isValidRange(item)) {\n      ranges.push(item);\n    } else if (quotesOpened && !quotesEven) {\n      quotesOpened = false;\n      if (isValidRange(last + item)) {\n        ranges.push(last + item);\n      }\n      last = '';\n    } else {\n      quotesOpened = true;\n      last += `${item},`;\n    }\n  });\n  return ranges;\n}\n\nmodule.exports = DefinedNamesXform;\n","const utils = require('../../../utils/utils');\nconst BaseXform = require('../base-xform');\n\nclass WorksheetXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.leafNode('sheet', {\n      sheetId: model.id,\n      name: model.name,\n      state: model.state,\n      'r:id': model.rId,\n    });\n  }\n\n  parseOpen(node) {\n    if (node.name === 'sheet') {\n      this.model = {\n        name: utils.xmlDecode(node.attributes.name),\n        id: parseInt(node.attributes.sheetId, 10),\n        state: node.attributes.state,\n        rId: node.attributes['r:id'],\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = WorksheetXform;\n","const BaseXform = require('../base-xform');\n\nclass WorkbookViewXform extends BaseXform {\n  render(xmlStream, model) {\n    const attributes = {\n      xWindow: model.x || 0,\n      yWindow: model.y || 0,\n      windowWidth: model.width || 12000,\n      windowHeight: model.height || 24000,\n      firstSheet: model.firstSheet,\n      activeTab: model.activeTab,\n    };\n    if (model.visibility && model.visibility !== 'visible') {\n      attributes.visibility = model.visibility;\n    }\n    xmlStream.leafNode('workbookView', attributes);\n  }\n\n  parseOpen(node) {\n    if (node.name === 'workbookView') {\n      const model = (this.model = {});\n      const addS = function(name, value, dflt) {\n        const s = value !== undefined ? (model[name] = value) : dflt;\n        if (s !== undefined) {\n          model[name] = s;\n        }\n      };\n      const addN = function(name, value, dflt) {\n        const n = value !== undefined ? (model[name] = parseInt(value, 10)) : dflt;\n        if (n !== undefined) {\n          model[name] = n;\n        }\n      };\n      addN('x', node.attributes.xWindow, 0);\n      addN('y', node.attributes.yWindow, 0);\n      addN('width', node.attributes.windowWidth, 25000);\n      addN('height', node.attributes.windowHeight, 10000);\n      addS('visibility', node.attributes.visibility, 'visible');\n      addN('activeTab', node.attributes.activeTab, undefined);\n      addN('firstSheet', node.attributes.firstSheet, undefined);\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = WorkbookViewXform;\n","const BaseXform = require('../base-xform');\n\nclass WorksheetPropertiesXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.leafNode('workbookPr', {\n      date1904: model.date1904 ? 1 : undefined,\n      defaultThemeVersion: 164011,\n      filterPrivacy: 1,\n    });\n  }\n\n  parseOpen(node) {\n    if (node.name === 'workbookPr') {\n      this.model = {\n        date1904: node.attributes.date1904 === '1',\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = WorksheetPropertiesXform;\n","const BaseXform = require('../base-xform');\n\nclass WorkbookCalcPropertiesXform extends BaseXform {\n  render(xmlStream, model) {\n    xmlStream.leafNode('calcPr', {\n      calcId: 171027,\n      fullCalcOnLoad: model.fullCalcOnLoad ? 1 : undefined,\n    });\n  }\n\n  parseOpen(node) {\n    if (node.name === 'calcPr') {\n      this.model = {};\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = WorkbookCalcPropertiesXform;\n","const _ = require('../../../utils/under-dash');\n\nconst colCache = require('../../../utils/col-cache');\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst RelType = require('../../rel-type');\n\nconst Merges = require('./merges');\n\nconst BaseXform = require('../base-xform');\nconst ListXform = require('../list-xform');\nconst RowXform = require('./row-xform');\nconst ColXform = require('./col-xform');\nconst DimensionXform = require('./dimension-xform');\nconst HyperlinkXform = require('./hyperlink-xform');\nconst MergeCellXform = require('./merge-cell-xform');\nconst DataValidationsXform = require('./data-validations-xform');\nconst SheetPropertiesXform = require('./sheet-properties-xform');\nconst SheetFormatPropertiesXform = require('./sheet-format-properties-xform');\nconst SheetViewXform = require('./sheet-view-xform');\nconst SheetProtectionXform = require('./sheet-protection-xform');\nconst PageMarginsXform = require('./page-margins-xform');\nconst PageSetupXform = require('./page-setup-xform');\nconst PrintOptionsXform = require('./print-options-xform');\nconst AutoFilterXform = require('./auto-filter-xform');\nconst PictureXform = require('./picture-xform');\nconst DrawingXform = require('./drawing-xform');\nconst TablePartXform = require('./table-part-xform');\nconst RowBreaksXform = require('./row-breaks-xform');\nconst HeaderFooterXform = require('./header-footer-xform');\nconst ConditionalFormattingsXform = require('./cf/conditional-formattings-xform');\nconst ExtListXform = require('./ext-lst-xform');\n\nconst mergeRule = (rule, extRule) => {\n  Object.keys(extRule).forEach(key => {\n    const value = rule[key];\n    const extValue = extRule[key];\n    if (value === undefined && extValue !== undefined) {\n      rule[key] = extValue;\n    }\n  });\n};\n\nconst mergeConditionalFormattings = (model, extModel) => {\n  // conditional formattings are rendered in worksheet.conditionalFormatting and also in\n  // worksheet.extLst.ext.x14:conditionalFormattings\n  // some (e.g. dataBar) are even spread across both!\n  if (!extModel || !extModel.length) {\n    return model;\n  }\n  if (!model || !model.length) {\n    return extModel;\n  }\n\n  // index model rules by x14Id\n  const cfMap = {};\n  const ruleMap = {};\n  model.forEach(cf => {\n    cfMap[cf.ref] = cf;\n    cf.rules.forEach(rule => {\n      const {x14Id} = rule;\n      if (x14Id) {\n        ruleMap[x14Id] = rule;\n      }\n    });\n  });\n\n  extModel.forEach(extCf => {\n    extCf.rules.forEach(extRule => {\n      const rule = ruleMap[extRule.x14Id];\n      if (rule) {\n        // merge with matching rule\n        mergeRule(rule, extRule);\n      } else if (cfMap[extCf.ref]) {\n        // reuse existing cf ref\n        cfMap[extCf.ref].rules.push(extRule);\n      } else {\n        // create new cf\n        model.push({\n          ref: extCf.ref,\n          rules: [extRule],\n        });\n      }\n    });\n  });\n\n  // need to cope with rules in extModel that don't exist in model\n  return model;\n};\n\nclass WorkSheetXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    const {maxRows, maxCols, ignoreNodes} = options || {};\n\n    this.ignoreNodes = ignoreNodes || [];\n\n    this.map = {\n      sheetPr: new SheetPropertiesXform(),\n      dimension: new DimensionXform(),\n      sheetViews: new ListXform({\n        tag: 'sheetViews',\n        count: false,\n        childXform: new SheetViewXform(),\n      }),\n      sheetFormatPr: new SheetFormatPropertiesXform(),\n      cols: new ListXform({tag: 'cols', count: false, childXform: new ColXform()}),\n      sheetData: new ListXform({\n        tag: 'sheetData',\n        count: false,\n        empty: true,\n        childXform: new RowXform({maxItems: maxCols}),\n        maxItems: maxRows,\n      }),\n      autoFilter: new AutoFilterXform(),\n      mergeCells: new ListXform({tag: 'mergeCells', count: true, childXform: new MergeCellXform()}),\n      rowBreaks: new RowBreaksXform(),\n      hyperlinks: new ListXform({\n        tag: 'hyperlinks',\n        count: false,\n        childXform: new HyperlinkXform(),\n      }),\n      pageMargins: new PageMarginsXform(),\n      dataValidations: new DataValidationsXform(),\n      pageSetup: new PageSetupXform(),\n      headerFooter: new HeaderFooterXform(),\n      printOptions: new PrintOptionsXform(),\n      picture: new PictureXform(),\n      drawing: new DrawingXform(),\n      sheetProtection: new SheetProtectionXform(),\n      tableParts: new ListXform({tag: 'tableParts', count: true, childXform: new TablePartXform()}),\n      conditionalFormatting: new ConditionalFormattingsXform(),\n      extLst: new ExtListXform(),\n    };\n  }\n\n  prepare(model, options) {\n    options.merges = new Merges();\n    model.hyperlinks = options.hyperlinks = [];\n    model.comments = options.comments = [];\n\n    options.formulae = {};\n    options.siFormulae = 0;\n    this.map.cols.prepare(model.cols, options);\n    this.map.sheetData.prepare(model.rows, options);\n    this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);\n\n    model.mergeCells = options.merges.mergeCells;\n\n    // prepare relationships\n    const rels = (model.rels = []);\n\n    function nextRid(r) {\n      return `rId${r.length + 1}`;\n    }\n\n    model.hyperlinks.forEach(hyperlink => {\n      const rId = nextRid(rels);\n      hyperlink.rId = rId;\n      rels.push({\n        Id: rId,\n        Type: RelType.Hyperlink,\n        Target: hyperlink.target,\n        TargetMode: 'External',\n      });\n    });\n\n    // prepare comment relationships\n    if (model.comments.length > 0) {\n      const comment = {\n        Id: nextRid(rels),\n        Type: RelType.Comments,\n        Target: `../comments${model.id}.xml`,\n      };\n      rels.push(comment);\n      const vmlDrawing = {\n        Id: nextRid(rels),\n        Type: RelType.VmlDrawing,\n        Target: `../drawings/vmlDrawing${model.id}.vml`,\n      };\n      rels.push(vmlDrawing);\n\n      model.comments.forEach(item => {\n        item.refAddress = colCache.decodeAddress(item.ref);\n      });\n\n      options.commentRefs.push({\n        commentName: `comments${model.id}`,\n        vmlDrawing: `vmlDrawing${model.id}`,\n      });\n    }\n\n    const drawingRelsHash = [];\n    let bookImage;\n    model.media.forEach(medium => {\n      if (medium.type === 'background') {\n        const rId = nextRid(rels);\n        bookImage = options.media[medium.imageId];\n        rels.push({\n          Id: rId,\n          Type: RelType.Image,\n          Target: `../media/${bookImage.name}.${bookImage.extension}`,\n        });\n        model.background = {\n          rId,\n        };\n        model.image = options.media[medium.imageId];\n      } else if (medium.type === 'image') {\n        let {drawing} = model;\n        bookImage = options.media[medium.imageId];\n        if (!drawing) {\n          drawing = model.drawing = {\n            rId: nextRid(rels),\n            name: `drawing${++options.drawingsCount}`,\n            anchors: [],\n            rels: [],\n          };\n          options.drawings.push(drawing);\n          rels.push({\n            Id: drawing.rId,\n            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',\n            Target: `../drawings/${drawing.name}.xml`,\n          });\n        }\n        let rIdImage =\n          this.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];\n        if (!rIdImage) {\n          rIdImage = nextRid(drawing.rels);\n          drawingRelsHash[drawing.rels.length] = rIdImage;\n          drawing.rels.push({\n            Id: rIdImage,\n            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',\n            Target: `../media/${bookImage.name}.${bookImage.extension}`,\n          });\n        }\n\n        const anchor = {\n          picture: {\n            rId: rIdImage,\n          },\n          range: medium.range,\n        };\n        if (medium.hyperlinks && medium.hyperlinks.hyperlink) {\n          const rIdHyperLink = nextRid(drawing.rels);\n          drawingRelsHash[drawing.rels.length] = rIdHyperLink;\n          anchor.picture.hyperlinks = {\n            tooltip: medium.hyperlinks.tooltip,\n            rId: rIdHyperLink,\n          };\n          drawing.rels.push({\n            Id: rIdHyperLink,\n            Type: RelType.Hyperlink,\n            Target: medium.hyperlinks.hyperlink,\n            TargetMode: 'External',\n          });\n        }\n        this.preImageId = medium.imageId;\n        drawing.anchors.push(anchor);\n      }\n    });\n\n    // prepare tables\n    model.tables.forEach(table => {\n      // relationships\n      const rId = nextRid(rels);\n      table.rId = rId;\n      rels.push({\n        Id: rId,\n        Type: RelType.Table,\n        Target: `../tables/${table.target}`,\n      });\n\n      // dynamic styles\n      table.columns.forEach(column => {\n        const {style} = column;\n        if (style) {\n          column.dxfId = options.styles.addDxfStyle(style);\n        }\n      });\n    });\n\n    // prepare ext items\n    this.map.extLst.prepare(model, options);\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode('worksheet', WorkSheetXform.WORKSHEET_ATTRIBUTES);\n\n    const sheetFormatPropertiesModel = model.properties\n      ? {\n          defaultRowHeight: model.properties.defaultRowHeight,\n          dyDescent: model.properties.dyDescent,\n          outlineLevelCol: model.properties.outlineLevelCol,\n          outlineLevelRow: model.properties.outlineLevelRow,\n        }\n      : undefined;\n    if (model.properties && model.properties.defaultColWidth) {\n      sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;\n    }\n    const sheetPropertiesModel = {\n      outlineProperties: model.properties && model.properties.outlineProperties,\n      tabColor: model.properties && model.properties.tabColor,\n      pageSetup:\n        model.pageSetup && model.pageSetup.fitToPage\n          ? {\n              fitToPage: model.pageSetup.fitToPage,\n            }\n          : undefined,\n    };\n    const pageMarginsModel = model.pageSetup && model.pageSetup.margins;\n    const printOptionsModel = {\n      showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,\n      showGridLines: model.pageSetup && model.pageSetup.showGridLines,\n      horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,\n      verticalCentered: model.pageSetup && model.pageSetup.verticalCentered,\n    };\n    const sheetProtectionModel = model.sheetProtection;\n\n    this.map.sheetPr.render(xmlStream, sheetPropertiesModel);\n    this.map.dimension.render(xmlStream, model.dimensions);\n    this.map.sheetViews.render(xmlStream, model.views);\n    this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);\n    this.map.cols.render(xmlStream, model.cols);\n    this.map.sheetData.render(xmlStream, model.rows);\n    this.map.sheetProtection.render(xmlStream, sheetProtectionModel); // Note: must be after sheetData and before autoFilter\n    this.map.autoFilter.render(xmlStream, model.autoFilter);\n    this.map.mergeCells.render(xmlStream, model.mergeCells);\n    this.map.conditionalFormatting.render(xmlStream, model.conditionalFormattings); // Note: must be before dataValidations\n    this.map.dataValidations.render(xmlStream, model.dataValidations);\n\n    // For some reason hyperlinks have to be after the data validations\n    this.map.hyperlinks.render(xmlStream, model.hyperlinks);\n\n    this.map.printOptions.render(xmlStream, printOptionsModel); // Note: must be before pageMargins\n    this.map.pageMargins.render(xmlStream, pageMarginsModel);\n    this.map.pageSetup.render(xmlStream, model.pageSetup);\n    this.map.headerFooter.render(xmlStream, model.headerFooter);\n    this.map.rowBreaks.render(xmlStream, model.rowBreaks);\n    this.map.drawing.render(xmlStream, model.drawing); // Note: must be after rowBreaks\n    this.map.picture.render(xmlStream, model.background); // Note: must be after drawing\n    this.map.tableParts.render(xmlStream, model.tables);\n\n    this.map.extLst.render(xmlStream, model);\n\n    if (model.rels) {\n      // add a <legacyDrawing /> node for each comment\n      model.rels.forEach(rel => {\n        if (rel.Type === RelType.VmlDrawing) {\n          xmlStream.leafNode('legacyDrawing', {'r:id': rel.Id});\n        }\n      });\n    }\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    if (node.name === 'worksheet') {\n      _.each(this.map, xform => {\n        xform.reset();\n      });\n      return true;\n    }\n\n    if (this.map[node.name] && !this.ignoreNodes.includes(node.name)) {\n      this.parser = this.map[node.name];\n      this.parser.parseOpen(node);\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case 'worksheet': {\n        const properties = this.map.sheetFormatPr.model || {};\n        if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {\n          properties.tabColor = this.map.sheetPr.model.tabColor;\n        }\n        if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {\n          properties.outlineProperties = this.map.sheetPr.model.outlineProperties;\n        }\n        const sheetProperties = {\n          fitToPage:\n            (this.map.sheetPr.model &&\n              this.map.sheetPr.model.pageSetup &&\n              this.map.sheetPr.model.pageSetup.fitToPage) ||\n            false,\n          margins: this.map.pageMargins.model,\n        };\n        const pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);\n        const conditionalFormattings = mergeConditionalFormattings(\n          this.map.conditionalFormatting.model,\n          this.map.extLst.model && this.map.extLst.model['x14:conditionalFormattings']\n        );\n        this.model = {\n          dimensions: this.map.dimension.model,\n          cols: this.map.cols.model,\n          rows: this.map.sheetData.model,\n          mergeCells: this.map.mergeCells.model,\n          hyperlinks: this.map.hyperlinks.model,\n          dataValidations: this.map.dataValidations.model,\n          properties,\n          views: this.map.sheetViews.model,\n          pageSetup,\n          headerFooter: this.map.headerFooter.model,\n          background: this.map.picture.model,\n          drawing: this.map.drawing.model,\n          tables: this.map.tableParts.model,\n          conditionalFormattings,\n        };\n\n        if (this.map.autoFilter.model) {\n          this.model.autoFilter = this.map.autoFilter.model;\n        }\n        if (this.map.sheetProtection.model) {\n          this.model.sheetProtection = this.map.sheetProtection.model;\n        }\n\n        return false;\n      }\n\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    // options.merges = new Merges();\n    // options.merges.reconcile(model.mergeCells, model.rows);\n    const rels = (model.relationships || []).reduce((h, rel) => {\n      h[rel.Id] = rel;\n      if (rel.Type === RelType.Comments) {\n        model.comments = options.comments[rel.Target].comments;\n      }\n      if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {\n        const vmlComment = options.vmlDrawings[rel.Target].comments;\n        model.comments.forEach((comment, index) => {\n          comment.note = Object.assign({}, comment.note, vmlComment[index]);\n        });\n      }\n      return h;\n    }, {});\n    options.commentsMap = (model.comments || []).reduce((h, comment) => {\n      if (comment.ref) {\n        h[comment.ref] = comment;\n      }\n      return h;\n    }, {});\n    options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {\n      if (hyperlink.rId) {\n        h[hyperlink.address] = rels[hyperlink.rId].Target;\n      }\n      return h;\n    }, {});\n    options.formulae = {};\n\n    // compact the rows and cells\n    model.rows = (model.rows && model.rows.filter(Boolean)) || [];\n    model.rows.forEach(row => {\n      row.cells = (row.cells && row.cells.filter(Boolean)) || [];\n    });\n\n    this.map.cols.reconcile(model.cols, options);\n    this.map.sheetData.reconcile(model.rows, options);\n    this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);\n\n    model.media = [];\n    if (model.drawing) {\n      const drawingRel = rels[model.drawing.rId];\n      const match = drawingRel.Target.match(/\\/drawings\\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);\n      if (match) {\n        const drawingName = match[1];\n        const drawing = options.drawings[drawingName];\n        drawing.anchors.forEach(anchor => {\n          if (anchor.medium) {\n            const image = {\n              type: 'image',\n              imageId: anchor.medium.index,\n              range: anchor.range,\n              hyperlinks: anchor.picture.hyperlinks,\n            };\n            model.media.push(image);\n          }\n        });\n      }\n    }\n\n    const backgroundRel = model.background && rels[model.background.rId];\n    if (backgroundRel) {\n      const target = backgroundRel.Target.split('/media/')[1];\n      const imageId = options.mediaIndex && options.mediaIndex[target];\n      if (imageId !== undefined) {\n        model.media.push({\n          type: 'background',\n          imageId,\n        });\n      }\n    }\n\n    model.tables = (model.tables || []).map(tablePart => {\n      const rel = rels[tablePart.rId];\n      return options.tables[rel.Target];\n    });\n\n    delete model.relationships;\n    delete model.hyperlinks;\n    delete model.comments;\n  }\n}\n\nWorkSheetXform.WORKSHEET_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'x14ac',\n  'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',\n};\n\nmodule.exports = WorkSheetXform;\n","\n\nmodule.exports = {\n  OfficeDocument:\n    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',\n  Worksheet: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',\n  CalcChain: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain',\n  SharedStrings:\n    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',\n  Styles: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',\n  Theme: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',\n  Hyperlink: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',\n  Image: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',\n  CoreProperties:\n    'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',\n  ExtenderProperties:\n    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',\n  Comments: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',\n  VmlDrawing: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',\n  Table: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',\n};\n","const _ = require('../../../utils/under-dash');\n\nconst Range = require('../../../doc/range');\nconst colCache = require('../../../utils/col-cache');\nconst Enums = require('../../../doc/enums');\n\nclass Merges {\n  constructor() {\n    // optional mergeCells is array of ranges (like the xml)\n    this.merges = {};\n  }\n\n  add(merge) {\n    // merge is {address, master}\n    if (this.merges[merge.master]) {\n      this.merges[merge.master].expandToAddress(merge.address);\n    } else {\n      const range = `${merge.master}:${merge.address}`;\n      this.merges[merge.master] = new Range(range);\n    }\n  }\n\n  get mergeCells() {\n    return _.map(this.merges, merge => merge.range);\n  }\n\n  reconcile(mergeCells, rows) {\n    // reconcile merge list with merge cells\n    _.each(mergeCells, merge => {\n      const dimensions = colCache.decode(merge);\n      for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n        const row = rows[i - 1];\n        for (let j = dimensions.left; j <= dimensions.right; j++) {\n          const cell = row.cells[j - 1];\n          if (!cell) {\n            // nulls are not included in document - so if master cell has no value - add a null one here\n            row.cells[j] = {\n              type: Enums.ValueType.Null,\n              address: colCache.encodeAddress(i, j),\n            };\n          } else if (cell.type === Enums.ValueType.Merge) {\n            cell.master = dimensions.tl;\n          }\n        }\n      }\n    });\n  }\n\n  getMasterAddress(address) {\n    // if address has been merged, return its master's address. Assumes reconcile has been called\n    const range = this.hash[address];\n    return range && range.tl;\n  }\n}\n\nmodule.exports = Merges;\n","const BaseXform = require('../base-xform');\nconst utils = require('../../../utils/utils');\n\nconst CellXform = require('./cell-xform');\n\nclass RowXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.maxItems = options && options.maxItems;\n    this.map = {\n      c: new CellXform(),\n    };\n  }\n\n  get tag() {\n    return 'row';\n  }\n\n  prepare(model, options) {\n    const styleId = options.styles.addStyleModel(model.style);\n    if (styleId) {\n      model.styleId = styleId;\n    }\n    const cellXform = this.map.c;\n    model.cells.forEach(cellModel => {\n      cellXform.prepare(cellModel, options);\n    });\n  }\n\n  render(xmlStream, model, options) {\n    xmlStream.openNode('row');\n    xmlStream.addAttribute('r', model.number);\n    if (model.height) {\n      xmlStream.addAttribute('ht', model.height);\n      xmlStream.addAttribute('customHeight', '1');\n    }\n    if (model.hidden) {\n      xmlStream.addAttribute('hidden', '1');\n    }\n    if (model.min > 0 && model.max > 0 && model.min <= model.max) {\n      xmlStream.addAttribute('spans', `${model.min}:${model.max}`);\n    }\n    if (model.styleId) {\n      xmlStream.addAttribute('s', model.styleId);\n      xmlStream.addAttribute('customFormat', '1');\n    }\n    xmlStream.addAttribute('x14ac:dyDescent', '0.25');\n    if (model.outlineLevel) {\n      xmlStream.addAttribute('outlineLevel', model.outlineLevel);\n    }\n    if (model.collapsed) {\n      xmlStream.addAttribute('collapsed', '1');\n    }\n\n    const cellXform = this.map.c;\n    model.cells.forEach(cellModel => {\n      cellXform.render(xmlStream, cellModel, options);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    if (node.name === 'row') {\n      this.numRowsSeen += 1;\n      const spans = node.attributes.spans\n        ? node.attributes.spans.split(':').map(span => parseInt(span, 10))\n        : [undefined, undefined];\n      const model = (this.model = {\n        number: parseInt(node.attributes.r, 10),\n        min: spans[0],\n        max: spans[1],\n        cells: [],\n      });\n      if (node.attributes.s) {\n        model.styleId = parseInt(node.attributes.s, 10);\n      }\n      if (utils.parseBoolean(node.attributes.hidden)) {\n        model.hidden = true;\n      }\n      if (utils.parseBoolean(node.attributes.bestFit)) {\n        model.bestFit = true;\n      }\n      if (node.attributes.ht) {\n        model.height = parseFloat(node.attributes.ht);\n      }\n      if (node.attributes.outlineLevel) {\n        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\n      }\n      if (utils.parseBoolean(node.attributes.collapsed)) {\n        model.collapsed = true;\n      }\n      return true;\n    }\n\n    this.parser = this.map[node.name];\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    return false;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.cells.push(this.parser.model);\n        if (this.maxItems && this.model.cells.length > this.maxItems) {\n          throw new Error(`Max column count (${this.maxItems}) exceeded`);\n        }\n        this.parser = undefined;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  reconcile(model, options) {\n    model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};\n    if (model.styleId !== undefined) {\n      model.styleId = undefined;\n    }\n\n    const cellXform = this.map.c;\n    model.cells.forEach(cellModel => {\n      cellXform.reconcile(cellModel, options);\n    });\n  }\n}\n\nmodule.exports = RowXform;\n","const utils = require('../../../utils/utils');\nconst BaseXform = require('../base-xform');\nconst Range = require('../../../doc/range');\nconst Enums = require('../../../doc/enums');\n\nconst RichTextXform = require('../strings/rich-text-xform');\n\nfunction getValueType(v) {\n  if (v === null || v === undefined) {\n    return Enums.ValueType.Null;\n  }\n  if (v instanceof String || typeof v === 'string') {\n    return Enums.ValueType.String;\n  }\n  if (typeof v === 'number') {\n    return Enums.ValueType.Number;\n  }\n  if (typeof v === 'boolean') {\n    return Enums.ValueType.Boolean;\n  }\n  if (v instanceof Date) {\n    return Enums.ValueType.Date;\n  }\n  if (v.text && v.hyperlink) {\n    return Enums.ValueType.Hyperlink;\n  }\n  if (v.formula) {\n    return Enums.ValueType.Formula;\n  }\n  if (v.error) {\n    return Enums.ValueType.Error;\n  }\n  throw new Error('I could not understand type of value');\n}\n\nfunction getEffectiveCellType(cell) {\n  switch (cell.type) {\n    case Enums.ValueType.Formula:\n      return getValueType(cell.result);\n    default:\n      return cell.type;\n  }\n}\n\nclass CellXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.richTextXForm = new RichTextXform();\n  }\n\n  get tag() {\n    return 'c';\n  }\n\n  prepare(model, options) {\n    const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));\n    if (styleId) {\n      model.styleId = styleId;\n    }\n\n    if (model.comment) {\n      options.comments.push({...model.comment, ref: model.address});\n    }\n\n    switch (model.type) {\n      case Enums.ValueType.String:\n      case Enums.ValueType.RichText:\n        if (options.sharedStrings) {\n          model.ssId = options.sharedStrings.add(model.value);\n        }\n        break;\n\n      case Enums.ValueType.Date:\n        if (options.date1904) {\n          model.date1904 = true;\n        }\n        break;\n\n      case Enums.ValueType.Hyperlink:\n        if (options.sharedStrings && model.text !== undefined && model.text !== null) {\n          model.ssId = options.sharedStrings.add(model.text);\n        }\n        options.hyperlinks.push({\n          address: model.address,\n          target: model.hyperlink,\n          tooltip: model.tooltip,\n        });\n        break;\n\n      case Enums.ValueType.Merge:\n        options.merges.add(model);\n        break;\n\n      case Enums.ValueType.Formula:\n        if (options.date1904) {\n          // in case valueType is date\n          model.date1904 = true;\n        }\n\n        if (model.shareType === 'shared') {\n          model.si = options.siFormulae++;\n        }\n\n        if (model.formula) {\n          options.formulae[model.address] = model;\n        } else if (model.sharedFormula) {\n          const master = options.formulae[model.sharedFormula];\n          if (!master) {\n            throw new Error(\n              `Shared Formula master must exist above and or left of clone for cell ${model.address}`\n            );\n          }\n          if (master.si === undefined) {\n            master.shareType = 'shared';\n            master.si = options.siFormulae++;\n            master.range = new Range(master.address, model.address);\n          } else if (master.range) {\n            master.range.expandToAddress(model.address);\n          }\n          model.si = master.si;\n        }\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  renderFormula(xmlStream, model) {\n    let attrs = null;\n    switch (model.shareType) {\n      case 'shared':\n        attrs = {\n          t: 'shared',\n          ref: model.ref || model.range.range,\n          si: model.si,\n        };\n        break;\n\n      case 'array':\n        attrs = {\n          t: 'array',\n          ref: model.ref,\n        };\n        break;\n\n      default:\n        if (model.si !== undefined) {\n          attrs = {\n            t: 'shared',\n            si: model.si,\n          };\n        }\n        break;\n    }\n\n    switch (getValueType(model.result)) {\n      case Enums.ValueType.Null: // ?\n        xmlStream.leafNode('f', attrs, model.formula);\n        break;\n\n      case Enums.ValueType.String:\n        // oddly, formula results don't ever use shared strings\n        xmlStream.addAttribute('t', 'str');\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result);\n        break;\n\n      case Enums.ValueType.Number:\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result);\n        break;\n\n      case Enums.ValueType.Boolean:\n        xmlStream.addAttribute('t', 'b');\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result ? 1 : 0);\n        break;\n\n      case Enums.ValueType.Error:\n        xmlStream.addAttribute('t', 'e');\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, model.result.error);\n        break;\n\n      case Enums.ValueType.Date:\n        xmlStream.leafNode('f', attrs, model.formula);\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.result, model.date1904));\n        break;\n\n      // case Enums.ValueType.Hyperlink: // ??\n      // case Enums.ValueType.Formula:\n      default:\n        throw new Error('I could not understand type of value');\n    }\n  }\n\n  render(xmlStream, model) {\n    if (model.type === Enums.ValueType.Null && !model.styleId) {\n      // if null and no style, exit\n      return;\n    }\n\n    xmlStream.openNode('c');\n    xmlStream.addAttribute('r', model.address);\n\n    if (model.styleId) {\n      xmlStream.addAttribute('s', model.styleId);\n    }\n\n    switch (model.type) {\n      case Enums.ValueType.Null:\n        break;\n\n      case Enums.ValueType.Number:\n        xmlStream.leafNode('v', null, model.value);\n        break;\n\n      case Enums.ValueType.Boolean:\n        xmlStream.addAttribute('t', 'b');\n        xmlStream.leafNode('v', null, model.value ? '1' : '0');\n        break;\n\n      case Enums.ValueType.Error:\n        xmlStream.addAttribute('t', 'e');\n        xmlStream.leafNode('v', null, model.value.error);\n        break;\n\n      case Enums.ValueType.String:\n      case Enums.ValueType.RichText:\n        if (model.ssId !== undefined) {\n          xmlStream.addAttribute('t', 's');\n          xmlStream.leafNode('v', null, model.ssId);\n        } else if (model.value && model.value.richText) {\n          xmlStream.addAttribute('t', 'inlineStr');\n          xmlStream.openNode('is');\n          model.value.richText.forEach(text => {\n            this.richTextXForm.render(xmlStream, text);\n          });\n          xmlStream.closeNode('is');\n        } else {\n          xmlStream.addAttribute('t', 'str');\n          xmlStream.leafNode('v', null, model.value);\n        }\n        break;\n\n      case Enums.ValueType.Date:\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.value, model.date1904));\n        break;\n\n      case Enums.ValueType.Hyperlink:\n        if (model.ssId !== undefined) {\n          xmlStream.addAttribute('t', 's');\n          xmlStream.leafNode('v', null, model.ssId);\n        } else {\n          xmlStream.addAttribute('t', 'str');\n          xmlStream.leafNode('v', null, model.text);\n        }\n        break;\n\n      case Enums.ValueType.Formula:\n        this.renderFormula(xmlStream, model);\n        break;\n\n      case Enums.ValueType.Merge:\n        // nothing to add\n        break;\n\n      default:\n        break;\n    }\n\n    xmlStream.closeNode(); // </c>\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'c':\n        // const address = colCache.decodeAddress(node.attributes.r);\n        this.model = {\n          address: node.attributes.r,\n        };\n        this.t = node.attributes.t;\n        if (node.attributes.s) {\n          this.model.styleId = parseInt(node.attributes.s, 10);\n        }\n        return true;\n\n      case 'f':\n        this.currentNode = 'f';\n        this.model.si = node.attributes.si;\n        this.model.shareType = node.attributes.t;\n        this.model.ref = node.attributes.ref;\n        return true;\n\n      case 'v':\n        this.currentNode = 'v';\n        return true;\n\n      case 't':\n        this.currentNode = 't';\n        return true;\n\n      case 'r':\n        this.parser = this.richTextXForm;\n        this.parser.parseOpen(node);\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n      return;\n    }\n    switch (this.currentNode) {\n      case 'f':\n        this.model.formula = this.model.formula ? this.model.formula + text : text;\n        break;\n      case 'v':\n      case 't':\n        if (this.model.value && this.model.value.richText) {\n          this.model.value.richText.text = this.model.value.richText.text\n            ? this.model.value.richText.text + text\n            : text;\n        } else {\n          this.model.value = this.model.value ? this.model.value + text : text;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  parseClose(name) {\n    switch (name) {\n      case 'c': {\n        const {model} = this;\n\n        // first guess on cell type\n        if (model.formula || model.shareType) {\n          model.type = Enums.ValueType.Formula;\n          if (model.value) {\n            if (this.t === 'str') {\n              model.result = utils.xmlDecode(model.value);\n            } else if (this.t === 'b') {\n              model.result = parseInt(model.value, 10) !== 0;\n            } else if (this.t === 'e') {\n              model.result = {error: model.value};\n            } else {\n              model.result = parseFloat(model.value);\n            }\n            model.value = undefined;\n          }\n        } else if (model.value !== undefined) {\n          switch (this.t) {\n            case 's':\n              model.type = Enums.ValueType.String;\n              model.value = parseInt(model.value, 10);\n              break;\n            case 'str':\n              model.type = Enums.ValueType.String;\n              model.value = utils.xmlDecode(model.value);\n              break;\n            case 'inlineStr':\n              model.type = Enums.ValueType.String;\n              break;\n            case 'b':\n              model.type = Enums.ValueType.Boolean;\n              model.value = parseInt(model.value, 10) !== 0;\n              break;\n            case 'e':\n              model.type = Enums.ValueType.Error;\n              model.value = {error: model.value};\n              break;\n            default:\n              model.type = Enums.ValueType.Number;\n              model.value = parseFloat(model.value);\n              break;\n          }\n        } else if (model.styleId) {\n          model.type = Enums.ValueType.Null;\n        } else {\n          model.type = Enums.ValueType.Merge;\n        }\n        return false;\n      }\n\n      case 'f':\n      case 'v':\n      case 'is':\n        this.currentNode = undefined;\n        return true;\n\n      case 't':\n        if (this.parser) {\n          this.parser.parseClose(name);\n          return true;\n        }\n        this.currentNode = undefined;\n        return true;\n\n      case 'r':\n        this.model.value = this.model.value || {};\n        this.model.value.richText = this.model.value.richText || [];\n        this.model.value.richText.push(this.parser.model);\n        this.parser = undefined;\n        this.currentNode = undefined;\n        return true;\n\n      default:\n        if (this.parser) {\n          this.parser.parseClose(name);\n          return true;\n        }\n        return false;\n    }\n  }\n\n  reconcile(model, options) {\n    const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);\n    if (style) {\n      model.style = style;\n    }\n    if (model.styleId !== undefined) {\n      model.styleId = undefined;\n    }\n\n    switch (model.type) {\n      case Enums.ValueType.String:\n        if (typeof model.value === 'number') {\n          if (options.sharedStrings) {\n            model.value = options.sharedStrings.getString(model.value);\n          }\n        }\n        if (model.value.richText) {\n          model.type = Enums.ValueType.RichText;\n        }\n        break;\n\n      case Enums.ValueType.Number:\n        if (style && utils.isDateFmt(style.numFmt)) {\n          model.type = Enums.ValueType.Date;\n          model.value = utils.excelToDate(model.value, options.date1904);\n        }\n        break;\n\n      case Enums.ValueType.Formula:\n        if (model.result !== undefined && style && utils.isDateFmt(style.numFmt)) {\n          model.result = utils.excelToDate(model.result, options.date1904);\n        }\n        if (model.shareType === 'shared') {\n          if (model.ref) {\n            // master\n            options.formulae[model.si] = model.address;\n          } else {\n            // slave\n            model.sharedFormula = options.formulae[model.si];\n            delete model.shareType;\n          }\n          delete model.si;\n        }\n        break;\n\n      default:\n        break;\n    }\n\n    // look for hyperlink\n    const hyperlink = options.hyperlinkMap[model.address];\n    if (hyperlink) {\n      if (model.type === Enums.ValueType.Formula) {\n        model.text = model.result;\n        model.result = undefined;\n      } else {\n        model.text = model.value;\n        model.value = undefined;\n      }\n      model.type = Enums.ValueType.Hyperlink;\n      model.hyperlink = hyperlink;\n    }\n\n    const comment = options.commentsMap && options.commentsMap[model.address];\n    if (comment) {\n      model.comment = comment;\n    }\n  }\n}\n\nmodule.exports = CellXform;\n","const utils = require('../../../utils/utils');\nconst BaseXform = require('../base-xform');\n\nclass ColXform extends BaseXform {\n  get tag() {\n    return 'col';\n  }\n\n  prepare(model, options) {\n    const styleId = options.styles.addStyleModel(model.style || {});\n    if (styleId) {\n      model.styleId = styleId;\n    }\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('col');\n    xmlStream.addAttribute('min', model.min);\n    xmlStream.addAttribute('max', model.max);\n    if (model.width) {\n      xmlStream.addAttribute('width', model.width);\n    }\n    if (model.styleId) {\n      xmlStream.addAttribute('style', model.styleId);\n    }\n    if (model.hidden) {\n      xmlStream.addAttribute('hidden', '1');\n    }\n    if (model.bestFit) {\n      xmlStream.addAttribute('bestFit', '1');\n    }\n    if (model.outlineLevel) {\n      xmlStream.addAttribute('outlineLevel', model.outlineLevel);\n    }\n    if (model.collapsed) {\n      xmlStream.addAttribute('collapsed', '1');\n    }\n    xmlStream.addAttribute('customWidth', '1');\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (node.name === 'col') {\n      const model = (this.model = {\n        min: parseInt(node.attributes.min || '0', 10),\n        max: parseInt(node.attributes.max || '0', 10),\n        width:\n          node.attributes.width === undefined\n            ? undefined\n            : parseFloat(node.attributes.width || '0'),\n      });\n      if (node.attributes.style) {\n        model.styleId = parseInt(node.attributes.style, 10);\n      }\n      if (utils.parseBoolean(node.attributes.hidden)) {\n        model.hidden = true;\n      }\n      if (utils.parseBoolean(node.attributes.bestFit)) {\n        model.bestFit = true;\n      }\n      if (node.attributes.outlineLevel) {\n        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\n      }\n      if (utils.parseBoolean(node.attributes.collapsed)) {\n        model.collapsed = true;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n\n  reconcile(model, options) {\n    // reconcile column styles\n    if (model.styleId) {\n      model.style = options.styles.getStyleModel(model.styleId);\n    }\n  }\n}\n\nmodule.exports = ColXform;\n","const BaseXform = require('../base-xform');\n\nclass DimensionXform extends BaseXform {\n  get tag() {\n    return 'dimension';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.leafNode('dimension', {ref: model});\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === 'dimension') {\n      this.model = node.attributes.ref;\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = DimensionXform;\n","const BaseXform = require('../base-xform');\n\nclass HyperlinkXform extends BaseXform {\n  get tag() {\n    return 'hyperlink';\n  }\n\n  render(xmlStream, model) {\n    if (this.isInternalLink(model)) {\n      xmlStream.leafNode('hyperlink', {\n        ref: model.address,\n        'r:id': model.rId,\n        tooltip: model.tooltip,\n        location: model.target,\n      });\n    } else {\n      xmlStream.leafNode('hyperlink', {\n        ref: model.address,\n        'r:id': model.rId,\n        tooltip: model.tooltip,\n      });\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === 'hyperlink') {\n      this.model = {\n        address: node.attributes.ref,\n        rId: node.attributes['r:id'],\n        tooltip: node.attributes.tooltip,\n      };\n\n      // This is an internal link\n      if (node.attributes.location) {\n        this.model.target = node.attributes.location;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n\n  isInternalLink(model) {\n    // @example: Sheet2!D3, return true\n    return model.target && /^[^!]+![a-zA-Z]+[\\d]+$/.test(model.target);\n  }\n}\n\nmodule.exports = HyperlinkXform;\n","const BaseXform = require('../base-xform');\n\nclass MergeCellXform extends BaseXform {\n  get tag() {\n    return 'mergeCell';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode('mergeCell', {ref: model});\n  }\n\n  parseOpen(node) {\n    if (node.name === 'mergeCell') {\n      this.model = node.attributes.ref;\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = MergeCellXform;\n","const _ = require('../../../utils/under-dash');\nconst utils = require('../../../utils/utils');\nconst colCache = require('../../../utils/col-cache');\nconst BaseXform = require('../base-xform');\nconst Range = require('../../../doc/range');\n\nfunction assign(definedName, attributes, name, defaultValue) {\n  const value = attributes[name];\n  if (value !== undefined) {\n    definedName[name] = value;\n  } else if (defaultValue !== undefined) {\n    definedName[name] = defaultValue;\n  }\n}\n\nfunction assignBool(definedName, attributes, name, defaultValue) {\n  const value = attributes[name];\n  if (value !== undefined) {\n    definedName[name] = utils.parseBoolean(value);\n  } else if (defaultValue !== undefined) {\n    definedName[name] = defaultValue;\n  }\n}\n\nfunction optimiseDataValidations(model) {\n  // Squeeze alike data validations together into rectangular ranges\n  // to reduce file size and speed up Excel load time\n  const dvList = _.map(model, (dataValidation, address) => ({\n    address,\n    dataValidation,\n    marked: false,\n  })).sort((a, b) => _.strcmp(a.address, b.address));\n  const dvMap = _.keyBy(dvList, 'address');\n  const matchCol = (addr, height, col) => {\n    for (let i = 0; i < height; i++) {\n      const otherAddress = colCache.encodeAddress(addr.row + i, col);\n      if (!model[otherAddress] || !_.isEqual(model[addr.address], model[otherAddress])) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return dvList\n    .map(dv => {\n      if (!dv.marked) {\n        const addr = colCache.decodeEx(dv.address);\n        if (addr.dimensions) {\n          dvMap[addr.dimensions].marked = true;\n          return {\n            ...dv.dataValidation,\n            sqref: dv.address,\n          };\n        }\n\n        // iterate downwards - finding matching cells\n        let height = 1;\n        let otherAddress = colCache.encodeAddress(addr.row + height, addr.col);\n        while (model[otherAddress] && _.isEqual(dv.dataValidation, model[otherAddress])) {\n          height++;\n          otherAddress = colCache.encodeAddress(addr.row + height, addr.col);\n        }\n\n        // iterate rightwards...\n\n        let width = 1;\n        while (matchCol(addr, height, addr.col + width)) {\n          width++;\n        }\n\n        // mark all included addresses\n        for (let i = 0; i < height; i++) {\n          for (let j = 0; j < width; j++) {\n            otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);\n            dvMap[otherAddress].marked = true;\n          }\n        }\n\n        if (height > 1 || width > 1) {\n          const bottom = addr.row + (height - 1);\n          const right = addr.col + (width - 1);\n          return {\n            ...dv.dataValidation,\n            sqref: `${dv.address}:${colCache.encodeAddress(bottom, right)}`,\n          };\n        }\n        return {\n          ...dv.dataValidation,\n          sqref: dv.address,\n        };\n      }\n      return null;\n    })\n    .filter(Boolean);\n}\n\nclass DataValidationsXform extends BaseXform {\n  get tag() {\n    return 'dataValidations';\n  }\n\n  render(xmlStream, model) {\n    const optimizedModel = optimiseDataValidations(model);\n    if (optimizedModel.length) {\n      xmlStream.openNode('dataValidations', {count: optimizedModel.length});\n\n      optimizedModel.forEach(value => {\n        xmlStream.openNode('dataValidation');\n\n        if (value.type !== 'any') {\n          xmlStream.addAttribute('type', value.type);\n\n          if (value.operator && value.type !== 'list' && value.operator !== 'between') {\n            xmlStream.addAttribute('operator', value.operator);\n          }\n          if (value.allowBlank) {\n            xmlStream.addAttribute('allowBlank', '1');\n          }\n        }\n        if (value.showInputMessage) {\n          xmlStream.addAttribute('showInputMessage', '1');\n        }\n        if (value.promptTitle) {\n          xmlStream.addAttribute('promptTitle', value.promptTitle);\n        }\n        if (value.prompt) {\n          xmlStream.addAttribute('prompt', value.prompt);\n        }\n        if (value.showErrorMessage) {\n          xmlStream.addAttribute('showErrorMessage', '1');\n        }\n        if (value.errorStyle) {\n          xmlStream.addAttribute('errorStyle', value.errorStyle);\n        }\n        if (value.errorTitle) {\n          xmlStream.addAttribute('errorTitle', value.errorTitle);\n        }\n        if (value.error) {\n          xmlStream.addAttribute('error', value.error);\n        }\n        xmlStream.addAttribute('sqref', value.sqref);\n        (value.formulae || []).forEach((formula, index) => {\n          xmlStream.openNode(`formula${index + 1}`);\n          if (value.type === 'date') {\n            xmlStream.writeText(utils.dateToExcel(new Date(formula)));\n          } else {\n            xmlStream.writeText(formula);\n          }\n          xmlStream.closeNode();\n        });\n        xmlStream.closeNode();\n      });\n      xmlStream.closeNode();\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'dataValidations':\n        this.model = {};\n        return true;\n\n      case 'dataValidation': {\n        this._address = node.attributes.sqref;\n        const dataValidation = {type: node.attributes.type || 'any', formulae: []};\n\n        if (node.attributes.type) {\n          assignBool(dataValidation, node.attributes, 'allowBlank');\n        }\n        assignBool(dataValidation, node.attributes, 'showInputMessage');\n        assignBool(dataValidation, node.attributes, 'showErrorMessage');\n\n        switch (dataValidation.type) {\n          case 'any':\n          case 'list':\n          case 'custom':\n            break;\n          default:\n            assign(dataValidation, node.attributes, 'operator', 'between');\n            break;\n        }\n        assign(dataValidation, node.attributes, 'promptTitle');\n        assign(dataValidation, node.attributes, 'prompt');\n        assign(dataValidation, node.attributes, 'errorStyle');\n        assign(dataValidation, node.attributes, 'errorTitle');\n        assign(dataValidation, node.attributes, 'error');\n\n        this._dataValidation = dataValidation;\n        return true;\n      }\n\n      case 'formula1':\n      case 'formula2':\n        this._formula = [];\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this._formula) {\n      this._formula.push(text);\n    }\n  }\n\n  parseClose(name) {\n    switch (name) {\n      case 'dataValidations':\n        return false;\n      case 'dataValidation': {\n        if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {\n          delete this._dataValidation.formulae;\n          delete this._dataValidation.operator;\n        }\n        // The four known cases: 1. E4:L9 N4:U9  2.E4 L9  3. N4:U9  4. E4\n        const list = this._address.split(/\\s+/g) || [];\n        list.forEach(addr => {\n          if (addr.includes(':')) {\n            const range = new Range(addr);\n            range.forEachAddress(address => {\n              this.model[address] = this._dataValidation;\n            });\n          } else {\n            this.model[addr] = this._dataValidation;\n          }\n        });\n        return true;\n      }\n      case 'formula1':\n      case 'formula2': {\n        let formula = this._formula.join('');\n        switch (this._dataValidation.type) {\n          case 'whole':\n          case 'textLength':\n            formula = parseInt(formula, 10);\n            break;\n          case 'decimal':\n            formula = parseFloat(formula);\n            break;\n          case 'date':\n            formula = utils.excelToDate(parseFloat(formula));\n            break;\n          default:\n            break;\n        }\n        this._dataValidation.formulae.push(formula);\n        this._formula = undefined;\n        return true;\n      }\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = DataValidationsXform;\n","const BaseXform = require('../base-xform');\nconst ColorXform = require('../style/color-xform');\nconst PageSetupPropertiesXform = require('./page-setup-properties-xform');\nconst OutlinePropertiesXform = require('./outline-properties-xform');\n\nclass SheetPropertiesXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      tabColor: new ColorXform('tabColor'),\n      pageSetUpPr: new PageSetupPropertiesXform(),\n      outlinePr: new OutlinePropertiesXform(),\n    };\n  }\n\n  get tag() {\n    return 'sheetPr';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.addRollback();\n      xmlStream.openNode('sheetPr');\n\n      let inner = false;\n      inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;\n      inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;\n      inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;\n\n      if (inner) {\n        xmlStream.closeNode();\n        xmlStream.commit();\n      } else {\n        xmlStream.rollback();\n      }\n    }\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    if (node.name === this.tag) {\n      this.reset();\n      return true;\n    }\n    if (this.map[node.name]) {\n      this.parser = this.map[node.name];\n      this.parser.parseOpen(node);\n      return true;\n    }\n    return false;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n      return true;\n    }\n    return false;\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {\n      this.model = {};\n      if (this.map.tabColor.model) {\n        this.model.tabColor = this.map.tabColor.model;\n      }\n      if (this.map.pageSetUpPr.model) {\n        this.model.pageSetup = this.map.pageSetUpPr.model;\n      }\n      if (this.map.outlinePr.model) {\n        this.model.outlineProperties = this.map.outlinePr.model;\n      }\n    } else {\n      this.model = null;\n    }\n    return false;\n  }\n}\n\nmodule.exports = SheetPropertiesXform;\n","const BaseXform = require('../base-xform');\n\nclass PageSetupPropertiesXform extends BaseXform {\n  get tag() {\n    return 'pageSetUpPr';\n  }\n\n  render(xmlStream, model) {\n    if (model && model.fitToPage) {\n      xmlStream.leafNode(this.tag, {\n        fitToPage: model.fitToPage ? '1' : undefined,\n      });\n      return true;\n    }\n    return false;\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      this.model = {\n        fitToPage: node.attributes.fitToPage === '1',\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = PageSetupPropertiesXform;\n","const BaseXform = require('../base-xform');\n\nconst isDefined = attr => typeof attr !== 'undefined';\n\nclass OutlinePropertiesXform extends BaseXform {\n  get tag() {\n    return 'outlinePr';\n  }\n\n  render(xmlStream, model) {\n    if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {\n      xmlStream.leafNode(this.tag, {\n        summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : undefined,\n        summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : undefined,\n      });\n      return true;\n    }\n    return false;\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      this.model = {\n        summaryBelow: isDefined(node.attributes.summaryBelow)\n          ? Boolean(Number(node.attributes.summaryBelow))\n          : undefined,\n        summaryRight: isDefined(node.attributes.summaryRight)\n          ? Boolean(Number(node.attributes.summaryRight))\n          : undefined,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = OutlinePropertiesXform;\n","const _ = require('../../../utils/under-dash');\nconst BaseXform = require('../base-xform');\n\nclass SheetFormatPropertiesXform extends BaseXform {\n  get tag() {\n    return 'sheetFormatPr';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      const attributes = {\n        defaultRowHeight: model.defaultRowHeight,\n        outlineLevelRow: model.outlineLevelRow,\n        outlineLevelCol: model.outlineLevelCol,\n        'x14ac:dyDescent': model.dyDescent,\n      };\n      if (model.defaultColWidth) {\n        attributes.defaultColWidth = model.defaultColWidth;\n      }\n\n      // default value for 'defaultRowHeight' is 15, this should not be 'custom'\n      if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {\n        attributes.customHeight = '1';\n      }\n\n      if (_.some(attributes, value => value !== undefined)) {\n        xmlStream.leafNode('sheetFormatPr', attributes);\n      }\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === 'sheetFormatPr') {\n      this.model = {\n        defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || '0'),\n        dyDescent: parseFloat(node.attributes['x14ac:dyDescent'] || '0'),\n        outlineLevelRow: parseInt(node.attributes.outlineLevelRow || '0', 10),\n        outlineLevelCol: parseInt(node.attributes.outlineLevelCol || '0', 10),\n      };\n      if (node.attributes.defaultColWidth) {\n        this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = SheetFormatPropertiesXform;\n","const colCache = require('../../../utils/col-cache');\nconst BaseXform = require('../base-xform');\n\nconst VIEW_STATES = {\n  frozen: 'frozen',\n  frozenSplit: 'frozen',\n  split: 'split',\n};\n\nclass SheetViewXform extends BaseXform {\n  get tag() {\n    return 'sheetView';\n  }\n\n  prepare(model) {\n    switch (model.state) {\n      case 'frozen':\n      case 'split':\n        break;\n      default:\n        model.state = 'normal';\n        break;\n    }\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('sheetView', {\n      workbookViewId: model.workbookViewId || 0,\n    });\n    const add = function(name, value, included) {\n      if (included) {\n        xmlStream.addAttribute(name, value);\n      }\n    };\n    add('rightToLeft', '1', model.rightToLeft === true);\n    add('tabSelected', '1', model.tabSelected);\n    add('showRuler', '0', model.showRuler === false);\n    add('showRowColHeaders', '0', model.showRowColHeaders === false);\n    add('showGridLines', '0', model.showGridLines === false);\n    add('zoomScale', model.zoomScale, model.zoomScale);\n    add('zoomScaleNormal', model.zoomScaleNormal, model.zoomScaleNormal);\n    add('view', model.style, model.style);\n\n    let topLeftCell;\n    let xSplit;\n    let ySplit;\n    let activePane;\n    switch (model.state) {\n      case 'frozen':\n        xSplit = model.xSplit || 0;\n        ySplit = model.ySplit || 0;\n        topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;\n        activePane =\n          (model.xSplit && model.ySplit && 'bottomRight') ||\n          (model.xSplit && 'topRight') ||\n          'bottomLeft';\n\n        xmlStream.leafNode('pane', {\n          xSplit: model.xSplit || undefined,\n          ySplit: model.ySplit || undefined,\n          topLeftCell,\n          activePane,\n          state: 'frozen',\n        });\n        xmlStream.leafNode('selection', {\n          pane: activePane,\n          activeCell: model.activeCell,\n          sqref: model.activeCell,\n        });\n        break;\n      case 'split':\n        if (model.activePane === 'topLeft') {\n          model.activePane = undefined;\n        }\n        xmlStream.leafNode('pane', {\n          xSplit: model.xSplit || undefined,\n          ySplit: model.ySplit || undefined,\n          topLeftCell: model.topLeftCell,\n          activePane: model.activePane,\n        });\n        xmlStream.leafNode('selection', {\n          pane: model.activePane,\n          activeCell: model.activeCell,\n          sqref: model.activeCell,\n        });\n        break;\n      case 'normal':\n        if (model.activeCell) {\n          xmlStream.leafNode('selection', {\n            activeCell: model.activeCell,\n            sqref: model.activeCell,\n          });\n        }\n        break;\n      default:\n        break;\n    }\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'sheetView':\n        this.sheetView = {\n          workbookViewId: parseInt(node.attributes.workbookViewId, 10),\n          rightToLeft: node.attributes.rightToLeft === '1',\n          tabSelected: node.attributes.tabSelected === '1',\n          showRuler: !(node.attributes.showRuler === '0'),\n          showRowColHeaders: !(node.attributes.showRowColHeaders === '0'),\n          showGridLines: !(node.attributes.showGridLines === '0'),\n          zoomScale: parseInt(node.attributes.zoomScale || '100', 10),\n          zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || '100', 10),\n          style: node.attributes.view,\n        };\n        this.pane = undefined;\n        this.selections = {};\n        return true;\n\n      case 'pane':\n        this.pane = {\n          xSplit: parseInt(node.attributes.xSplit || '0', 10),\n          ySplit: parseInt(node.attributes.ySplit || '0', 10),\n          topLeftCell: node.attributes.topLeftCell,\n          activePane: node.attributes.activePane || 'topLeft',\n          state: node.attributes.state,\n        };\n        return true;\n\n      case 'selection': {\n        const name = node.attributes.pane || 'topLeft';\n        this.selections[name] = {\n          pane: name,\n          activeCell: node.attributes.activeCell,\n        };\n        return true;\n      }\n\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    let model;\n    let selection;\n    switch (name) {\n      case 'sheetView':\n        if (this.sheetView && this.pane) {\n          model = this.model = {\n            workbookViewId: this.sheetView.workbookViewId,\n            rightToLeft: this.sheetView.rightToLeft,\n            state: VIEW_STATES[this.pane.state] || 'split', // split is default\n            xSplit: this.pane.xSplit,\n            ySplit: this.pane.ySplit,\n            topLeftCell: this.pane.topLeftCell,\n            showRuler: this.sheetView.showRuler,\n            showRowColHeaders: this.sheetView.showRowColHeaders,\n            showGridLines: this.sheetView.showGridLines,\n            zoomScale: this.sheetView.zoomScale,\n            zoomScaleNormal: this.sheetView.zoomScaleNormal,\n          };\n          if (this.model.state === 'split') {\n            model.activePane = this.pane.activePane;\n          }\n          selection = this.selections[this.pane.activePane];\n          if (selection && selection.activeCell) {\n            model.activeCell = selection.activeCell;\n          }\n          if (this.sheetView.style) {\n            model.style = this.sheetView.style;\n          }\n        } else {\n          model = this.model = {\n            workbookViewId: this.sheetView.workbookViewId,\n            rightToLeft: this.sheetView.rightToLeft,\n            state: 'normal',\n            showRuler: this.sheetView.showRuler,\n            showRowColHeaders: this.sheetView.showRowColHeaders,\n            showGridLines: this.sheetView.showGridLines,\n            zoomScale: this.sheetView.zoomScale,\n            zoomScaleNormal: this.sheetView.zoomScaleNormal,\n          };\n          selection = this.selections.topLeft;\n          if (selection && selection.activeCell) {\n            model.activeCell = selection.activeCell;\n          }\n          if (this.sheetView.style) {\n            model.style = this.sheetView.style;\n          }\n        }\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  reconcile() {}\n}\n\nmodule.exports = SheetViewXform;\n","const _ = require('../../../utils/under-dash');\nconst BaseXform = require('../base-xform');\n\nfunction booleanToXml(model, value) {\n  return model ? value : undefined;\n}\n\nfunction xmlToBoolean(value, equals) {\n  return value === equals ? true : undefined;\n}\n\nclass SheetProtectionXform extends BaseXform {\n  get tag() {\n    return 'sheetProtection';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      const attributes = {\n        sheet: booleanToXml(model.sheet, '1'),\n        selectLockedCells: model.selectLockedCells === false ? '1' : undefined,\n        selectUnlockedCells: model.selectUnlockedCells === false ? '1' : undefined,\n        formatCells: booleanToXml(model.formatCells, '0'),\n        formatColumns: booleanToXml(model.formatColumns, '0'),\n        formatRows: booleanToXml(model.formatRows, '0'),\n        insertColumns: booleanToXml(model.insertColumns, '0'),\n        insertRows: booleanToXml(model.insertRows, '0'),\n        insertHyperlinks: booleanToXml(model.insertHyperlinks, '0'),\n        deleteColumns: booleanToXml(model.deleteColumns, '0'),\n        deleteRows: booleanToXml(model.deleteRows, '0'),\n        sort: booleanToXml(model.sort, '0'),\n        autoFilter: booleanToXml(model.autoFilter, '0'),\n        pivotTables: booleanToXml(model.pivotTables, '0'),\n      };\n      if (model.sheet) {\n        attributes.algorithmName = model.algorithmName;\n        attributes.hashValue = model.hashValue;\n        attributes.saltValue = model.saltValue;\n        attributes.spinCount = model.spinCount;\n        attributes.objects = booleanToXml(model.objects === false, '1');\n        attributes.scenarios = booleanToXml(model.scenarios === false, '1');\n      }\n      if (_.some(attributes, value => value !== undefined)) {\n        xmlStream.leafNode(this.tag, attributes);\n      }\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          sheet: xmlToBoolean(node.attributes.sheet, '1'),\n          objects: node.attributes.objects === '1' ? false : undefined,\n          scenarios: node.attributes.scenarios === '1' ? false : undefined,\n          selectLockedCells: node.attributes.selectLockedCells === '1' ? false : undefined,\n          selectUnlockedCells: node.attributes.selectUnlockedCells === '1' ? false : undefined,\n          formatCells: xmlToBoolean(node.attributes.formatCells, '0'),\n          formatColumns: xmlToBoolean(node.attributes.formatColumns, '0'),\n          formatRows: xmlToBoolean(node.attributes.formatRows, '0'),\n          insertColumns: xmlToBoolean(node.attributes.insertColumns, '0'),\n          insertRows: xmlToBoolean(node.attributes.insertRows, '0'),\n          insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, '0'),\n          deleteColumns: xmlToBoolean(node.attributes.deleteColumns, '0'),\n          deleteRows: xmlToBoolean(node.attributes.deleteRows, '0'),\n          sort: xmlToBoolean(node.attributes.sort, '0'),\n          autoFilter: xmlToBoolean(node.attributes.autoFilter, '0'),\n          pivotTables: xmlToBoolean(node.attributes.pivotTables, '0'),\n        };\n        if (node.attributes.algorithmName) {\n          this.model.algorithmName = node.attributes.algorithmName;\n          this.model.hashValue = node.attributes.hashValue;\n          this.model.saltValue = node.attributes.saltValue;\n          this.model.spinCount = parseInt(node.attributes.spinCount, 10);\n        }\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = SheetProtectionXform;\n","const _ = require('../../../utils/under-dash');\nconst BaseXform = require('../base-xform');\n\nclass PageMarginsXform extends BaseXform {\n  get tag() {\n    return 'pageMargins';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      const attributes = {\n        left: model.left,\n        right: model.right,\n        top: model.top,\n        bottom: model.bottom,\n        header: model.header,\n        footer: model.footer,\n      };\n      if (_.some(attributes, value => value !== undefined)) {\n        xmlStream.leafNode(this.tag, attributes);\n      }\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          left: parseFloat(node.attributes.left || 0.7),\n          right: parseFloat(node.attributes.right || 0.7),\n          top: parseFloat(node.attributes.top || 0.75),\n          bottom: parseFloat(node.attributes.bottom || 0.75),\n          header: parseFloat(node.attributes.header || 0.3),\n          footer: parseFloat(node.attributes.footer || 0.3),\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = PageMarginsXform;\n","const _ = require('../../../utils/under-dash');\nconst BaseXform = require('../base-xform');\n\nfunction booleanToXml(model) {\n  return model ? '1' : undefined;\n}\nfunction pageOrderToXml(model) {\n  switch (model) {\n    case 'overThenDown':\n      return model;\n    default:\n      return undefined;\n  }\n}\nfunction cellCommentsToXml(model) {\n  switch (model) {\n    case 'atEnd':\n    case 'asDisplyed':\n      return model;\n    default:\n      return undefined;\n  }\n}\nfunction errorsToXml(model) {\n  switch (model) {\n    case 'dash':\n    case 'blank':\n    case 'NA':\n      return model;\n    default:\n      return undefined;\n  }\n}\nfunction pageSizeToModel(value) {\n  return value !== undefined ? parseInt(value, 10) : undefined;\n}\n\nclass PageSetupXform extends BaseXform {\n  get tag() {\n    return 'pageSetup';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      const attributes = {\n        paperSize: model.paperSize,\n        orientation: model.orientation,\n        horizontalDpi: model.horizontalDpi,\n        verticalDpi: model.verticalDpi,\n        pageOrder: pageOrderToXml(model.pageOrder),\n        blackAndWhite: booleanToXml(model.blackAndWhite),\n        draft: booleanToXml(model.draft),\n        cellComments: cellCommentsToXml(model.cellComments),\n        errors: errorsToXml(model.errors),\n        scale: model.scale,\n        fitToWidth: model.fitToWidth,\n        fitToHeight: model.fitToHeight,\n        firstPageNumber: model.firstPageNumber,\n        useFirstPageNumber: booleanToXml(model.firstPageNumber),\n        usePrinterDefaults: booleanToXml(model.usePrinterDefaults),\n        copies: model.copies,\n      };\n      if (_.some(attributes, value => value !== undefined)) {\n        xmlStream.leafNode(this.tag, attributes);\n      }\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          paperSize: pageSizeToModel(node.attributes.paperSize),\n          orientation: node.attributes.orientation || 'portrait',\n          horizontalDpi: parseInt(node.attributes.horizontalDpi || '4294967295', 10),\n          verticalDpi: parseInt(node.attributes.verticalDpi || '4294967295', 10),\n          pageOrder: node.attributes.pageOrder || 'downThenOver',\n          blackAndWhite: node.attributes.blackAndWhite === '1',\n          draft: node.attributes.draft === '1',\n          cellComments: node.attributes.cellComments || 'None',\n          errors: node.attributes.errors || 'displayed',\n          scale: parseInt(node.attributes.scale || '100', 10),\n          fitToWidth: parseInt(node.attributes.fitToWidth || '1', 10),\n          fitToHeight: parseInt(node.attributes.fitToHeight || '1', 10),\n          firstPageNumber: parseInt(node.attributes.firstPageNumber || '1', 10),\n          useFirstPageNumber: node.attributes.useFirstPageNumber === '1',\n          usePrinterDefaults: node.attributes.usePrinterDefaults === '1',\n          copies: parseInt(node.attributes.copies || '1', 10),\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = PageSetupXform;\n","const _ = require('../../../utils/under-dash');\nconst BaseXform = require('../base-xform');\n\nfunction booleanToXml(model) {\n  return model ? '1' : undefined;\n}\n\nclass PrintOptionsXform extends BaseXform {\n  get tag() {\n    return 'printOptions';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      const attributes = {\n        headings: booleanToXml(model.showRowColHeaders),\n        gridLines: booleanToXml(model.showGridLines),\n        horizontalCentered: booleanToXml(model.horizontalCentered),\n        verticalCentered: booleanToXml(model.verticalCentered),\n      };\n      if (_.some(attributes, value => value !== undefined)) {\n        xmlStream.leafNode(this.tag, attributes);\n      }\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          showRowColHeaders: node.attributes.headings === '1',\n          showGridLines: node.attributes.gridLines === '1',\n          horizontalCentered: node.attributes.horizontalCentered === '1',\n          verticalCentered: node.attributes.verticalCentered === '1',\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = PrintOptionsXform;\n","const colCache = require('../../../utils/col-cache');\nconst BaseXform = require('../base-xform');\n\nclass AutoFilterXform extends BaseXform {\n  get tag() {\n    return 'autoFilter';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      if (typeof model === 'string') {\n        // assume range\n        xmlStream.leafNode('autoFilter', {ref: model});\n      } else {\n        const getAddress = function(addr) {\n          if (typeof addr === 'string') {\n            return addr;\n          }\n          return colCache.getAddress(addr.row, addr.column).address;\n        };\n\n        const firstAddress = getAddress(model.from);\n        const secondAddress = getAddress(model.to);\n        if (firstAddress && secondAddress) {\n          xmlStream.leafNode('autoFilter', {ref: `${firstAddress}:${secondAddress}`});\n        }\n      }\n    }\n  }\n\n  parseOpen(node) {\n    if (node.name === 'autoFilter') {\n      this.model = node.attributes.ref;\n    }\n  }\n}\n\nmodule.exports = AutoFilterXform;\n","const BaseXform = require('../base-xform');\n\nclass PictureXform extends BaseXform {\n  get tag() {\n    return 'picture';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.leafNode(this.tag, {'r:id': model.rId});\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          rId: node.attributes['r:id'],\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = PictureXform;\n","const BaseXform = require('../base-xform');\n\nclass DrawingXform extends BaseXform {\n  get tag() {\n    return 'drawing';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.leafNode(this.tag, {'r:id': model.rId});\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          rId: node.attributes['r:id'],\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = DrawingXform;\n","const BaseXform = require('../base-xform');\n\nclass TablePartXform extends BaseXform {\n  get tag() {\n    return 'tablePart';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.leafNode(this.tag, {'r:id': model.rId});\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          rId: node.attributes['r:id'],\n        };\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = TablePartXform;\n","\n\nconst PageBreaksXform = require('./page-breaks-xform');\n\nconst ListXform = require('../list-xform');\n\nclass RowBreaksXform extends ListXform {\n  constructor() {\n    const options = {\n      tag: 'rowBreaks',\n      count: true,\n      childXform: new PageBreaksXform(),\n    };\n    super(options);\n  }\n\n  // get tag() { return 'rowBreaks'; }\n\n  render(xmlStream, model) {\n    if (model && model.length) {\n      xmlStream.openNode(this.tag, this.$);\n      if (this.count) {\n        xmlStream.addAttribute(this.$count, model.length);\n        xmlStream.addAttribute('manualBreakCount', model.length);\n      }\n\n      const {childXform} = this;\n      model.forEach(childModel => {\n        childXform.render(xmlStream, childModel);\n      });\n\n      xmlStream.closeNode();\n    } else if (this.empty) {\n      xmlStream.leafNode(this.tag);\n    }\n  }\n}\n\nmodule.exports = RowBreaksXform;\n","const BaseXform = require('../base-xform');\n\nclass PageBreaksXform extends BaseXform {\n  get tag() {\n    return 'brk';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode('brk', model);\n  }\n\n  parseOpen(node) {\n    if (node.name === 'brk') {\n      this.model = node.attributes.ref;\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = PageBreaksXform;\n","const BaseXform = require('../base-xform');\n\nclass HeaderFooterXform extends BaseXform {\n  get tag() {\n    return 'headerFooter';\n  }\n\n  render(xmlStream, model) {\n    if (model) {\n      xmlStream.addRollback();\n\n      let createTag = false;\n\n      xmlStream.openNode('headerFooter');\n      if (model.differentFirst) {\n        xmlStream.addAttribute('differentFirst', '1');\n        createTag = true;\n      }\n      if (model.differentOddEven) {\n        xmlStream.addAttribute('differentOddEven', '1');\n        createTag = true;\n      }\n      if (model.oddHeader && typeof model.oddHeader === 'string') {\n        xmlStream.leafNode('oddHeader', null, model.oddHeader);\n        createTag = true;\n      }\n      if (model.oddFooter && typeof model.oddFooter === 'string') {\n        xmlStream.leafNode('oddFooter', null, model.oddFooter);\n        createTag = true;\n      }\n      if (model.evenHeader && typeof model.evenHeader === 'string') {\n        xmlStream.leafNode('evenHeader', null, model.evenHeader);\n        createTag = true;\n      }\n      if (model.evenFooter && typeof model.evenFooter === 'string') {\n        xmlStream.leafNode('evenFooter', null, model.evenFooter);\n        createTag = true;\n      }\n      if (model.firstHeader && typeof model.firstHeader === 'string') {\n        xmlStream.leafNode('firstHeader', null, model.firstHeader);\n        createTag = true;\n      }\n      if (model.firstFooter && typeof model.firstFooter === 'string') {\n        xmlStream.leafNode('firstFooter', null, model.firstFooter);\n        createTag = true;\n      }\n\n      if (createTag) {\n        xmlStream.closeNode();\n        xmlStream.commit();\n      } else {\n        xmlStream.rollback();\n      }\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case 'headerFooter':\n        this.model = {};\n        if (node.attributes.differentFirst) {\n          this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;\n        }\n        if (node.attributes.differentOddEven) {\n          this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;\n        }\n        return true;\n\n      case 'oddHeader':\n        this.currentNode = 'oddHeader';\n        return true;\n\n      case 'oddFooter':\n        this.currentNode = 'oddFooter';\n        return true;\n\n      case 'evenHeader':\n        this.currentNode = 'evenHeader';\n        return true;\n\n      case 'evenFooter':\n        this.currentNode = 'evenFooter';\n        return true;\n\n      case 'firstHeader':\n        this.currentNode = 'firstHeader';\n        return true;\n\n      case 'firstFooter':\n        this.currentNode = 'firstFooter';\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    switch (this.currentNode) {\n      case 'oddHeader':\n        this.model.oddHeader = text;\n        break;\n\n      case 'oddFooter':\n        this.model.oddFooter = text;\n        break;\n\n      case 'evenHeader':\n        this.model.evenHeader = text;\n        break;\n\n      case 'evenFooter':\n        this.model.evenFooter = text;\n        break;\n\n      case 'firstHeader':\n        this.model.firstHeader = text;\n        break;\n\n      case 'firstFooter':\n        this.model.firstFooter = text;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  parseClose() {\n    switch (this.currentNode) {\n      case 'oddHeader':\n      case 'oddFooter':\n      case 'evenHeader':\n      case 'evenFooter':\n      case 'firstHeader':\n      case 'firstFooter':\n        this.currentNode = undefined;\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n\nmodule.exports = HeaderFooterXform;\n","const BaseXform = require('../../base-xform');\n\nconst ConditionalFormattingXform = require('./conditional-formatting-xform');\n\nclass ConditionalFormattingsXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.cfXform = new ConditionalFormattingXform();\n  }\n\n  get tag() {\n    return 'conditionalFormatting';\n  }\n\n  reset() {\n    this.model = [];\n  }\n\n  prepare(model, options) {\n    // ensure each rule has a priority value\n    let nextPriority = model.reduce(\n      (p, cf) => Math.max(p, ...cf.rules.map(rule => rule.priority || 0)),\n      1\n    );\n    model.forEach(cf => {\n      cf.rules.forEach(rule => {\n        if (!rule.priority) {\n          rule.priority = nextPriority++;\n        }\n\n        if (rule.style) {\n          rule.dxfId = options.styles.addDxfStyle(rule.style);\n        }\n      });\n    });\n  }\n\n  render(xmlStream, model) {\n    model.forEach(cf => {\n      this.cfXform.render(xmlStream, cf);\n    });\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case 'conditionalFormatting':\n        this.parser = this.cfXform;\n        this.parser.parseOpen(node);\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.push(this.parser.model);\n        this.parser = undefined;\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  reconcile(model, options) {\n    model.forEach(cf => {\n      cf.rules.forEach(rule => {\n        if (rule.dxfId !== undefined) {\n          rule.style = options.styles.getDxfStyle(rule.dxfId);\n          delete rule.dxfId;\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = ConditionalFormattingsXform;\n","const CompositeXform = require('../../composite-xform');\n\nconst CfRuleXform = require('./cf-rule-xform');\n\nclass ConditionalFormattingXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      cfRule: new CfRuleXform(),\n    };\n  }\n\n  get tag() {\n    return 'conditionalFormatting';\n  }\n\n  render(xmlStream, model) {\n    // if there are no primitive rules, exit now\n    if (!model.rules.some(CfRuleXform.isPrimitive)) {\n      return;\n    }\n\n    xmlStream.openNode(this.tag, {sqref: model.ref});\n\n    model.rules.forEach(rule => {\n      if (CfRuleXform.isPrimitive(rule)) {\n        rule.ref = model.ref;\n        this.map.cfRule.render(xmlStream, rule);\n      }\n    });\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel({attributes}) {\n    return {\n      ref: attributes.sqref,\n      rules: [],\n    };\n  }\n\n  onParserClose(name, parser) {\n    this.model.rules.push(parser.model);\n  }\n}\n\nmodule.exports = ConditionalFormattingXform;\n","const BaseXform = require('./base-xform');\n\n/* 'virtual' methods used as a form of documentation */\n/* eslint-disable class-methods-use-this */\n\n// base class for xforms that are composed of other xforms\n// offers some default implementations\nclass CompositeXform extends BaseXform {\n  createNewModel(node) {\n    return {};\n  }\n\n  parseOpen(node) {\n    // Typical pattern for composite xform\n    this.parser = this.parser || this.map[node.name];\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    if (node.name === this.tag) {\n      this.model = this.createNewModel(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  parseText(text) {\n    // Default implementation. Send text to child parser\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  onParserClose(name, parser) {\n    // parseClose has seen a child parser close\n    // now need to incorporate into this.model somehow\n    this.model[name] = parser.model;\n  }\n\n  parseClose(name) {\n    // Default implementation\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.onParserClose(name, this.parser);\n        this.parser = undefined;\n      }\n      return true;\n    }\n\n    return name !== this.tag;\n  }\n}\n\nmodule.exports = CompositeXform;\n","const BaseXform = require('../../base-xform');\nconst CompositeXform = require('../../composite-xform');\n\nconst Range = require('../../../../doc/range');\n\nconst DatabarXform = require('./databar-xform');\nconst ExtLstRefXform = require('./ext-lst-ref-xform');\nconst FormulaXform = require('./formula-xform');\nconst ColorScaleXform = require('./color-scale-xform');\nconst IconSetXform = require('./icon-set-xform');\n\nconst extIcons = {\n  '3Triangles': true,\n  '3Stars': true,\n  '5Boxes': true,\n};\n\nconst getTextFormula = model => {\n  if (model.formulae && model.formulae[0]) {\n    return model.formulae[0];\n  }\n\n  const range = new Range(model.ref);\n  const {tl} = range;\n  switch (model.operator) {\n    case 'containsText':\n      return `NOT(ISERROR(SEARCH(\"${model.text}\",${tl})))`;\n    case 'containsBlanks':\n      return `LEN(TRIM(${tl}))=0`;\n    case 'notContainsBlanks':\n      return `LEN(TRIM(${tl}))>0`;\n    case 'containsErrors':\n      return `ISERROR(${tl})`;\n    case 'notContainsErrors':\n      return `NOT(ISERROR(${tl}))`;\n    default:\n      return undefined;\n  }\n};\n\nconst getTimePeriodFormula = model => {\n  if (model.formulae && model.formulae[0]) {\n    return model.formulae[0];\n  }\n\n  const range = new Range(model.ref);\n  const {tl} = range;\n  switch (model.timePeriod) {\n    case 'thisWeek':\n      return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;\n    case 'lastWeek':\n      return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;\n    case 'nextWeek':\n      return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;\n    case 'yesterday':\n      return `FLOOR(${tl},1)=TODAY()-1`;\n    case 'today':\n      return `FLOOR(${tl},1)=TODAY()`;\n    case 'tomorrow':\n      return `FLOOR(${tl},1)=TODAY()+1`;\n    case 'last7Days':\n      return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;\n    case 'lastMonth':\n      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;\n    case 'thisMonth':\n      return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;\n    case 'nextMonth':\n      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;\n    default:\n      return undefined;\n  }\n};\n\nconst opType = attributes => {\n  const {type, operator} = attributes;\n  switch (type) {\n    case 'containsText':\n    case 'containsBlanks':\n    case 'notContainsBlanks':\n    case 'containsErrors':\n    case 'notContainsErrors':\n      return {\n        type: 'containsText',\n        operator: type,\n      };\n\n    default:\n      return {type, operator};\n  }\n};\n\nclass CfRuleXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      dataBar: (this.databarXform = new DatabarXform()),\n      extLst: (this.extLstRefXform = new ExtLstRefXform()),\n      formula: (this.formulaXform = new FormulaXform()),\n      colorScale: (this.colorScaleXform = new ColorScaleXform()),\n      iconSet: (this.iconSetXform = new IconSetXform()),\n    };\n  }\n\n  get tag() {\n    return 'cfRule';\n  }\n\n  static isPrimitive(rule) {\n    // is this rule primitive?\n    if (rule.type === 'iconSet') {\n      if (rule.custom || extIcons[rule.iconSet]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  render(xmlStream, model) {\n    switch (model.type) {\n      case 'expression':\n        this.renderExpression(xmlStream, model);\n        break;\n      case 'cellIs':\n        this.renderCellIs(xmlStream, model);\n        break;\n      case 'top10':\n        this.renderTop10(xmlStream, model);\n        break;\n      case 'aboveAverage':\n        this.renderAboveAverage(xmlStream, model);\n        break;\n      case 'dataBar':\n        this.renderDataBar(xmlStream, model);\n        break;\n      case 'colorScale':\n        this.renderColorScale(xmlStream, model);\n        break;\n      case 'iconSet':\n        this.renderIconSet(xmlStream, model);\n        break;\n      case 'containsText':\n        this.renderText(xmlStream, model);\n        break;\n      case 'timePeriod':\n        this.renderTimePeriod(xmlStream, model);\n        break;\n    }\n  }\n\n  renderExpression(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'expression',\n      dxfId: model.dxfId,\n      priority: model.priority,\n    });\n\n    this.formulaXform.render(xmlStream, model.formulae[0]);\n\n    xmlStream.closeNode();\n  }\n\n  renderCellIs(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'cellIs',\n      dxfId: model.dxfId,\n      priority: model.priority,\n      operator: model.operator,\n    });\n\n    model.formulae.forEach(formula => {\n      this.formulaXform.render(xmlStream, formula);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  renderTop10(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      type: 'top10',\n      dxfId: model.dxfId,\n      priority: model.priority,\n      percent: BaseXform.toBoolAttribute(model.percent, false),\n      bottom: BaseXform.toBoolAttribute(model.bottom, false),\n      rank: BaseXform.toIntValue(model.rank, 10, true),\n    });\n  }\n\n  renderAboveAverage(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      type: 'aboveAverage',\n      dxfId: model.dxfId,\n      priority: model.priority,\n      aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true),\n    });\n  }\n\n  renderDataBar(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'dataBar',\n      priority: model.priority,\n    });\n\n    this.databarXform.render(xmlStream, model);\n    this.extLstRefXform.render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  renderColorScale(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'colorScale',\n      priority: model.priority,\n    });\n\n    this.colorScaleXform.render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  renderIconSet(xmlStream, model) {\n    // iconset is all primitive or all extLst\n    if (!CfRuleXform.isPrimitive(model)) {\n      return;\n    }\n\n    xmlStream.openNode(this.tag, {\n      type: 'iconSet',\n      priority: model.priority,\n    });\n\n    this.iconSetXform.render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  renderText(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: model.operator,\n      dxfId: model.dxfId,\n      priority: model.priority,\n      operator: BaseXform.toStringAttribute(model.operator, 'containsText'),\n    });\n\n    const formula = getTextFormula(model);\n    if (formula) {\n      this.formulaXform.render(xmlStream, formula);\n    }\n\n    xmlStream.closeNode();\n  }\n\n  renderTimePeriod(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'timePeriod',\n      dxfId: model.dxfId,\n      priority: model.priority,\n      timePeriod: model.timePeriod,\n    });\n\n    const formula = getTimePeriodFormula(model);\n    if (formula) {\n      this.formulaXform.render(xmlStream, formula);\n    }\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel({attributes}) {\n    return {\n      ...opType(attributes),\n      dxfId: BaseXform.toIntValue(attributes.dxfId),\n      priority: BaseXform.toIntValue(attributes.priority),\n      timePeriod: attributes.timePeriod,\n      percent: BaseXform.toBoolValue(attributes.percent),\n      bottom: BaseXform.toBoolValue(attributes.bottom),\n      rank: BaseXform.toIntValue(attributes.rank),\n      aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage),\n    };\n  }\n\n  onParserClose(name, parser) {\n    switch (name) {\n      case 'dataBar':\n      case 'extLst':\n      case 'colorScale':\n      case 'iconSet':\n        // merge parser model with ours\n        Object.assign(this.model, parser.model);\n        break;\n\n      case 'formula':\n        // except - formula is a string and appends to formulae\n        this.model.formulae = this.model.formulae || [];\n        this.model.formulae.push(parser.model);\n        break;\n    }\n  }\n}\n\nmodule.exports = CfRuleXform;\n","const CompositeXform = require('../../composite-xform');\n\nconst ColorXform = require('../../style/color-xform');\nconst CfvoXform = require('./cfvo-xform');\n\nclass DatabarXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      cfvo: (this.cfvoXform = new CfvoXform()),\n      color: (this.colorXform = new ColorXform()),\n    };\n  }\n\n  get tag() {\n    return 'dataBar';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    model.cfvo.forEach(cfvo => {\n      this.cfvoXform.render(xmlStream, cfvo);\n    });\n    this.colorXform.render(xmlStream, model.color);\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel() {\n    return {\n      cfvo: [],\n    };\n  }\n\n  onParserClose(name, parser) {\n    switch (name) {\n      case 'cfvo':\n        this.model.cfvo.push(parser.model);\n        break;\n      case 'color':\n        this.model.color = parser.model;\n        break;\n    }\n  }\n}\n\nmodule.exports = DatabarXform;\n","const BaseXform = require('../../base-xform');\n\nclass CfvoXform extends BaseXform {\n  get tag() {\n    return 'cfvo';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      type: model.type,\n      val: model.value,\n    });\n  }\n\n  parseOpen(node) {\n    this.model = {\n      type: node.attributes.type,\n      value: BaseXform.toFloatValue(node.attributes.val),\n    };\n  }\n\n  parseClose(name) {\n    return name !== this.tag;\n  }\n}\n\nmodule.exports = CfvoXform;\n","/* eslint-disable max-classes-per-file */\nconst BaseXform = require('../../base-xform');\nconst CompositeXform = require('../../composite-xform');\n\nclass X14IdXform extends BaseXform {\n  get tag() {\n    return 'x14:id';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, null, model);\n  }\n\n  parseOpen() {\n    this.model = '';\n  }\n\n  parseText(text) {\n    this.model += text;\n  }\n\n  parseClose(name) {\n    return name !== this.tag;\n  }\n}\n\nclass ExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'x14:id': (this.idXform = new X14IdXform()),\n    };\n  }\n\n  get tag() {\n    return 'ext';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      uri: '{B025F937-C7B1-47D3-B67F-A62EFF666E3E}',\n      'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',\n    });\n\n    this.idXform.render(xmlStream, model.x14Id);\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel() {\n    return {};\n  }\n\n  onParserClose(name, parser) {\n    this.model.x14Id = parser.model;\n  }\n}\n\nclass ExtLstRefXform extends CompositeXform {\n  constructor() {\n    super();\n    this.map = {\n      ext: new ExtXform(),\n    };\n  }\n\n  get tag() {\n    return 'extLst';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n    this.map.ext.render(xmlStream, model);\n    xmlStream.closeNode();\n  }\n\n  createNewModel() {\n    return {};\n  }\n\n  onParserClose(name, parser) {\n    Object.assign(this.model, parser.model);\n  }\n}\n\nmodule.exports = ExtLstRefXform;\n","const BaseXform = require('../../base-xform');\n\nclass FormulaXform extends BaseXform {\n  get tag() {\n    return 'formula';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, null, model);\n  }\n\n  parseOpen() {\n    this.model = '';\n  }\n\n  parseText(text) {\n    this.model += text;\n  }\n\n  parseClose(name) {\n    return name !== this.tag;\n  }\n}\n\nmodule.exports = FormulaXform;\n","const CompositeXform = require('../../composite-xform');\n\nconst ColorXform = require('../../style/color-xform');\nconst CfvoXform = require('./cfvo-xform');\n\nclass ColorScaleXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      cfvo: (this.cfvoXform = new CfvoXform()),\n      color: (this.colorXform = new ColorXform()),\n    };\n  }\n\n  get tag() {\n    return 'colorScale';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    model.cfvo.forEach(cfvo => {\n      this.cfvoXform.render(xmlStream, cfvo);\n    });\n    model.color.forEach(color => {\n      this.colorXform.render(xmlStream, color);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel(node) {\n    return {\n      cfvo: [],\n      color: [],\n    };\n  }\n\n  onParserClose(name, parser) {\n    this.model[name].push(parser.model);\n  }\n}\n\nmodule.exports = ColorScaleXform;\n","const BaseXform = require('../../base-xform');\nconst CompositeXform = require('../../composite-xform');\n\nconst CfvoXform = require('./cfvo-xform');\n\nclass IconSetXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      cfvo: (this.cfvoXform = new CfvoXform()),\n    };\n  }\n\n  get tag() {\n    return 'iconSet';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      iconSet: BaseXform.toStringAttribute(model.iconSet, '3TrafficLights'),\n      reverse: BaseXform.toBoolAttribute(model.reverse, false),\n      showValue: BaseXform.toBoolAttribute(model.showValue, true),\n    });\n\n    model.cfvo.forEach(cfvo => {\n      this.cfvoXform.render(xmlStream, cfvo);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel({attributes}) {\n    return {\n      iconSet: BaseXform.toStringValue(attributes.iconSet, '3TrafficLights'),\n      reverse: BaseXform.toBoolValue(attributes.reverse),\n      showValue: BaseXform.toBoolValue(attributes.showValue),\n      cfvo: [],\n    };\n  }\n\n  onParserClose(name, parser) {\n    this.model[name].push(parser.model);\n  }\n}\n\nmodule.exports = IconSetXform;\n","/* eslint-disable max-classes-per-file */\nconst CompositeXform = require('../composite-xform');\n\nconst ConditionalFormattingsExt = require('./cf-ext/conditional-formattings-ext-xform');\n\nclass ExtXform extends CompositeXform {\n  constructor() {\n    super();\n    this.map = {\n      'x14:conditionalFormattings': (this.conditionalFormattings = new ConditionalFormattingsExt()),\n    };\n  }\n\n  get tag() {\n    return 'ext';\n  }\n\n  hasContent(model) {\n    return this.conditionalFormattings.hasContent(model.conditionalFormattings);\n  }\n\n  prepare(model, options) {\n    this.conditionalFormattings.prepare(model.conditionalFormattings, options);\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode('ext', {\n      uri: '{78C0D931-6437-407d-A8EE-F0AAD7539E65}',\n      'xmlns:x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',\n    });\n\n    this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel() {\n    return {};\n  }\n\n  onParserClose(name, parser) {\n    this.model[name] = parser.model;\n  }\n}\n\nclass ExtLstXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      ext: (this.ext = new ExtXform()),\n    };\n  }\n\n  get tag() {\n    return 'extLst';\n  }\n\n  prepare(model, options) {\n    this.ext.prepare(model, options);\n  }\n\n  hasContent(model) {\n    return this.ext.hasContent(model);\n  }\n\n  render(xmlStream, model) {\n    if (!this.hasContent(model)) {\n      return;\n    }\n\n    xmlStream.openNode('extLst');\n    this.ext.render(xmlStream, model);\n    xmlStream.closeNode();\n  }\n\n  createNewModel() {\n    return {};\n  }\n\n  onParserClose(name, parser) {\n    Object.assign(this.model, parser.model);\n  }\n}\n\nmodule.exports = ExtLstXform;\n","const CompositeXform = require('../../composite-xform');\n\nconst CfRuleExtXform = require('./cf-rule-ext-xform');\nconst ConditionalFormattingExtXform = require('./conditional-formatting-ext-xform');\n\nclass ConditionalFormattingsExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'x14:conditionalFormatting': (this.cfXform = new ConditionalFormattingExtXform()),\n    };\n  }\n\n  get tag() {\n    return 'x14:conditionalFormattings';\n  }\n\n  hasContent(model) {\n    if (model.hasExtContent === undefined) {\n      model.hasExtContent = model.some(cf => cf.rules.some(CfRuleExtXform.isExt));\n    }\n    return model.hasExtContent;\n  }\n\n  prepare(model, options) {\n    model.forEach(cf => {\n      this.cfXform.prepare(cf, options);\n    });\n  }\n\n  render(xmlStream, model) {\n    if (this.hasContent(model)) {\n      xmlStream.openNode(this.tag);\n      model.forEach(cf => this.cfXform.render(xmlStream, cf));\n      xmlStream.closeNode();\n    }\n  }\n\n  createNewModel() {\n    return [];\n  }\n\n  onParserClose(name, parser) {\n    // model is array of conditional formatting objects\n    this.model.push(parser.model);\n  }\n}\n\nmodule.exports = ConditionalFormattingsExtXform;\n","const {v4: uuidv4} = require('uuid');\nconst BaseXform = require('../../base-xform');\nconst CompositeXform = require('../../composite-xform');\n\nconst DatabarExtXform = require('./databar-ext-xform');\nconst IconSetExtXform = require('./icon-set-ext-xform');\n\nconst extIcons = {\n  '3Triangles': true,\n  '3Stars': true,\n  '5Boxes': true,\n};\n\nclass CfRuleExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'x14:dataBar': (this.databarXform = new DatabarExtXform()),\n      'x14:iconSet': (this.iconSetXform = new IconSetExtXform()),\n    };\n  }\n\n  get tag() {\n    return 'x14:cfRule';\n  }\n\n  static isExt(rule) {\n    // is this rule primitive?\n    if (rule.type === 'dataBar') {\n      return DatabarExtXform.isExt(rule);\n    }\n    if (rule.type === 'iconSet') {\n      if (rule.custom || extIcons[rule.iconSet]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  prepare(model) {\n    if (CfRuleExtXform.isExt(model)) {\n      model.x14Id = `{${uuidv4()}}`.toUpperCase();\n    }\n  }\n\n  render(xmlStream, model) {\n    if (!CfRuleExtXform.isExt(model)) {\n      return;\n    }\n\n    switch (model.type) {\n      case 'dataBar':\n        this.renderDataBar(xmlStream, model);\n        break;\n      case 'iconSet':\n        this.renderIconSet(xmlStream, model);\n        break;\n    }\n  }\n\n  renderDataBar(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'dataBar',\n      id: model.x14Id,\n    });\n\n    this.databarXform.render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  renderIconSet(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: 'iconSet',\n      priority: model.priority,\n      id: model.x14Id || `{${uuidv4()}}`,\n    });\n\n    this.iconSetXform.render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel({attributes}) {\n    return {\n      type: attributes.type,\n      x14Id: attributes.id,\n      priority: BaseXform.toIntValue(attributes.priority),\n    };\n  }\n\n  onParserClose(name, parser) {\n    Object.assign(this.model, parser.model);\n  }\n}\n\nmodule.exports = CfRuleExtXform;\n","const BaseXform = require('../../base-xform');\nconst CompositeXform = require('../../composite-xform');\n\nconst ColorXform = require('../../style/color-xform');\nconst CfvoExtXform = require('./cfvo-ext-xform');\n\nclass DatabarExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'x14:cfvo': (this.cfvoXform = new CfvoExtXform()),\n      'x14:borderColor': (this.borderColorXform = new ColorXform('x14:borderColor')),\n      'x14:negativeBorderColor': (this.negativeBorderColorXform = new ColorXform(\n        'x14:negativeBorderColor'\n      )),\n      'x14:negativeFillColor': (this.negativeFillColorXform = new ColorXform(\n        'x14:negativeFillColor'\n      )),\n      'x14:axisColor': (this.axisColorXform = new ColorXform('x14:axisColor')),\n    };\n  }\n\n  static isExt(rule) {\n    // not all databars need ext\n    // TODO: refine this\n    return !rule.gradient;\n  }\n\n  get tag() {\n    return 'x14:dataBar';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      minLength: BaseXform.toIntAttribute(model.minLength, 0, true),\n      maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true),\n      border: BaseXform.toBoolAttribute(model.border, false),\n      gradient: BaseXform.toBoolAttribute(model.gradient, true),\n      negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(\n        model.negativeBarColorSameAsPositive,\n        true\n      ),\n      negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(\n        model.negativeBarBorderColorSameAsPositive,\n        true\n      ),\n      axisPosition: BaseXform.toAttribute(model.axisPosition, 'auto'),\n      direction: BaseXform.toAttribute(model.direction, 'leftToRight'),\n    });\n\n    model.cfvo.forEach(cfvo => {\n      this.cfvoXform.render(xmlStream, cfvo);\n    });\n\n    this.borderColorXform.render(xmlStream, model.borderColor);\n    this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);\n    this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);\n    this.axisColorXform.render(xmlStream, model.axisColor);\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel({attributes}) {\n    return {\n      cfvo: [],\n      minLength: BaseXform.toIntValue(attributes.minLength, 0),\n      maxLength: BaseXform.toIntValue(attributes.maxLength, 100),\n      border: BaseXform.toBoolValue(attributes.border, false),\n      gradient: BaseXform.toBoolValue(attributes.gradient, true),\n      negativeBarColorSameAsPositive: BaseXform.toBoolValue(\n        attributes.negativeBarColorSameAsPositive,\n        true\n      ),\n      negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(\n        attributes.negativeBarBorderColorSameAsPositive,\n        true\n      ),\n      axisPosition: BaseXform.toStringValue(attributes.axisPosition, 'auto'),\n      direction: BaseXform.toStringValue(attributes.direction, 'leftToRight'),\n    };\n  }\n\n  onParserClose(name, parser) {\n    const [, prop] = name.split(':');\n    switch (prop) {\n      case 'cfvo':\n        this.model.cfvo.push(parser.model);\n        break;\n\n      default:\n        this.model[prop] = parser.model;\n        break;\n    }\n  }\n}\n\nmodule.exports = DatabarExtXform;\n","const CompositeXform = require('../../composite-xform');\n\nconst FExtXform = require('./f-ext-xform');\n\nclass CfvoExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xm:f': (this.fExtXform = new FExtXform()),\n    };\n  }\n\n  get tag() {\n    return 'x14:cfvo';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      type: model.type,\n    });\n    if (model.value !== undefined) {\n      this.fExtXform.render(xmlStream, model.value);\n    }\n    xmlStream.closeNode();\n  }\n\n  createNewModel(node) {\n    return {\n      type: node.attributes.type,\n    };\n  }\n\n  onParserClose(name, parser) {\n    switch (name) {\n      case 'xm:f':\n        this.model.value = parser.model ? parseFloat(parser.model) : 0;\n        break;\n    }\n  }\n}\n\nmodule.exports = CfvoExtXform;\n","const BaseXform = require('../../base-xform');\n\nclass FExtXform extends BaseXform {\n  get tag() {\n    return 'xm:f';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, null, model);\n  }\n\n  parseOpen() {\n    this.model = '';\n  }\n\n  parseText(text) {\n    this.model += text;\n  }\n\n  parseClose(name) {\n    return name !== this.tag;\n  }\n}\n\nmodule.exports = FExtXform;\n","const BaseXform = require('../../base-xform');\nconst CompositeXform = require('../../composite-xform');\n\nconst CfvoExtXform = require('./cfvo-ext-xform');\nconst CfIconExtXform = require('./cf-icon-ext-xform');\n\nclass IconSetExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'x14:cfvo': (this.cfvoXform = new CfvoExtXform()),\n      'x14:cfIcon': (this.cfIconXform = new CfIconExtXform()),\n    };\n  }\n\n  get tag() {\n    return 'x14:iconSet';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      iconSet: BaseXform.toStringAttribute(model.iconSet),\n      reverse: BaseXform.toBoolAttribute(model.reverse, false),\n      showValue: BaseXform.toBoolAttribute(model.showValue, true),\n      custom: BaseXform.toBoolAttribute(model.icons, false),\n    });\n\n    model.cfvo.forEach(cfvo => {\n      this.cfvoXform.render(xmlStream, cfvo);\n    });\n\n    if (model.icons) {\n      model.icons.forEach((icon, i) => {\n        icon.iconId = i;\n        this.cfIconXform.render(xmlStream, icon);\n      });\n    }\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel({attributes}) {\n    return {\n      cfvo: [],\n      iconSet: BaseXform.toStringValue(attributes.iconSet, '3TrafficLights'),\n      reverse: BaseXform.toBoolValue(attributes.reverse, false),\n      showValue: BaseXform.toBoolValue(attributes.showValue, true),\n    };\n  }\n\n  onParserClose(name, parser) {\n    const [, prop] = name.split(':');\n    switch (prop) {\n      case 'cfvo':\n        this.model.cfvo.push(parser.model);\n        break;\n\n      case 'cfIcon':\n        if (!this.model.icons) {\n          this.model.icons = [];\n        }\n        this.model.icons.push(parser.model);\n        break;\n\n      default:\n        this.model[prop] = parser.model;\n        break;\n    }\n  }\n}\n\nmodule.exports = IconSetExtXform;\n","const BaseXform = require('../../base-xform');\n\nclass CfIconExtXform extends BaseXform {\n  get tag() {\n    return 'x14:cfIcon';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      iconSet: model.iconSet,\n      iconId: model.iconId,\n    });\n  }\n\n  parseOpen({attributes}) {\n    this.model = {\n      iconSet: attributes.iconSet,\n      iconId: BaseXform.toIntValue(attributes.iconId),\n    };\n  }\n\n  parseClose(name) {\n    return name !== this.tag;\n  }\n}\n\nmodule.exports = CfIconExtXform;\n","const CompositeXform = require('../../composite-xform');\n\nconst SqRefExtXform = require('./sqref-ext-xform');\nconst CfRuleExtXform = require('./cf-rule-ext-xform');\n\nclass ConditionalFormattingExtXform extends CompositeXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xm:sqref': (this.sqRef = new SqRefExtXform()),\n      'x14:cfRule': (this.cfRule = new CfRuleExtXform()),\n    };\n  }\n\n  get tag() {\n    return 'x14:conditionalFormatting';\n  }\n\n  prepare(model, options) {\n    model.rules.forEach(rule => {\n      this.cfRule.prepare(rule, options);\n    });\n  }\n\n  render(xmlStream, model) {\n    if (!model.rules.some(CfRuleExtXform.isExt)) {\n      return;\n    }\n\n    xmlStream.openNode(this.tag, {\n      'xmlns:xm': 'http://schemas.microsoft.com/office/excel/2006/main',\n    });\n\n    model.rules.filter(CfRuleExtXform.isExt).forEach(rule => this.cfRule.render(xmlStream, rule));\n\n    // for some odd reason, Excel needs the <xm:sqref> node to be after the rules\n    this.sqRef.render(xmlStream, model.ref);\n\n    xmlStream.closeNode();\n  }\n\n  createNewModel() {\n    return {\n      rules: [],\n    };\n  }\n\n  onParserClose(name, parser) {\n    switch (name) {\n      case 'xm:sqref':\n        this.model.ref = parser.model;\n        break;\n\n      case 'x14:cfRule':\n        this.model.rules.push(parser.model);\n        break;\n    }\n  }\n}\n\nmodule.exports = ConditionalFormattingExtXform;\n","const BaseXform = require('../../base-xform');\n\nclass SqrefExtXform extends BaseXform {\n  get tag() {\n    return 'xm:sqref';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, null, model);\n  }\n\n  parseOpen() {\n    this.model = '';\n  }\n\n  parseText(text) {\n    this.model += text;\n  }\n\n  parseClose(name) {\n    return name !== this.tag;\n  }\n}\n\nmodule.exports = SqrefExtXform;\n","const colCache = require('../../../utils/col-cache');\nconst XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\nconst TwoCellAnchorXform = require('./two-cell-anchor-xform');\nconst OneCellAnchorXform = require('./one-cell-anchor-xform');\n\nfunction getAnchorType(model) {\n  const range = typeof model.range === 'string' ? colCache.decode(model.range) : model.range;\n\n  return range.br ? 'xdr:twoCellAnchor' : 'xdr:oneCellAnchor';\n}\n\nclass DrawingXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xdr:twoCellAnchor': new TwoCellAnchorXform(),\n      'xdr:oneCellAnchor': new OneCellAnchorXform(),\n    };\n  }\n\n  prepare(model) {\n    model.anchors.forEach((item, index) => {\n      item.anchorType = getAnchorType(item);\n      const anchor = this.map[item.anchorType];\n      anchor.prepare(item, {index});\n    });\n  }\n\n  get tag() {\n    return 'xdr:wsDr';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode(this.tag, DrawingXform.DRAWING_ATTRIBUTES);\n\n    model.anchors.forEach(item => {\n      const anchor = this.map[item.anchorType];\n      anchor.render(xmlStream, item);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        this.model = {\n          anchors: [],\n        };\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.anchors.push(this.parser.model);\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    model.anchors.forEach(anchor => {\n      if (anchor.br) {\n        this.map['xdr:twoCellAnchor'].reconcile(anchor, options);\n      } else {\n        this.map['xdr:oneCellAnchor'].reconcile(anchor, options);\n      }\n    });\n  }\n}\n\nDrawingXform.DRAWING_ATTRIBUTES = {\n  'xmlns:xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',\n  'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',\n};\n\nmodule.exports = DrawingXform;\n","const BaseCellAnchorXform = require('./base-cell-anchor-xform');\nconst StaticXform = require('../static-xform');\n\nconst CellPositionXform = require('./cell-position-xform');\nconst PicXform = require('./pic-xform');\n\nclass TwoCellAnchorXform extends BaseCellAnchorXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xdr:from': new CellPositionXform({tag: 'xdr:from'}),\n      'xdr:to': new CellPositionXform({tag: 'xdr:to'}),\n      'xdr:pic': new PicXform(),\n      'xdr:clientData': new StaticXform({tag: 'xdr:clientData'}),\n    };\n  }\n\n  get tag() {\n    return 'xdr:twoCellAnchor';\n  }\n\n  prepare(model, options) {\n    this.map['xdr:pic'].prepare(model.picture, options);\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {editAs: model.range.editAs || 'oneCell'});\n\n    this.map['xdr:from'].render(xmlStream, model.range.tl);\n    this.map['xdr:to'].render(xmlStream, model.range.br);\n    this.map['xdr:pic'].render(xmlStream, model.picture);\n    this.map['xdr:clientData'].render(xmlStream, {});\n\n    xmlStream.closeNode();\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model.range.tl = this.map['xdr:from'].model;\n        this.model.range.br = this.map['xdr:to'].model;\n        this.model.picture = this.map['xdr:pic'].model;\n        return false;\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    model.medium = this.reconcilePicture(model.picture, options);\n  }\n}\n\nmodule.exports = TwoCellAnchorXform;\n","const BaseXform = require('../base-xform');\n\nclass BaseCellAnchorXform extends BaseXform {\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        this.model = {\n          range: {\n            editAs: node.attributes.editAs || 'oneCell',\n          },\n        };\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  reconcilePicture(model, options) {\n    if (model && model.rId) {\n      const rel = options.rels[model.rId];\n      const match = rel.Target.match(/.*\\/media\\/(.+[.][a-zA-Z]{3,4})/);\n      if (match) {\n        const name = match[1];\n        const mediaId = options.mediaIndex[name];\n        return options.media[mediaId];\n      }\n    }\n    return undefined;\n  }\n}\n\nmodule.exports = BaseCellAnchorXform;\n","const BaseXform = require('../base-xform');\nconst IntegerXform = require('../simple/integer-xform');\n\nclass CellPositionXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.map = {\n      'xdr:col': new IntegerXform({tag: 'xdr:col', zero: true}),\n      'xdr:colOff': new IntegerXform({tag: 'xdr:colOff', zero: true}),\n      'xdr:row': new IntegerXform({tag: 'xdr:row', zero: true}),\n      'xdr:rowOff': new IntegerXform({tag: 'xdr:rowOff', zero: true}),\n    };\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    this.map['xdr:col'].render(xmlStream, model.nativeCol);\n    this.map['xdr:colOff'].render(xmlStream, model.nativeColOff);\n\n    this.map['xdr:row'].render(xmlStream, model.nativeRow);\n    this.map['xdr:rowOff'].render(xmlStream, model.nativeRowOff);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model = {\n          nativeCol: this.map['xdr:col'].model,\n          nativeColOff: this.map['xdr:colOff'].model,\n          nativeRow: this.map['xdr:row'].model,\n          nativeRowOff: this.map['xdr:rowOff'].model,\n        };\n        return false;\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n}\n\nmodule.exports = CellPositionXform;\n","const BaseXform = require('../base-xform');\nconst StaticXform = require('../static-xform');\n\nconst BlipFillXform = require('./blip-fill-xform');\nconst NvPicPrXform = require('./nv-pic-pr-xform');\n\nconst spPrJSON = require('./sp-pr');\n\nclass PicXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xdr:nvPicPr': new NvPicPrXform(),\n      'xdr:blipFill': new BlipFillXform(),\n      'xdr:spPr': new StaticXform(spPrJSON),\n    };\n  }\n\n  get tag() {\n    return 'xdr:pic';\n  }\n\n  prepare(model, options) {\n    model.index = options.index + 1;\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    this.map['xdr:nvPicPr'].render(xmlStream, model);\n    this.map['xdr:blipFill'].render(xmlStream, model);\n    this.map['xdr:spPr'].render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.mergeModel(this.parser.model);\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        // not quite sure how we get here!\n        return true;\n    }\n  }\n}\n\nmodule.exports = PicXform;\n","const BaseXform = require('../base-xform');\nconst BlipXform = require('./blip-xform');\n\nclass BlipFillXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'a:blip': new BlipXform(),\n    };\n  }\n\n  get tag() {\n    return 'xdr:blipFill';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    this.map['a:blip'].render(xmlStream, model);\n\n    // TODO: options for this + parsing\n    xmlStream.openNode('a:stretch');\n    xmlStream.leafNode('a:fillRect');\n    xmlStream.closeNode();\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        break;\n\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model = this.map['a:blip'].model;\n        return false;\n\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = BlipFillXform;\n","const BaseXform = require('../base-xform');\n\nclass BlipXform extends BaseXform {\n  get tag() {\n    return 'a:blip';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n      'r:embed': model.rId,\n      cstate: 'print',\n    });\n    // TODO: handle children (e.g. a:extLst=>a:ext=>a14:useLocalDpi\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          rId: node.attributes['r:embed'],\n        };\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        // unprocessed internal nodes\n        return true;\n    }\n  }\n}\n\nmodule.exports = BlipXform;\n","const BaseXform = require('../base-xform');\nconst CNvPrXform = require('./c-nv-pr-xform');\nconst CNvPicPrXform = require('./c-nv-pic-pr-xform');\n\nclass NvPicPrXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xdr:cNvPr': new CNvPrXform(),\n      'xdr:cNvPicPr': new CNvPicPrXform(),\n    };\n  }\n\n  get tag() {\n    return 'xdr:nvPicPr';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n    this.map['xdr:cNvPr'].render(xmlStream, model);\n    this.map['xdr:cNvPicPr'].render(xmlStream, model);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model = this.map['xdr:cNvPr'].model;\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = NvPicPrXform;\n","const BaseXform = require('../base-xform');\nconst HlickClickXform = require('./hlink-click-xform');\nconst ExtLstXform = require('./ext-lst-xform');\n\nclass CNvPrXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'a:hlinkClick': new HlickClickXform(),\n      'a:extLst': new ExtLstXform(),\n    };\n  }\n\n  get tag() {\n    return 'xdr:cNvPr';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {\n      id: model.index,\n      name: `Picture ${model.index}`,\n    });\n    this.map['a:hlinkClick'].render(xmlStream, model);\n    this.map['a:extLst'].render(xmlStream, model);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model = this.map['a:hlinkClick'].model;\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = CNvPrXform;\n","const BaseXform = require('../base-xform');\n\nclass HLinkClickXform extends BaseXform {\n  get tag() {\n    return 'a:hlinkClick';\n  }\n\n  render(xmlStream, model) {\n    if (!(model.hyperlinks && model.hyperlinks.rId)) {\n      return;\n    }\n    xmlStream.leafNode(this.tag, {\n      'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',\n      'r:id': model.hyperlinks.rId,\n      tooltip: model.hyperlinks.tooltip,\n    });\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          hyperlinks: {\n            rId: node.attributes['r:id'],\n            tooltip: node.attributes.tooltip,\n          },\n        };\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = HLinkClickXform;\n","const BaseXform = require('../base-xform');\n\nclass ExtLstXform extends BaseXform {\n  get tag() {\n    return 'a:extLst';\n  }\n\n  render(xmlStream) {\n    xmlStream.openNode(this.tag);\n    xmlStream.openNode('a:ext', {\n      uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}',\n    });\n    xmlStream.leafNode('a16:creationId', {\n      'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main',\n      id: '{00000000-0008-0000-0000-000002000000}',\n    });\n    xmlStream.closeNode();\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        // unprocessed internal nodes\n        return true;\n    }\n  }\n}\n\nmodule.exports = ExtLstXform;\n","const BaseXform = require('../base-xform');\n\nclass CNvPicPrXform extends BaseXform {\n  get tag() {\n    return 'xdr:cNvPicPr';\n  }\n\n  render(xmlStream) {\n    xmlStream.openNode(this.tag);\n    xmlStream.leafNode('a:picLocks', {\n      noChangeAspect: '1',\n    });\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        // unprocessed internal nodes\n        return true;\n    }\n  }\n}\n\nmodule.exports = CNvPicPrXform;\n","module.exports = {\n  tag: 'xdr:spPr',\n  c: [\n    {\n      tag: 'a:xfrm',\n      c: [\n        {tag: 'a:off', $: {x: '0', y: '0'}},\n        {tag: 'a:ext', $: {cx: '0', cy: '0'}},\n      ],\n    },\n    {\n      tag: 'a:prstGeom',\n      $: {prst: 'rect'},\n      c: [{tag: 'a:avLst'}],\n    },\n  ],\n};\n","const BaseCellAnchorXform = require('./base-cell-anchor-xform');\nconst StaticXform = require('../static-xform');\n\nconst CellPositionXform = require('./cell-position-xform');\nconst ExtXform = require('./ext-xform');\nconst PicXform = require('./pic-xform');\n\nclass OneCellAnchorXform extends BaseCellAnchorXform {\n  constructor() {\n    super();\n\n    this.map = {\n      'xdr:from': new CellPositionXform({tag: 'xdr:from'}),\n      'xdr:ext': new ExtXform({tag: 'xdr:ext'}),\n      'xdr:pic': new PicXform(),\n      'xdr:clientData': new StaticXform({tag: 'xdr:clientData'}),\n    };\n  }\n\n  get tag() {\n    return 'xdr:oneCellAnchor';\n  }\n\n  prepare(model, options) {\n    this.map['xdr:pic'].prepare(model.picture, options);\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {editAs: model.range.editAs || 'oneCell'});\n\n    this.map['xdr:from'].render(xmlStream, model.range.tl);\n    this.map['xdr:ext'].render(xmlStream, model.range.ext);\n    this.map['xdr:pic'].render(xmlStream, model.picture);\n    this.map['xdr:clientData'].render(xmlStream, {});\n\n    xmlStream.closeNode();\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model.range.tl = this.map['xdr:from'].model;\n        this.model.range.ext = this.map['xdr:ext'].model;\n        this.model.picture = this.map['xdr:pic'].model;\n        return false;\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    model.medium = this.reconcilePicture(model.picture, options);\n  }\n}\n\nmodule.exports = OneCellAnchorXform;\n","const BaseXform = require('../base-xform');\n\n/** https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML */\nconst EMU_PER_PIXEL_AT_96_DPI = 9525;\n\nclass ExtXform extends BaseXform {\n  constructor(options) {\n    super();\n\n    this.tag = options.tag;\n    this.map = {};\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag);\n\n    const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);\n    const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);\n\n    xmlStream.addAttribute('cx', width);\n    xmlStream.addAttribute('cy', height);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      this.model = {\n        width: parseInt(node.attributes.cx || '0', 10) / EMU_PER_PIXEL_AT_96_DPI,\n        height: parseInt(node.attributes.cy || '0', 10) / EMU_PER_PIXEL_AT_96_DPI,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText(/* text */) {}\n\n  parseClose(/* name */) {\n    return false;\n  }\n}\n\nmodule.exports = ExtXform;\n","const XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\nconst ListXform = require('../list-xform');\n\nconst AutoFilterXform = require('./auto-filter-xform');\nconst TableColumnXform = require('./table-column-xform');\nconst TableStyleInfoXform = require('./table-style-info-xform');\n\nclass TableXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      autoFilter: new AutoFilterXform(),\n      tableColumns: new ListXform({\n        tag: 'tableColumns',\n        count: true,\n        empty: true,\n        childXform: new TableColumnXform(),\n      }),\n      tableStyleInfo: new TableStyleInfoXform(),\n    };\n  }\n\n  prepare(model, options) {\n    this.map.autoFilter.prepare(model);\n    this.map.tableColumns.prepare(model.columns, options);\n  }\n\n  get tag() {\n    return 'table';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode(this.tag, {\n      ...TableXform.TABLE_ATTRIBUTES,\n      id: model.id,\n      name: model.name,\n      displayName: model.displayName || model.name,\n      ref: model.tableRef,\n      totalsRowCount: model.totalsRow ? '1' : undefined,\n      totalsRowShown: model.totalsRow ? undefined : '1',\n      headerRowCount: model.headerRow ? '1' : '0',\n    });\n\n    this.map.autoFilter.render(xmlStream, model);\n    this.map.tableColumns.render(xmlStream, model.columns);\n    this.map.tableStyleInfo.render(xmlStream, model.style);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    const {name, attributes} = node;\n    switch (name) {\n      case this.tag:\n        this.reset();\n        this.model = {\n          name: attributes.name,\n          displayName: attributes.displayName || attributes.name,\n          tableRef: attributes.ref,\n          totalsRow: attributes.totalsRowCount === '1',\n          headerRow: attributes.headerRowCount === '1',\n        };\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model.columns = this.map.tableColumns.model;\n        if (this.map.autoFilter.model) {\n          this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;\n          this.map.autoFilter.model.columns.forEach((column, index) => {\n            this.model.columns[index].filterButton = column.filterButton;\n          });\n        }\n        this.model.style = this.map.tableStyleInfo.model;\n        return false;\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    // fetch the dfxs from styles\n    model.columns.forEach(column => {\n      if (column.dxfId !== undefined) {\n        column.style = options.styles.getDxfStyle(column.dxfId);\n      }\n    });\n  }\n}\n\nTableXform.TABLE_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'xr xr3',\n  'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',\n  'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',\n  // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',\n};\n\nmodule.exports = TableXform;\n","const BaseXform = require('../base-xform');\n\nconst FilterColumnXform = require('./filter-column-xform');\n\nclass AutoFilterXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      filterColumn: new FilterColumnXform(),\n    };\n  }\n\n  get tag() {\n    return 'autoFilter';\n  }\n\n  prepare(model) {\n    model.columns.forEach((column, index) => {\n      this.map.filterColumn.prepare(column, {index});\n    });\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openNode(this.tag, {ref: model.autoFilterRef});\n\n    model.columns.forEach(column => {\n      this.map.filterColumn.render(xmlStream, column);\n    });\n\n    xmlStream.closeNode();\n    return true;\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          autoFilterRef: node.attributes.ref,\n          columns: [],\n        };\n        return true;\n\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parseOpen(node);\n          return true;\n        }\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\n    }\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.columns.push(this.parser.model);\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        throw new Error(`Unexpected xml node in parseClose: ${name}`);\n    }\n  }\n}\n\nmodule.exports = AutoFilterXform;\n","const BaseXform = require('../base-xform');\nconst ListXform = require('../list-xform');\n\nconst CustomFilterXform = require('./custom-filter-xform');\nconst FilterXform = require('./filter-xform');\n\nclass FilterColumnXform extends BaseXform {\n  constructor() {\n    super();\n\n    this.map = {\n      customFilters: new ListXform({\n        tag: 'customFilters',\n        count: false,\n        empty: true,\n        childXform: new CustomFilterXform(),\n      }),\n      filters: new ListXform({\n        tag: 'filters',\n        count: false,\n        empty: true,\n        childXform: new FilterXform(),\n      }),\n    };\n  }\n\n  get tag() {\n    return 'filterColumn';\n  }\n\n  prepare(model, options) {\n    model.colId = options.index.toString();\n  }\n\n  render(xmlStream, model) {\n    if (model.customFilters) {\n      xmlStream.openNode(this.tag, {\n        colId: model.colId,\n        hiddenButton: model.filterButton ? '0' : '1',\n      });\n\n      this.map.customFilters.render(xmlStream, model.customFilters);\n\n      xmlStream.closeNode();\n      return true;\n    }\n    xmlStream.leafNode(this.tag, {\n      colId: model.colId,\n      hiddenButton: model.filterButton ? '0' : '1',\n    });\n    return true;\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    const {attributes} = node;\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          filterButton: attributes.hiddenButton === '0',\n        };\n        return true;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parseOpen(node);\n          return true;\n        }\n        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model.customFilters = this.map.customFilters.model;\n        return false;\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n}\n\nmodule.exports = FilterColumnXform;\n","const BaseXform = require('../base-xform');\n\nclass CustomFilterXform extends BaseXform {\n  get tag() {\n    return 'customFilter';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      val: model.val,\n      operator: model.operator,\n    });\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      this.model = {\n        val: node.attributes.val,\n        operator: node.attributes.operator,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = CustomFilterXform;\n","const BaseXform = require('../base-xform');\n\nclass FilterXform extends BaseXform {\n  get tag() {\n    return 'filter';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      val: model.val,\n    });\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      this.model = {\n        val: node.attributes.val,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = FilterXform;\n","const BaseXform = require('../base-xform');\n\nclass TableColumnXform extends BaseXform {\n  get tag() {\n    return 'tableColumn';\n  }\n\n  prepare(model, options) {\n    model.id = options.index + 1;\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      id: model.id.toString(),\n      name: model.name,\n      totalsRowLabel: model.totalsRowLabel,\n      totalsRowFunction: model.totalsRowFunction,\n      dxfId: model.dxfId,\n    });\n    return true;\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      const {attributes} = node;\n      this.model = {\n        name: attributes.name,\n        totalsRowLabel: attributes.totalsRowLabel,\n        totalsRowFunction: attributes.totalsRowFunction,\n        dxfId: attributes.dxfId,\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = TableColumnXform;\n","const BaseXform = require('../base-xform');\n\nclass TableStyleInfoXform extends BaseXform {\n  get tag() {\n    return 'tableStyleInfo';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, {\n      name: model.theme ? model.theme : undefined,\n      showFirstColumn: model.showFirstColumn ? '1' : '0',\n      showLastColumn: model.showLastColumn ? '1' : '0',\n      showRowStripes: model.showRowStripes ? '1' : '0',\n      showColumnStripes: model.showColumnStripes ? '1' : '0',\n    });\n    return true;\n  }\n\n  parseOpen(node) {\n    if (node.name === this.tag) {\n      const {attributes} = node;\n      this.model = {\n        theme: attributes.name ? attributes.name : null,\n        showFirstColumn: attributes.showFirstColumn === '1',\n        showLastColumn: attributes.showLastColumn === '1',\n        showRowStripes: attributes.showRowStripes === '1',\n        showColumnStripes: attributes.showColumnStripes === '1',\n      };\n      return true;\n    }\n    return false;\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = TableStyleInfoXform;\n","const XmlStream = require('../../../utils/xml-stream');\nconst utils = require('../../../utils/utils');\nconst BaseXform = require('../base-xform');\n\nconst CommentXform = require('./comment-xform');\n\nconst CommentsXform = (module.exports = function() {\n  this.map = {\n    comment: new CommentXform(),\n  };\n});\n\nutils.inherits(\n  CommentsXform,\n  BaseXform,\n  {\n    COMMENTS_ATTRIBUTES: {\n      xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n    },\n  },\n  {\n    render(xmlStream, model) {\n      model = model || this.model;\n      xmlStream.openXml(XmlStream.StdDocAttributes);\n      xmlStream.openNode('comments', CommentsXform.COMMENTS_ATTRIBUTES);\n\n      // authors\n      // TODO: support authors properly\n      xmlStream.openNode('authors');\n      xmlStream.leafNode('author', null, 'Author');\n      xmlStream.closeNode();\n\n      // comments\n      xmlStream.openNode('commentList');\n      model.comments.forEach(comment => {\n        this.map.comment.render(xmlStream, comment);\n      });\n      xmlStream.closeNode();\n      xmlStream.closeNode();\n    },\n\n    parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n      switch (node.name) {\n        case 'commentList':\n          this.model = {\n            comments: [],\n          };\n          return true;\n        case 'comment':\n          this.parser = this.map.comment;\n          this.parser.parseOpen(node);\n          return true;\n        default:\n          return false;\n      }\n    },\n    parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n      }\n    },\n    parseClose(name) {\n      switch (name) {\n        case 'commentList':\n          return false;\n        case 'comment':\n          this.model.comments.push(this.parser.model);\n          this.parser = undefined;\n          return true;\n        default:\n          if (this.parser) {\n            this.parser.parseClose(name);\n          }\n          return true;\n      }\n    },\n  }\n);\n","const RichTextXform = require('../strings/rich-text-xform');\nconst utils = require('../../../utils/utils');\nconst BaseXform = require('../base-xform');\n\n/**\n  <comment ref=\"B1\" authorId=\"0\">\n    <text>\n      <r>\n        <rPr>\n          <b/>\n          <sz val=\"9\"/>\n          <rFont val=\"\"/>\n          <charset val=\"134\"/>\n        </rPr>\n        <t>51422:</t>\n      </r>\n      <r>\n        <rPr>\n          <sz val=\"9\"/>\n          <rFont val=\"\"/>\n          <charset val=\"134\"/>\n        </rPr>\n        <t xml:space=\"preserve\">&#10;test</t>\n      </r>\n    </text>\n  </comment>\n */\n\nconst CommentXform = (module.exports = function(model) {\n  this.model = model;\n});\n\nutils.inherits(CommentXform, BaseXform, {\n  get tag() {\n    return 'r';\n  },\n\n  get richTextXform() {\n    if (!this._richTextXform) {\n      this._richTextXform = new RichTextXform();\n    }\n    return this._richTextXform;\n  },\n\n  render(xmlStream, model) {\n    model = model || this.model;\n\n    xmlStream.openNode('comment', {\n      ref: model.ref,\n      authorId: 0,\n    });\n    xmlStream.openNode('text');\n    if (model && model.note && model.note.texts) {\n      model.note.texts.forEach(text => {\n        this.richTextXform.render(xmlStream, text);\n      });\n    }\n    xmlStream.closeNode();\n    xmlStream.closeNode();\n  },\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case 'comment':\n        this.model = {\n          type: 'note',\n          note: {\n            texts: [],\n          },\n          ...node.attributes,\n        };\n        return true;\n      case 'r':\n        this.parser = this.richTextXform;\n        this.parser.parseOpen(node);\n        return true;\n      default:\n        return false;\n    }\n  },\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  },\n  parseClose(name) {\n    switch (name) {\n      case 'comment':\n        return false;\n      case 'r':\n        this.model.note.texts.push(this.parser.model);\n        this.parser = undefined;\n        return true;\n      default:\n        if (this.parser) {\n          this.parser.parseClose(name);\n        }\n        return true;\n    }\n  },\n});\n","const XmlStream = require('../../../utils/xml-stream');\n\nconst BaseXform = require('../base-xform');\nconst VmlShapeXform = require('./vml-shape-xform');\n\n// This class is (currently) single purposed to insert the triangle\n// drawing icons on commented cells\nclass VmlNotesXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      'v:shape': new VmlShapeXform(),\n    };\n  }\n\n  get tag() {\n    return 'xml';\n  }\n\n  render(xmlStream, model) {\n    xmlStream.openXml(XmlStream.StdDocAttributes);\n    xmlStream.openNode(this.tag, VmlNotesXform.DRAWING_ATTRIBUTES);\n\n    xmlStream.openNode('o:shapelayout', {'v:ext': 'edit'});\n    xmlStream.leafNode('o:idmap', {'v:ext': 'edit', data: 1});\n    xmlStream.closeNode();\n\n    xmlStream.openNode('v:shapetype', {\n      id: '_x0000_t202',\n      coordsize: '21600,21600',\n      'o:spt': 202,\n      path: 'm,l,21600r21600,l21600,xe',\n    });\n    xmlStream.leafNode('v:stroke', {joinstyle: 'miter'});\n    xmlStream.leafNode('v:path', {gradientshapeok: 't', 'o:connecttype': 'rect'});\n    xmlStream.closeNode();\n\n    model.comments.forEach((item, index) => {\n      this.map['v:shape'].render(xmlStream, item, index);\n    });\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        this.model = {\n          comments: [],\n        };\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.model.comments.push(this.parser.model);\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        // could be some unrecognised tags\n        return true;\n    }\n  }\n\n  reconcile(model, options) {\n    model.anchors.forEach(anchor => {\n      if (anchor.br) {\n        this.map['xdr:twoCellAnchor'].reconcile(anchor, options);\n      } else {\n        this.map['xdr:oneCellAnchor'].reconcile(anchor, options);\n      }\n    });\n  }\n}\n\nVmlNotesXform.DRAWING_ATTRIBUTES = {\n  'xmlns:v': 'urn:schemas-microsoft-com:vml',\n  'xmlns:o': 'urn:schemas-microsoft-com:office:office',\n  'xmlns:x': 'urn:schemas-microsoft-com:office:excel',\n};\n\nmodule.exports = VmlNotesXform;\n","const BaseXform = require('../base-xform');\nconst VmlTextboxXform = require('./vml-textbox-xform');\nconst VmlClientDataXform = require('./vml-client-data-xform');\n\nclass VmlShapeXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      'v:textbox': new VmlTextboxXform(),\n      'x:ClientData': new VmlClientDataXform(),\n    };\n  }\n\n  get tag() {\n    return 'v:shape';\n  }\n\n  render(xmlStream, model, index) {\n    xmlStream.openNode('v:shape', VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index));\n\n    xmlStream.leafNode('v:fill', {color2: 'infoBackground [80]'});\n    xmlStream.leafNode('v:shadow', {color: 'none [81]', obscured: 't'});\n    xmlStream.leafNode('v:path', {'o:connecttype': 'none'});\n    this.map['v:textbox'].render(xmlStream, model);\n    this.map['x:ClientData'].render(xmlStream, model);\n\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    if (this.parser) {\n      this.parser.parseOpen(node);\n      return true;\n    }\n\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        this.model = {\n          margins: {\n            insetmode: node.attributes['o:insetmode'],\n          },\n          anchor: '',\n          editAs: '',\n          protection: {},\n        };\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.model.margins.inset = this.map['v:textbox'].model && this.map['v:textbox'].model.inset;\n        this.model.protection =\n          this.map['x:ClientData'].model && this.map['x:ClientData'].model.protection;\n        this.model.anchor = this.map['x:ClientData'].model && this.map['x:ClientData'].model.anchor;\n        this.model.editAs = this.map['x:ClientData'].model && this.map['x:ClientData'].model.editAs;\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nVmlShapeXform.V_SHAPE_ATTRIBUTES = (model, index) => ({\n  id: `_x0000_s${1025 + index}`,\n  type: '#_x0000_t202',\n  style:\n    'position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden',\n  fillcolor: 'infoBackground [80]',\n  strokecolor: 'none [81]',\n  'o:insetmode': model.note.margins && model.note.margins.insetmode,\n});\n\nmodule.exports = VmlShapeXform;\n","const BaseXform = require('../base-xform');\n\nclass VmlTextboxXform extends BaseXform {\n  get tag() {\n    return 'v:textbox';\n  }\n\n  conversionUnit(value, multiple, unit) {\n    return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;\n  }\n\n  reverseConversionUnit(inset) {\n    return (inset || '').split(',').map(margin => {\n      return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, '')).toFixed(2));\n    });\n  }\n\n  render(xmlStream, model) {\n    const attributes = {\n      style: 'mso-direction-alt:auto',\n    };\n    if (model && model.note) {\n      let {inset} = model.note && model.note.margins;\n      if (Array.isArray(inset)) {\n        inset = inset\n          .map(margin => {\n            return this.conversionUnit(margin, 10, 'mm');\n          })\n          .join(',');\n      }\n      if (inset) {\n        attributes.inset = inset;\n      }\n    }\n    xmlStream.openNode('v:textbox', attributes);\n    xmlStream.leafNode('div', {style: 'text-align:left'});\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {\n          inset: this.reverseConversionUnit(node.attributes.inset),\n        };\n        return true;\n      default:\n        return true;\n    }\n  }\n\n  parseText() {}\n\n  parseClose(name) {\n    switch (name) {\n      case this.tag:\n        return false;\n      default:\n        return true;\n    }\n  }\n}\n\nmodule.exports = VmlTextboxXform;\n","const BaseXform = require('../base-xform');\n\nconst VmlAnchorXform = require('./vml-anchor-xform');\nconst VmlProtectionXform = require('./style/vml-protection-xform');\nconst VmlPositionXform = require('./style/vml-position-xform');\n\nconst POSITION_TYPE = ['twoCells', 'oneCells', 'absolute'];\n\nclass VmlClientDataXform extends BaseXform {\n  constructor() {\n    super();\n    this.map = {\n      'x:Anchor': new VmlAnchorXform(),\n      'x:Locked': new VmlProtectionXform({tag: 'x:Locked'}),\n      'x:LockText': new VmlProtectionXform({tag: 'x:LockText'}),\n      'x:SizeWithCells': new VmlPositionXform({tag: 'x:SizeWithCells'}),\n      'x:MoveWithCells': new VmlPositionXform({tag: 'x:MoveWithCells'}),\n    };\n  }\n\n  get tag() {\n    return 'x:ClientData';\n  }\n\n  render(xmlStream, model) {\n    const {protection, editAs} = model.note;\n    xmlStream.openNode(this.tag, {ObjectType: 'Note'});\n    this.map['x:MoveWithCells'].render(xmlStream, editAs, POSITION_TYPE);\n    this.map['x:SizeWithCells'].render(xmlStream, editAs, POSITION_TYPE);\n    this.map['x:Anchor'].render(xmlStream, model);\n    this.map['x:Locked'].render(xmlStream, protection.locked);\n    xmlStream.leafNode('x:AutoFill', null, 'False');\n    this.map['x:LockText'].render(xmlStream, protection.lockText);\n    xmlStream.leafNode('x:Row', null, model.refAddress.row - 1);\n    xmlStream.leafNode('x:Column', null, model.refAddress.col - 1);\n    xmlStream.closeNode();\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.reset();\n        this.model = {\n          anchor: [],\n          protection: {},\n          editAs: '',\n        };\n        break;\n      default:\n        this.parser = this.map[node.name];\n        if (this.parser) {\n          this.parser.parseOpen(node);\n        }\n        break;\n    }\n    return true;\n  }\n\n  parseText(text) {\n    if (this.parser) {\n      this.parser.parseText(text);\n    }\n  }\n\n  parseClose(name) {\n    if (this.parser) {\n      if (!this.parser.parseClose(name)) {\n        this.parser = undefined;\n      }\n      return true;\n    }\n    switch (name) {\n      case this.tag:\n        this.normalizeModel();\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  normalizeModel() {\n    const position = Object.assign(\n      {},\n      this.map['x:MoveWithCells'].model,\n      this.map['x:SizeWithCells'].model\n    );\n    const len = Object.keys(position).length;\n    this.model.editAs = POSITION_TYPE[len];\n    this.model.anchor = this.map['x:Anchor'].text;\n    this.model.protection.locked = this.map['x:Locked'].text;\n    this.model.protection.lockText = this.map['x:LockText'].text;\n  }\n}\n\nmodule.exports = VmlClientDataXform;\n","const BaseXform = require('../base-xform');\n\n// render the triangle in the cell for the comment\nclass VmlAnchorXform extends BaseXform {\n  get tag() {\n    return 'x:Anchor';\n  }\n\n  getAnchorRect(anchor) {\n    const l = Math.floor(anchor.left);\n    const lf = Math.floor((anchor.left - l) * 68);\n    const t = Math.floor(anchor.top);\n    const tf = Math.floor((anchor.top - t) * 18);\n    const r = Math.floor(anchor.right);\n    const rf = Math.floor((anchor.right - r) * 68);\n    const b = Math.floor(anchor.bottom);\n    const bf = Math.floor((anchor.bottom - b) * 18);\n    return [l, lf, t, tf, r, rf, b, bf];\n  }\n\n  getDefaultRect(ref) {\n    const l = ref.col;\n    const lf = 6;\n    const t = Math.max(ref.row - 2, 0);\n    const tf = 14;\n    const r = l + 2;\n    const rf = 2;\n    const b = t + 4;\n    const bf = 16;\n    return [l, lf, t, tf, r, rf, b, bf];\n  }\n\n  render(xmlStream, model) {\n    const rect = model.anchor\n      ? this.getAnchorRect(model.anchor)\n      : this.getDefaultRect(model.refAddress);\n\n    xmlStream.leafNode('x:Anchor', null, rect.join(', '));\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.text = '';\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    this.text = text;\n  }\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = VmlAnchorXform;\n","const BaseXform = require('../../base-xform');\n\nclass VmlProtectionXform extends BaseXform {\n  constructor(model) {\n    super();\n    this._model = model;\n  }\n\n  get tag() {\n    return this._model && this._model.tag;\n  }\n\n  render(xmlStream, model) {\n    xmlStream.leafNode(this.tag, null, model);\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.text = '';\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText(text) {\n    this.text = text;\n  }\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = VmlProtectionXform;\n","const BaseXform = require('../../base-xform');\n\nclass VmlPositionXform extends BaseXform {\n  constructor(model) {\n    super();\n    this._model = model;\n  }\n\n  get tag() {\n    return this._model && this._model.tag;\n  }\n\n  render(xmlStream, model, type) {\n    if (model === type[2]) {\n      xmlStream.leafNode(this.tag);\n    } else if (this.tag === 'x:SizeWithCells' && model === type[1]) {\n      xmlStream.leafNode(this.tag);\n    }\n  }\n\n  parseOpen(node) {\n    switch (node.name) {\n      case this.tag:\n        this.model = {};\n        this.model[this.tag] = true;\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  parseText() {}\n\n  parseClose() {\n    return false;\n  }\n}\n\nmodule.exports = VmlPositionXform;\n","/* eslint-disable */\nmodule.exports =\n  '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n<a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"> <a:themeElements> <a:clrScheme name=\"Office\"> <a:dk1> <a:sysClr val=\"windowText\" lastClr=\"000000\"/> </a:dk1> <a:lt1> <a:sysClr val=\"window\" lastClr=\"FFFFFF\"/> </a:lt1> <a:dk2> <a:srgbClr val=\"1F497D\"/> </a:dk2> <a:lt2> <a:srgbClr val=\"EEECE1\"/> </a:lt2> <a:accent1> <a:srgbClr val=\"4F81BD\"/> </a:accent1> <a:accent2> <a:srgbClr val=\"C0504D\"/> </a:accent2> <a:accent3> <a:srgbClr val=\"9BBB59\"/> </a:accent3> <a:accent4> <a:srgbClr val=\"8064A2\"/> </a:accent4> <a:accent5> <a:srgbClr val=\"4BACC6\"/> </a:accent5> <a:accent6> <a:srgbClr val=\"F79646\"/> </a:accent6> <a:hlink> <a:srgbClr val=\"0000FF\"/> </a:hlink> <a:folHlink> <a:srgbClr val=\"800080\"/> </a:folHlink> </a:clrScheme> <a:fontScheme name=\"Office\"> <a:majorFont> <a:latin typeface=\"Cambria\"/> <a:ea typeface=\"\"/> <a:cs typeface=\"\"/> <a:font script=\"Jpan\" typeface=\" \"/> <a:font script=\"Hang\" typeface=\" \"/> <a:font script=\"Hans\" typeface=\"\"/> <a:font script=\"Hant\" typeface=\"\"/> <a:font script=\"Arab\" typeface=\"Times New Roman\"/> <a:font script=\"Hebr\" typeface=\"Times New Roman\"/> <a:font script=\"Thai\" typeface=\"Tahoma\"/> <a:font script=\"Ethi\" typeface=\"Nyala\"/> <a:font script=\"Beng\" typeface=\"Vrinda\"/> <a:font script=\"Gujr\" typeface=\"Shruti\"/> <a:font script=\"Khmr\" typeface=\"MoolBoran\"/> <a:font script=\"Knda\" typeface=\"Tunga\"/> <a:font script=\"Guru\" typeface=\"Raavi\"/> <a:font script=\"Cans\" typeface=\"Euphemia\"/> <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/> <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/> <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/> <a:font script=\"Thaa\" typeface=\"MV Boli\"/> <a:font script=\"Deva\" typeface=\"Mangal\"/> <a:font script=\"Telu\" typeface=\"Gautami\"/> <a:font script=\"Taml\" typeface=\"Latha\"/> <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/> <a:font script=\"Orya\" typeface=\"Kalinga\"/> <a:font script=\"Mlym\" typeface=\"Kartika\"/> <a:font script=\"Laoo\" typeface=\"DokChampa\"/> <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/> <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/> <a:font script=\"Viet\" typeface=\"Times New Roman\"/> <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/> <a:font script=\"Geor\" typeface=\"Sylfaen\"/> </a:majorFont> <a:minorFont> <a:latin typeface=\"Calibri\"/> <a:ea typeface=\"\"/> <a:cs typeface=\"\"/> <a:font script=\"Jpan\" typeface=\" \"/> <a:font script=\"Hang\" typeface=\" \"/> <a:font script=\"Hans\" typeface=\"\"/> <a:font script=\"Hant\" typeface=\"\"/> <a:font script=\"Arab\" typeface=\"Arial\"/> <a:font script=\"Hebr\" typeface=\"Arial\"/> <a:font script=\"Thai\" typeface=\"Tahoma\"/> <a:font script=\"Ethi\" typeface=\"Nyala\"/> <a:font script=\"Beng\" typeface=\"Vrinda\"/> <a:font script=\"Gujr\" typeface=\"Shruti\"/> <a:font script=\"Khmr\" typeface=\"DaunPenh\"/> <a:font script=\"Knda\" typeface=\"Tunga\"/> <a:font script=\"Guru\" typeface=\"Raavi\"/> <a:font script=\"Cans\" typeface=\"Euphemia\"/> <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/> <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/> <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/> <a:font script=\"Thaa\" typeface=\"MV Boli\"/> <a:font script=\"Deva\" typeface=\"Mangal\"/> <a:font script=\"Telu\" typeface=\"Gautami\"/> <a:font script=\"Taml\" typeface=\"Latha\"/> <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/> <a:font script=\"Orya\" typeface=\"Kalinga\"/> <a:font script=\"Mlym\" typeface=\"Kartika\"/> <a:font script=\"Laoo\" typeface=\"DokChampa\"/> <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/> <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/> <a:font script=\"Viet\" typeface=\"Arial\"/> <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/> <a:font script=\"Geor\" typeface=\"Sylfaen\"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name=\"Office\"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"50000\"/> <a:satMod val=\"300000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"35000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"37000\"/> <a:satMod val=\"300000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"15000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang=\"16200000\" scaled=\"1\"/> </a:gradFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"100000\"/> <a:shade val=\"100000\"/> <a:satMod val=\"130000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"50000\"/> <a:shade val=\"100000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang=\"16200000\" scaled=\"0\"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"> <a:solidFill> <a:schemeClr val=\"phClr\"> <a:shade val=\"95000\"/> <a:satMod val=\"105000\"/> </a:schemeClr> </a:solidFill> <a:prstDash val=\"solid\"/> </a:ln> <a:ln w=\"25400\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:prstDash val=\"solid\"/> </a:ln> <a:ln w=\"38100\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:prstDash val=\"solid\"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad=\"40000\" dist=\"20000\" dir=\"5400000\" rotWithShape=\"0\"> <a:srgbClr val=\"000000\"> <a:alpha val=\"38000\"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\"> <a:srgbClr val=\"000000\"> <a:alpha val=\"35000\"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\"> <a:srgbClr val=\"000000\"> <a:alpha val=\"35000\"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst=\"orthographicFront\"> <a:rot lat=\"0\" lon=\"0\" rev=\"0\"/> </a:camera> <a:lightRig rig=\"threePt\" dir=\"t\"> <a:rot lat=\"0\" lon=\"0\" rev=\"1200000\"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w=\"63500\" h=\"25400\"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val=\"phClr\"/> </a:solidFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"40000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"40000\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"45000\"/> <a:shade val=\"99000\"/> <a:satMod val=\"350000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:shade val=\"20000\"/> <a:satMod val=\"255000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path=\"circle\"> <a:fillToRect l=\"50000\" t=\"-80000\" r=\"50000\" b=\"180000\"/> </a:path> </a:gradFill> <a:gradFill rotWithShape=\"1\"> <a:gsLst> <a:gs pos=\"0\"> <a:schemeClr val=\"phClr\"> <a:tint val=\"80000\"/> <a:satMod val=\"300000\"/> </a:schemeClr> </a:gs> <a:gs pos=\"100000\"> <a:schemeClr val=\"phClr\"> <a:shade val=\"30000\"/> <a:satMod val=\"200000\"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path=\"circle\"> <a:fillToRect l=\"50000\" t=\"50000\" r=\"50000\" b=\"50000\"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx=\"1\"> <a:schemeClr val=\"accent1\"/> </a:lnRef> <a:fillRef idx=\"3\"> <a:schemeClr val=\"accent1\"/> </a:fillRef> <a:effectRef idx=\"2\"> <a:schemeClr val=\"accent1\"/> </a:effectRef> <a:fontRef idx=\"minor\"> <a:schemeClr val=\"lt1\"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx=\"2\"> <a:schemeClr val=\"accent1\"/> </a:lnRef> <a:fillRef idx=\"0\"> <a:schemeClr val=\"accent1\"/> </a:fillRef> <a:effectRef idx=\"1\"> <a:schemeClr val=\"accent1\"/> </a:effectRef> <a:fontRef idx=\"minor\"> <a:schemeClr val=\"tx1\"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';\n","const fs = require('fs');\nconst fastCsv = require('fast-csv');\nconst customParseFormat = require('dayjs/plugin/customParseFormat');\nconst utc = require('dayjs/plugin/utc');\nconst dayjs = require('dayjs').extend(customParseFormat).extend(utc);\nconst StreamBuf = require('../utils/stream-buf');\n\nconst {\n  fs: {exists},\n} = require('../utils/utils');\n\n/* eslint-disable quote-props */\nconst SpecialValues = {\n  true: true,\n  false: false,\n  '#N/A': {error: '#N/A'},\n  '#REF!': {error: '#REF!'},\n  '#NAME?': {error: '#NAME?'},\n  '#DIV/0!': {error: '#DIV/0!'},\n  '#NULL!': {error: '#NULL!'},\n  '#VALUE!': {error: '#VALUE!'},\n  '#NUM!': {error: '#NUM!'},\n};\n/* eslint-ensable quote-props */\n\nclass CSV {\n  constructor(workbook) {\n    this.workbook = workbook;\n    this.worksheet = null;\n  }\n\n  async readFile(filename, options) {\n    options = options || {};\n    if (!(await exists(filename))) {\n      throw new Error(`File not found: ${filename}`);\n    }\n    const stream = fs.createReadStream(filename);\n    const worksheet = await this.read(stream, options);\n    stream.close();\n    return worksheet;\n  }\n\n  read(stream, options) {\n    options = options || {};\n\n    return new Promise((resolve, reject) => {\n      const worksheet = this.workbook.addWorksheet(options.sheetName);\n\n      const dateFormats = options.dateFormats || [\n        'YYYY-MM-DD[T]HH:mm:ssZ',\n        'YYYY-MM-DD[T]HH:mm:ss',\n        'MM-DD-YYYY',\n        'YYYY-MM-DD',\n      ];\n      const map =\n        options.map ||\n        function(datum) {\n          if (datum === '') {\n            return null;\n          }\n          const datumNumber = Number(datum);\n          if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {\n            return datumNumber;\n          }\n          const dt = dateFormats.reduce((matchingDate, currentDateFormat) => {\n            if (matchingDate) {\n              return matchingDate;\n            }\n            const dayjsObj = dayjs(datum, currentDateFormat, true);\n            if (dayjsObj.isValid()) {\n              return dayjsObj;\n            }\n            return null;\n          }, null);\n          if (dt) {\n            return new Date(dt.valueOf());\n          }\n          const special = SpecialValues[datum];\n          if (special !== undefined) {\n            return special;\n          }\n          return datum;\n        };\n\n      const csvStream = fastCsv\n        .parse(options.parserOptions)\n        .on('data', data => {\n          worksheet.addRow(data.map(map));\n        })\n        .on('end', () => {\n          csvStream.emit('worksheet', worksheet);\n        });\n\n      csvStream.on('worksheet', resolve).on('error', reject);\n\n      stream.pipe(csvStream);\n    });\n  }\n\n  /**\n   * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md\n   */\n  createInputStream() {\n    throw new Error(\n      '`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md'\n    );\n  }\n\n  write(stream, options) {\n    return new Promise((resolve, reject) => {\n      options = options || {};\n      // const encoding = options.encoding || 'utf8';\n      // const separator = options.separator || ',';\n      // const quoteChar = options.quoteChar || '\\'';\n\n      const worksheet = this.workbook.getWorksheet(options.sheetName || options.sheetId);\n\n      const csvStream = fastCsv.format(options.formatterOptions);\n      stream.on('finish', () => {\n        resolve();\n      });\n      csvStream.on('error', reject);\n      csvStream.pipe(stream);\n\n      const {dateFormat, dateUTC} = options;\n      const map =\n        options.map ||\n        (value => {\n          if (value) {\n            if (value.text || value.hyperlink) {\n              return value.hyperlink || value.text || '';\n            }\n            if (value.formula || value.result) {\n              return value.result || '';\n            }\n            if (value instanceof Date) {\n              if (dateFormat) {\n                return dateUTC\n                  ? dayjs.utc(value).format(dateFormat)\n                  : dayjs(value).format(dateFormat);\n              }\n              return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();\n            }\n            if (value.error) {\n              return value.error;\n            }\n            if (typeof value === 'object') {\n              return JSON.stringify(value);\n            }\n          }\n          return value;\n        });\n\n      const includeEmptyRows = options.includeEmptyRows === undefined || options.includeEmptyRows;\n      let lastRow = 1;\n      if (worksheet) {\n        worksheet.eachRow((row, rowNumber) => {\n          if (includeEmptyRows) {\n            while (lastRow++ < rowNumber - 1) {\n              csvStream.write([]);\n            }\n          }\n          const {values} = row;\n          values.shift();\n          csvStream.write(values.map(map));\n          lastRow = rowNumber;\n        });\n      }\n      csvStream.end();\n    });\n  }\n\n  writeFile(filename, options) {\n    options = options || {};\n\n    const streamOptions = {\n      encoding: options.encoding || 'utf8',\n    };\n    const stream = fs.createWriteStream(filename, streamOptions);\n\n    return this.write(stream, options);\n  }\n\n  async writeBuffer(options) {\n    const stream = new StreamBuf();\n    await this.write(stream, options);\n    return stream.read();\n  }\n}\n\nmodule.exports = CSV;\n","\n\nconst XLSX = require('../xlsx/xlsx');\n\nclass ModelContainer {\n  constructor(model) {\n    this.model = model;\n  }\n\n  get xlsx() {\n    if (!this._xlsx) {\n      this._xlsx = new XLSX(this);\n    }\n    return this._xlsx;\n  }\n}\n\nmodule.exports = ModelContainer;\n","const fs = require('fs');\nconst Archiver = require('archiver');\n\nconst StreamBuf = require('../../utils/stream-buf');\n\nconst RelType = require('../../xlsx/rel-type');\nconst StylesXform = require('../../xlsx/xform/style/styles-xform');\nconst SharedStrings = require('../../utils/shared-strings');\nconst DefinedNames = require('../../doc/defined-names');\n\nconst CoreXform = require('../../xlsx/xform/core/core-xform');\nconst RelationshipsXform = require('../../xlsx/xform/core/relationships-xform');\nconst ContentTypesXform = require('../../xlsx/xform/core/content-types-xform');\nconst AppXform = require('../../xlsx/xform/core/app-xform');\nconst WorkbookXform = require('../../xlsx/xform/book/workbook-xform');\nconst SharedStringsXform = require('../../xlsx/xform/strings/shared-strings-xform');\n\nconst WorksheetWriter = require('./worksheet-writer');\n\nconst theme1Xml = require('../../xlsx/xml/theme1.js');\n\nclass WorkbookWriter {\n  constructor(options) {\n    options = options || {};\n\n    this.created = options.created || new Date();\n    this.modified = options.modified || this.created;\n    this.creator = options.creator || 'ExcelJS';\n    this.lastModifiedBy = options.lastModifiedBy || 'ExcelJS';\n    this.lastPrinted = options.lastPrinted;\n\n    // using shared strings creates a smaller xlsx file but may use more memory\n    this.useSharedStrings = options.useSharedStrings || false;\n    this.sharedStrings = new SharedStrings();\n\n    // style manager\n    this.styles = options.useStyles ? new StylesXform(true) : new StylesXform.Mock(true);\n\n    // defined names\n    this._definedNames = new DefinedNames();\n\n    this._worksheets = [];\n    this.views = [];\n\n    this.zipOptions = options.zip;\n\n    this.media = [];\n    this.commentRefs = [];\n\n    this.zip = Archiver('zip', this.zipOptions);\n    if (options.stream) {\n      this.stream = options.stream;\n    } else if (options.filename) {\n      this.stream = fs.createWriteStream(options.filename);\n    } else {\n      this.stream = new StreamBuf();\n    }\n    this.zip.pipe(this.stream);\n\n    // these bits can be added right now\n    this.promise = Promise.all([this.addThemes(), this.addOfficeRels()]);\n  }\n\n  get definedNames() {\n    return this._definedNames;\n  }\n\n  _openStream(path) {\n    const stream = new StreamBuf({bufSize: 65536, batch: true});\n    this.zip.append(stream, {name: path});\n    stream.on('finish', () => {\n      stream.emit('zipped');\n    });\n    return stream;\n  }\n\n  _commitWorksheets() {\n    const commitWorksheet = function(worksheet) {\n      if (!worksheet.committed) {\n        return new Promise(resolve => {\n          worksheet.stream.on('zipped', () => {\n            resolve();\n          });\n          worksheet.commit();\n        });\n      }\n      return Promise.resolve();\n    };\n    // if there are any uncommitted worksheets, commit them now and wait\n    const promises = this._worksheets.map(commitWorksheet);\n    if (promises.length) {\n      return Promise.all(promises);\n    }\n    return Promise.resolve();\n  }\n\n  async commit() {\n    // commit all worksheets, then add suplimentary files\n    await this.promise;\n    await this.addMedia();\n    await this._commitWorksheets();\n    await Promise.all([\n      this.addContentTypes(),\n      this.addApp(),\n      this.addCore(),\n      this.addSharedStrings(),\n      this.addStyles(),\n      this.addWorkbookRels(),\n    ]);\n    await this.addWorkbook();\n    return this._finalize();\n  }\n\n  get nextId() {\n    // find the next unique spot to add worksheet\n    let i;\n    for (i = 1; i < this._worksheets.length; i++) {\n      if (!this._worksheets[i]) {\n        return i;\n      }\n    }\n    return this._worksheets.length || 1;\n  }\n\n  addImage(image) {\n    const id = this.media.length;\n    const medium = Object.assign({}, image, {type: 'image', name: `image${id}.${image.extension}`});\n    this.media.push(medium);\n    return id;\n  }\n\n  getImage(id) {\n    return this.media[id];\n  }\n\n  addWorksheet(name, options) {\n    // it's possible to add a worksheet with different than default\n    // shared string handling\n    // in fact, it's even possible to switch it mid-sheet\n    options = options || {};\n    const useSharedStrings =\n      options.useSharedStrings !== undefined ? options.useSharedStrings : this.useSharedStrings;\n\n    if (options.tabColor) {\n      // eslint-disable-next-line no-console\n      console.trace('tabColor option has moved to { properties: tabColor: {...} }');\n      options.properties = Object.assign(\n        {\n          tabColor: options.tabColor,\n        },\n        options.properties\n      );\n    }\n\n    const id = this.nextId;\n    name = name || `sheet${id}`;\n\n    const worksheet = new WorksheetWriter({\n      id,\n      name,\n      workbook: this,\n      useSharedStrings,\n      properties: options.properties,\n      state: options.state,\n      pageSetup: options.pageSetup,\n      views: options.views,\n      autoFilter: options.autoFilter,\n      headerFooter: options.headerFooter,\n    });\n\n    this._worksheets[id] = worksheet;\n    return worksheet;\n  }\n\n  getWorksheet(id) {\n    if (id === undefined) {\n      return this._worksheets.find(() => true);\n    }\n    if (typeof id === 'number') {\n      return this._worksheets[id];\n    }\n    if (typeof id === 'string') {\n      return this._worksheets.find(worksheet => worksheet && worksheet.name === id);\n    }\n    return undefined;\n  }\n\n  addStyles() {\n    return new Promise(resolve => {\n      this.zip.append(this.styles.xml, {name: 'xl/styles.xml'});\n      resolve();\n    });\n  }\n\n  addThemes() {\n    return new Promise(resolve => {\n      this.zip.append(theme1Xml, {name: 'xl/theme/theme1.xml'});\n      resolve();\n    });\n  }\n\n  addOfficeRels() {\n    return new Promise(resolve => {\n      const xform = new RelationshipsXform();\n      const xml = xform.toXml([\n        {Id: 'rId1', Type: RelType.OfficeDocument, Target: 'xl/workbook.xml'},\n        {Id: 'rId2', Type: RelType.CoreProperties, Target: 'docProps/core.xml'},\n        {Id: 'rId3', Type: RelType.ExtenderProperties, Target: 'docProps/app.xml'},\n      ]);\n      this.zip.append(xml, {name: '/_rels/.rels'});\n      resolve();\n    });\n  }\n\n  addContentTypes() {\n    return new Promise(resolve => {\n      const model = {\n        worksheets: this._worksheets.filter(Boolean),\n        sharedStrings: this.sharedStrings,\n        commentRefs: this.commentRefs,\n        media: this.media,\n      };\n      const xform = new ContentTypesXform();\n      const xml = xform.toXml(model);\n      this.zip.append(xml, {name: '[Content_Types].xml'});\n      resolve();\n    });\n  }\n\n  addMedia() {\n    return Promise.all(\n      this.media.map(medium => {\n        if (medium.type === 'image') {\n          const filename = `xl/media/${medium.name}`;\n          if (medium.filename) {\n            return this.zip.file(medium.filename, {name: filename});\n          }\n          if (medium.buffer) {\n            return this.zip.append(medium.buffer, {name: filename});\n          }\n          if (medium.base64) {\n            const dataimg64 = medium.base64;\n            const content = dataimg64.substring(dataimg64.indexOf(',') + 1);\n            return this.zip.append(content, {name: filename, base64: true});\n          }\n        }\n        throw new Error('Unsupported media');\n      })\n    );\n  }\n\n  addApp() {\n    return new Promise(resolve => {\n      const model = {\n        worksheets: this._worksheets.filter(Boolean),\n      };\n      const xform = new AppXform();\n      const xml = xform.toXml(model);\n      this.zip.append(xml, {name: 'docProps/app.xml'});\n      resolve();\n    });\n  }\n\n  addCore() {\n    return new Promise(resolve => {\n      const coreXform = new CoreXform();\n      const xml = coreXform.toXml(this);\n      this.zip.append(xml, {name: 'docProps/core.xml'});\n      resolve();\n    });\n  }\n\n  addSharedStrings() {\n    if (this.sharedStrings.count) {\n      return new Promise(resolve => {\n        const sharedStringsXform = new SharedStringsXform();\n        const xml = sharedStringsXform.toXml(this.sharedStrings);\n        this.zip.append(xml, {name: '/xl/sharedStrings.xml'});\n        resolve();\n      });\n    }\n    return Promise.resolve();\n  }\n\n  addWorkbookRels() {\n    let count = 1;\n    const relationships = [\n      {Id: `rId${count++}`, Type: RelType.Styles, Target: 'styles.xml'},\n      {Id: `rId${count++}`, Type: RelType.Theme, Target: 'theme/theme1.xml'},\n    ];\n    if (this.sharedStrings.count) {\n      relationships.push({\n        Id: `rId${count++}`,\n        Type: RelType.SharedStrings,\n        Target: 'sharedStrings.xml',\n      });\n    }\n    this._worksheets.forEach(worksheet => {\n      if (worksheet) {\n        worksheet.rId = `rId${count++}`;\n        relationships.push({\n          Id: worksheet.rId,\n          Type: RelType.Worksheet,\n          Target: `worksheets/sheet${worksheet.id}.xml`,\n        });\n      }\n    });\n    return new Promise(resolve => {\n      const xform = new RelationshipsXform();\n      const xml = xform.toXml(relationships);\n      this.zip.append(xml, {name: '/xl/_rels/workbook.xml.rels'});\n      resolve();\n    });\n  }\n\n  addWorkbook() {\n    const {zip} = this;\n    const model = {\n      worksheets: this._worksheets.filter(Boolean),\n      definedNames: this._definedNames.model,\n      views: this.views,\n      properties: {},\n      calcProperties: {},\n    };\n\n    return new Promise(resolve => {\n      const xform = new WorkbookXform();\n      xform.prepare(model);\n      zip.append(xform.toXml(model), {name: '/xl/workbook.xml'});\n      resolve();\n    });\n  }\n\n  _finalize() {\n    return new Promise((resolve, reject) => {\n      this.stream.on('error', reject);\n      this.stream.on('finish', () => {\n        resolve(this);\n      });\n      this.zip.on('error', reject);\n\n      this.zip.finalize();\n    });\n  }\n}\n\nmodule.exports = WorkbookWriter;\n","class SharedStrings {\n  constructor() {\n    this._values = [];\n    this._totalRefs = 0;\n    this._hash = Object.create(null);\n  }\n\n  get count() {\n    return this._values.length;\n  }\n\n  get values() {\n    return this._values;\n  }\n\n  get totalRefs() {\n    return this._totalRefs;\n  }\n\n  getString(index) {\n    return this._values[index];\n  }\n\n  add(value) {\n    let index = this._hash[value];\n    if (index === undefined) {\n      index = this._hash[value] = this._values.length;\n      this._values.push(value);\n    }\n    this._totalRefs++;\n    return index;\n  }\n}\n\nmodule.exports = SharedStrings;\n","const _ = require('../../utils/under-dash');\n\nconst RelType = require('../../xlsx/rel-type');\n\nconst colCache = require('../../utils/col-cache');\nconst Encryptor = require('../../utils/encryptor');\nconst Dimensions = require('../../doc/range');\nconst StringBuf = require('../../utils/string-buf');\n\nconst Row = require('../../doc/row');\nconst Column = require('../../doc/column');\n\nconst SheetRelsWriter = require('./sheet-rels-writer');\nconst SheetCommentsWriter = require('./sheet-comments-writer');\nconst DataValidations = require('../../doc/data-validations');\n\nconst xmlBuffer = new StringBuf();\n\n// ============================================================================================\n// Xforms\nconst ListXform = require('../../xlsx/xform/list-xform');\nconst DataValidationsXform = require('../../xlsx/xform/sheet/data-validations-xform');\nconst SheetPropertiesXform = require('../../xlsx/xform/sheet/sheet-properties-xform');\nconst SheetFormatPropertiesXform = require('../../xlsx/xform/sheet/sheet-format-properties-xform');\nconst ColXform = require('../../xlsx/xform/sheet/col-xform');\nconst RowXform = require('../../xlsx/xform/sheet/row-xform');\nconst HyperlinkXform = require('../../xlsx/xform/sheet/hyperlink-xform');\nconst SheetViewXform = require('../../xlsx/xform/sheet/sheet-view-xform');\nconst SheetProtectionXform = require('../../xlsx/xform/sheet/sheet-protection-xform');\nconst PageMarginsXform = require('../../xlsx/xform/sheet/page-margins-xform');\nconst PageSetupXform = require('../../xlsx/xform/sheet/page-setup-xform');\nconst AutoFilterXform = require('../../xlsx/xform/sheet/auto-filter-xform');\nconst PictureXform = require('../../xlsx/xform/sheet/picture-xform');\nconst ConditionalFormattingsXform = require('../../xlsx/xform/sheet/cf/conditional-formattings-xform');\nconst HeaderFooterXform = require('../../xlsx/xform/sheet/header-footer-xform');\nconst RowBreaksXform = require('../../xlsx/xform/sheet/row-breaks-xform');\n\n// since prepare and render are functional, we can use singletons\nconst xform = {\n  dataValidations: new DataValidationsXform(),\n  sheetProperties: new SheetPropertiesXform(),\n  sheetFormatProperties: new SheetFormatPropertiesXform(),\n  columns: new ListXform({tag: 'cols', length: false, childXform: new ColXform()}),\n  row: new RowXform(),\n  hyperlinks: new ListXform({tag: 'hyperlinks', length: false, childXform: new HyperlinkXform()}),\n  sheetViews: new ListXform({tag: 'sheetViews', length: false, childXform: new SheetViewXform()}),\n  sheetProtection: new SheetProtectionXform(),\n  pageMargins: new PageMarginsXform(),\n  pageSeteup: new PageSetupXform(),\n  autoFilter: new AutoFilterXform(),\n  picture: new PictureXform(),\n  conditionalFormattings: new ConditionalFormattingsXform(),\n  headerFooter: new HeaderFooterXform(),\n  rowBreaks: new RowBreaksXform(),\n};\n\n// ============================================================================================\n\nclass WorksheetWriter {\n  constructor(options) {\n    // in a workbook, each sheet will have a number\n    this.id = options.id;\n\n    // and a name\n    this.name = options.name || `Sheet${this.id}`;\n\n    // add a state\n    this.state = options.state || 'visible';\n\n    // rows are stored here while they need to be worked on.\n    // when they are committed, they will be deleted.\n    this._rows = [];\n\n    // column definitions\n    this._columns = null;\n\n    // column keys (addRow convenience): key ==> this._columns index\n    this._keys = {};\n\n    // keep a record of all row and column pageBreaks\n    this._merges = [];\n    this._merges.add = function() {}; // ignore cell instruction\n\n    // keep record of all hyperlinks\n    this._sheetRelsWriter = new SheetRelsWriter(options);\n\n    this._sheetCommentsWriter = new SheetCommentsWriter(this, this._sheetRelsWriter, options);\n\n    // keep a record of dimensions\n    this._dimensions = new Dimensions();\n\n    // first uncommitted row\n    this._rowZero = 1;\n\n    // committed flag\n    this.committed = false;\n\n    // for data validations\n    this.dataValidations = new DataValidations();\n\n    // for sharing formulae\n    this._formulae = {};\n    this._siFormulae = 0;\n\n    // keep a record of conditionalFormattings\n    this.conditionalFormatting = [];\n\n    // keep a record of all row and column pageBreaks\n    this.rowBreaks = [];\n\n    // for default row height, outline levels, etc\n    this.properties = Object.assign(\n      {},\n      {\n        defaultRowHeight: 15,\n        dyDescent: 55,\n        outlineLevelCol: 0,\n        outlineLevelRow: 0,\n      },\n      options.properties\n    );\n\n    this.headerFooter = Object.assign(\n      {},\n      {\n        differentFirst: false,\n        differentOddEven: false,\n        oddHeader: null,\n        oddFooter: null,\n        evenHeader: null,\n        evenFooter: null,\n        firstHeader: null,\n        firstFooter: null,\n      },\n      options.headerFooter\n    );\n\n    // for all things printing\n    this.pageSetup = Object.assign(\n      {},\n      {\n        margins: {left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3},\n        orientation: 'portrait',\n        horizontalDpi: 4294967295,\n        verticalDpi: 4294967295,\n        fitToPage: !!(\n          options.pageSetup &&\n          (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) &&\n          !options.pageSetup.scale\n        ),\n        pageOrder: 'downThenOver',\n        blackAndWhite: false,\n        draft: false,\n        cellComments: 'None',\n        errors: 'displayed',\n        scale: 100,\n        fitToWidth: 1,\n        fitToHeight: 1,\n        paperSize: undefined,\n        showRowColHeaders: false,\n        showGridLines: false,\n        horizontalCentered: false,\n        verticalCentered: false,\n        rowBreaks: null,\n        colBreaks: null,\n      },\n      options.pageSetup\n    );\n\n    // using shared strings creates a smaller xlsx file but may use more memory\n    this.useSharedStrings = options.useSharedStrings || false;\n\n    this._workbook = options.workbook;\n\n    this.hasComments = false;\n\n    // views\n    this._views = options.views || [];\n\n    // auto filter\n    this.autoFilter = options.autoFilter || null;\n\n    this._media = [];\n\n    // worksheet protection\n    this.sheetProtection = null;\n\n    // start writing to stream now\n    this._writeOpenWorksheet();\n\n    this.startedData = false;\n  }\n\n  get workbook() {\n    return this._workbook;\n  }\n\n  get stream() {\n    if (!this._stream) {\n      // eslint-disable-next-line no-underscore-dangle\n      this._stream = this._workbook._openStream(`/xl/worksheets/sheet${this.id}.xml`);\n\n      // pause stream to prevent 'data' events\n      this._stream.pause();\n    }\n    return this._stream;\n  }\n\n  // destroy - not a valid operation for a streaming writer\n  // even though some streamers might be able to, it's a bad idea.\n  destroy() {\n    throw new Error('Invalid Operation: destroy');\n  }\n\n  commit() {\n    if (this.committed) {\n      return;\n    }\n    // commit all rows\n    this._rows.forEach(cRow => {\n      if (cRow) {\n        // write the row to the stream\n        this._writeRow(cRow);\n      }\n    });\n\n    // we _cannot_ accept new rows from now on\n    this._rows = null;\n\n    if (!this.startedData) {\n      this._writeOpenSheetData();\n    }\n    this._writeCloseSheetData();\n    this._writeAutoFilter();\n    this._writeMergeCells();\n\n    // for some reason, Excel can't handle dimensions at the bottom of the file\n    // this._writeDimensions();\n\n    this._writeHyperlinks();\n    this._writeConditionalFormatting();\n    this._writeDataValidations();\n    this._writeSheetProtection();\n    this._writePageMargins();\n    this._writePageSetup();\n    this._writeBackground();\n    this._writeHeaderFooter();\n    this._writeRowBreaks();\n\n    // Legacy Data tag for comments\n    this._writeLegacyData();\n\n    this._writeCloseWorksheet();\n    // signal end of stream to workbook\n    this.stream.end();\n\n    this._sheetCommentsWriter.commit();\n    // also commit the hyperlinks if any\n    this._sheetRelsWriter.commit();\n\n    this.committed = true;\n  }\n\n  // return the current dimensions of the writer\n  get dimensions() {\n    return this._dimensions;\n  }\n\n  get views() {\n    return this._views;\n  }\n\n  // =========================================================================\n  // Columns\n\n  // get the current columns array.\n  get columns() {\n    return this._columns;\n  }\n\n  // set the columns from an array of column definitions.\n  // Note: any headers defined will overwrite existing values.\n  set columns(value) {\n    // calculate max header row count\n    this._headerRowCount = value.reduce((pv, cv) => {\n      const headerCount = (cv.header && 1) || (cv.headers && cv.headers.length) || 0;\n      return Math.max(pv, headerCount);\n    }, 0);\n\n    // construct Column objects\n    let count = 1;\n    const columns = (this._columns = []);\n    value.forEach(defn => {\n      const column = new Column(this, count++, false);\n      columns.push(column);\n      column.defn = defn;\n    });\n  }\n\n  getColumnKey(key) {\n    return this._keys[key];\n  }\n\n  setColumnKey(key, value) {\n    this._keys[key] = value;\n  }\n\n  deleteColumnKey(key) {\n    delete this._keys[key];\n  }\n\n  eachColumnKey(f) {\n    _.each(this._keys, f);\n  }\n\n  // get a single column by col number. If it doesn't exist, it and any gaps before it\n  // are created.\n  getColumn(c) {\n    if (typeof c === 'string') {\n      // if it matches a key'd column, return that\n      const col = this._keys[c];\n      if (col) return col;\n\n      // otherwise, assume letter\n      c = colCache.l2n(c);\n    }\n    if (!this._columns) {\n      this._columns = [];\n    }\n    if (c > this._columns.length) {\n      let n = this._columns.length + 1;\n      while (n <= c) {\n        this._columns.push(new Column(this, n++));\n      }\n    }\n    return this._columns[c - 1];\n  }\n\n  // =========================================================================\n  // Rows\n  get _nextRow() {\n    return this._rowZero + this._rows.length;\n  }\n\n  // iterate over every uncommitted row in the worksheet, including maybe empty rows\n  eachRow(options, iteratee) {\n    if (!iteratee) {\n      iteratee = options;\n      options = undefined;\n    }\n    if (options && options.includeEmpty) {\n      const n = this._nextRow;\n      for (let i = this._rowZero; i < n; i++) {\n        iteratee(this.getRow(i), i);\n      }\n    } else {\n      this._rows.forEach(row => {\n        if (row.hasValues) {\n          iteratee(row, row.number);\n        }\n      });\n    }\n  }\n\n  _commitRow(cRow) {\n    // since rows must be written in order, we commit all rows up till and including cRow\n    let found = false;\n    while (this._rows.length && !found) {\n      const row = this._rows.shift();\n      this._rowZero++;\n      if (row) {\n        this._writeRow(row);\n        found = row.number === cRow.number;\n        this._rowZero = row.number + 1;\n      }\n    }\n  }\n\n  get lastRow() {\n    // returns last uncommitted row\n    if (this._rows.length) {\n      return this._rows[this._rows.length - 1];\n    }\n    return undefined;\n  }\n\n  // find a row (if exists) by row number\n  findRow(rowNumber) {\n    const index = rowNumber - this._rowZero;\n    return this._rows[index];\n  }\n\n  getRow(rowNumber) {\n    const index = rowNumber - this._rowZero;\n\n    // may fail if rows have been comitted\n    if (index < 0) {\n      throw new Error('Out of bounds: this row has been committed');\n    }\n    let row = this._rows[index];\n    if (!row) {\n      this._rows[index] = row = new Row(this, rowNumber);\n    }\n    return row;\n  }\n\n  addRow(value) {\n    const row = new Row(this, this._nextRow);\n    this._rows[row.number - this._rowZero] = row;\n    row.values = value;\n    return row;\n  }\n\n  // ================================================================================\n  // Cells\n\n  // returns the cell at [r,c] or address given by r. If not found, return undefined\n  findCell(r, c) {\n    const address = colCache.getAddress(r, c);\n    const row = this.findRow(address.row);\n    return row ? row.findCell(address.column) : undefined;\n  }\n\n  // return the cell at [r,c] or address given by r. If not found, create a new one.\n  getCell(r, c) {\n    const address = colCache.getAddress(r, c);\n    const row = this.getRow(address.row);\n    return row.getCellEx(address);\n  }\n\n  mergeCells(...cells) {\n    // may fail if rows have been comitted\n    const dimensions = new Dimensions(cells);\n\n    // check cells aren't already merged\n    this._merges.forEach(merge => {\n      if (merge.intersects(dimensions)) {\n        throw new Error('Cannot merge already merged cells');\n      }\n    });\n\n    // apply merge\n    const master = this.getCell(dimensions.top, dimensions.left);\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\n        if (i > dimensions.top || j > dimensions.left) {\n          this.getCell(i, j).merge(master);\n        }\n      }\n    }\n\n    // index merge\n    this._merges.push(dimensions);\n  }\n\n  // ===========================================================================\n  // Conditional Formatting\n  addConditionalFormatting(cf) {\n    this.conditionalFormatting.push(cf);\n  }\n\n  removeConditionalFormatting(filter) {\n    if (typeof filter === 'number') {\n      this.conditionalFormatting.splice(filter, 1);\n    } else if (filter instanceof Function) {\n      this.conditionalFormatting = this.conditionalFormatting.filter(filter);\n    } else {\n      this.conditionalFormatting = [];\n    }\n  }\n\n  // =========================================================================\n\n  addBackgroundImage(imageId) {\n    this._background = {\n      imageId,\n    };\n  }\n\n  getBackgroundImageId() {\n    return this._background && this._background.imageId;\n  }\n\n  // =========================================================================\n  // Worksheet Protection\n  protect(password, options) {\n    // TODO: make this function truly async\n    // perhaps marshal to worker thread or something\n    return new Promise(resolve => {\n      this.sheetProtection = {\n        sheet: true,\n      };\n      if (options && 'spinCount' in options) {\n        // force spinCount to be integer >= 0\n        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;\n      }\n      if (password) {\n        this.sheetProtection.algorithmName = 'SHA-512';\n        this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString('base64');\n        this.sheetProtection.spinCount = options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount\n        this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(\n          password,\n          'SHA512',\n          this.sheetProtection.saltValue,\n          this.sheetProtection.spinCount\n        );\n      }\n      if (options) {\n        this.sheetProtection = Object.assign(this.sheetProtection, options);\n        if (!password && 'spinCount' in options) {\n          delete this.sheetProtection.spinCount;\n        }\n      }\n      resolve();\n    });\n  }\n\n  unprotect() {\n    this.sheetProtection = null;\n  }\n\n  // ================================================================================\n\n  _write(text) {\n    xmlBuffer.reset();\n    xmlBuffer.addText(text);\n    this.stream.write(xmlBuffer);\n  }\n\n  _writeSheetProperties(xmlBuf, properties, pageSetup) {\n    const sheetPropertiesModel = {\n      outlineProperties: properties && properties.outlineProperties,\n      tabColor: properties && properties.tabColor,\n      pageSetup:\n        pageSetup && pageSetup.fitToPage\n          ? {\n              fitToPage: pageSetup.fitToPage,\n            }\n          : undefined,\n    };\n\n    xmlBuf.addText(xform.sheetProperties.toXml(sheetPropertiesModel));\n  }\n\n  _writeSheetFormatProperties(xmlBuf, properties) {\n    const sheetFormatPropertiesModel = properties\n      ? {\n          defaultRowHeight: properties.defaultRowHeight,\n          dyDescent: properties.dyDescent,\n          outlineLevelCol: properties.outlineLevelCol,\n          outlineLevelRow: properties.outlineLevelRow,\n        }\n      : undefined;\n    if (properties.defaultColWidth) {\n      sheetFormatPropertiesModel.defaultColWidth = properties.defaultColWidth;\n    }\n\n    xmlBuf.addText(xform.sheetFormatProperties.toXml(sheetFormatPropertiesModel));\n  }\n\n  _writeOpenWorksheet() {\n    xmlBuffer.reset();\n\n    xmlBuffer.addText('<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>');\n    xmlBuffer.addText(\n      '<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"' +\n        ' xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"' +\n        ' xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"' +\n        ' mc:Ignorable=\"x14ac\"' +\n        ' xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">'\n    );\n\n    this._writeSheetProperties(xmlBuffer, this.properties, this.pageSetup);\n\n    xmlBuffer.addText(xform.sheetViews.toXml(this.views));\n\n    this._writeSheetFormatProperties(xmlBuffer, this.properties);\n\n    this.stream.write(xmlBuffer);\n  }\n\n  _writeColumns() {\n    const cols = Column.toModel(this.columns);\n    if (cols) {\n      xform.columns.prepare(cols, {styles: this._workbook.styles});\n      this.stream.write(xform.columns.toXml(cols));\n    }\n  }\n\n  _writeOpenSheetData() {\n    this._write('<sheetData>');\n  }\n\n  _writeRow(row) {\n    if (!this.startedData) {\n      this._writeColumns();\n      this._writeOpenSheetData();\n      this.startedData = true;\n    }\n\n    if (row.hasValues || row.height) {\n      const {model} = row;\n      const options = {\n        styles: this._workbook.styles,\n        sharedStrings: this.useSharedStrings ? this._workbook.sharedStrings : undefined,\n        hyperlinks: this._sheetRelsWriter.hyperlinksProxy,\n        merges: this._merges,\n        formulae: this._formulae,\n        siFormulae: this._siFormulae,\n        comments: [],\n      };\n      xform.row.prepare(model, options);\n      this.stream.write(xform.row.toXml(model));\n\n      if (options.comments.length) {\n        this.hasComments = true;\n        this._sheetCommentsWriter.addComments(options.comments);\n      }\n    }\n  }\n\n  _writeCloseSheetData() {\n    this._write('</sheetData>');\n  }\n\n  _writeMergeCells() {\n    if (this._merges.length) {\n      xmlBuffer.reset();\n      xmlBuffer.addText(`<mergeCells count=\"${this._merges.length}\">`);\n      this._merges.forEach(merge => {\n        xmlBuffer.addText(`<mergeCell ref=\"${merge}\"/>`);\n      });\n      xmlBuffer.addText('</mergeCells>');\n\n      this.stream.write(xmlBuffer);\n    }\n  }\n\n  _writeHyperlinks() {\n    // eslint-disable-next-line no-underscore-dangle\n    this.stream.write(xform.hyperlinks.toXml(this._sheetRelsWriter._hyperlinks));\n  }\n\n  _writeConditionalFormatting() {\n    const options = {\n      styles: this._workbook.styles,\n    };\n    xform.conditionalFormattings.prepare(this.conditionalFormatting, options);\n    this.stream.write(xform.conditionalFormattings.toXml(this.conditionalFormatting));\n  }\n\n  _writeRowBreaks() {\n    this.stream.write(xform.rowBreaks.toXml(this.rowBreaks));\n  }\n\n  _writeDataValidations() {\n    this.stream.write(xform.dataValidations.toXml(this.dataValidations.model));\n  }\n\n  _writeSheetProtection() {\n    this.stream.write(xform.sheetProtection.toXml(this.sheetProtection));\n  }\n\n  _writePageMargins() {\n    this.stream.write(xform.pageMargins.toXml(this.pageSetup.margins));\n  }\n\n  _writePageSetup() {\n    this.stream.write(xform.pageSeteup.toXml(this.pageSetup));\n  }\n\n  _writeHeaderFooter() {\n    this.stream.write(xform.headerFooter.toXml(this.headerFooter));\n  }\n\n  _writeAutoFilter() {\n    this.stream.write(xform.autoFilter.toXml(this.autoFilter));\n  }\n\n  _writeBackground() {\n    if (this._background) {\n      if (this._background.imageId !== undefined) {\n        const image = this._workbook.getImage(this._background.imageId);\n        const pictureId = this._sheetRelsWriter.addMedia({\n          Target: `../media/${image.name}`,\n          Type: RelType.Image,\n        });\n\n        this._background = {\n          ...this._background,\n          rId: pictureId,\n        };\n      }\n      this.stream.write(xform.picture.toXml({rId: this._background.rId}));\n    }\n  }\n\n  _writeLegacyData() {\n    if (this.hasComments) {\n      xmlBuffer.reset();\n      xmlBuffer.addText(`<legacyDrawing r:id=\"${this._sheetCommentsWriter.vmlRelId}\"/>`);\n      this.stream.write(xmlBuffer);\n    }\n  }\n\n  _writeDimensions() {\n    // for some reason, Excel can't handle dimensions at the bottom of the file\n    // and we don't know the dimensions until the commit, so don't write them.\n    // this._write('<dimension ref=\"' + this._dimensions + '\"/>');\n  }\n\n  _writeCloseWorksheet() {\n    this._write('</worksheet>');\n  }\n}\n\nmodule.exports = WorksheetWriter;\n","/* eslint-disable max-classes-per-file */\nconst utils = require('../../utils/utils');\nconst RelType = require('../../xlsx/rel-type');\n\nclass HyperlinksProxy {\n  constructor(sheetRelsWriter) {\n    this.writer = sheetRelsWriter;\n  }\n\n  push(hyperlink) {\n    this.writer.addHyperlink(hyperlink);\n  }\n}\n\nclass SheetRelsWriter {\n  constructor(options) {\n    // in a workbook, each sheet will have a number\n    this.id = options.id;\n\n    // count of all relationships\n    this.count = 0;\n\n    // keep record of all hyperlinks\n    this._hyperlinks = [];\n\n    this._workbook = options.workbook;\n  }\n\n  get stream() {\n    if (!this._stream) {\n      // eslint-disable-next-line no-underscore-dangle\n      this._stream = this._workbook._openStream(`/xl/worksheets/_rels/sheet${this.id}.xml.rels`);\n    }\n    return this._stream;\n  }\n\n  get length() {\n    return this._hyperlinks.length;\n  }\n\n  each(fn) {\n    return this._hyperlinks.forEach(fn);\n  }\n\n  get hyperlinksProxy() {\n    return this._hyperlinksProxy || (this._hyperlinksProxy = new HyperlinksProxy(this));\n  }\n\n  addHyperlink(hyperlink) {\n    // Write to stream\n    const relationship = {\n      Target: hyperlink.target,\n      Type: RelType.Hyperlink,\n      TargetMode: 'External',\n    };\n    const rId = this._writeRelationship(relationship);\n\n    // store sheet stuff for later\n    this._hyperlinks.push({\n      rId,\n      address: hyperlink.address,\n    });\n  }\n\n  addMedia(media) {\n    return this._writeRelationship(media);\n  }\n\n  addRelationship(rel) {\n    return this._writeRelationship(rel);\n  }\n\n  commit() {\n    if (this.count) {\n      // write xml utro\n      this._writeClose();\n      // and close stream\n      this.stream.end();\n    }\n  }\n\n  // ================================================================================\n  _writeOpen() {\n    this.stream.write(\n      `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n       <Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">`\n    );\n  }\n\n  _writeRelationship(relationship) {\n    if (!this.count) {\n      this._writeOpen();\n    }\n\n    const rId = `rId${++this.count}`;\n\n    if (relationship.TargetMode) {\n      this.stream.write(\n        `<Relationship Id=\"${rId}\"` +\n          ` Type=\"${relationship.Type}\"` +\n          ` Target=\"${utils.xmlEncode(relationship.Target)}\"` +\n          ` TargetMode=\"${relationship.TargetMode}\"` +\n          '/>'\n      );\n    } else {\n      this.stream.write(\n        `<Relationship Id=\"${rId}\" Type=\"${relationship.Type}\" Target=\"${relationship.Target}\"/>`\n      );\n    }\n\n    return rId;\n  }\n\n  _writeClose() {\n    this.stream.write('</Relationships>');\n  }\n}\n\nmodule.exports = SheetRelsWriter;\n","const XmlStream = require('../../utils/xml-stream');\nconst RelType = require('../../xlsx/rel-type');\nconst colCache = require('../../utils/col-cache');\nconst CommentXform = require('../../xlsx/xform/comment/comment-xform');\nconst VmlShapeXform = require('../../xlsx/xform/comment/vml-shape-xform');\n\nclass SheetCommentsWriter {\n  constructor(worksheet, sheetRelsWriter, options) {\n    // in a workbook, each sheet will have a number\n    this.id = options.id;\n    this.count = 0;\n    this._worksheet = worksheet;\n    this._workbook = options.workbook;\n    this._sheetRelsWriter = sheetRelsWriter;\n  }\n\n  get commentsStream() {\n    if (!this._commentsStream) {\n      // eslint-disable-next-line no-underscore-dangle\n      this._commentsStream = this._workbook._openStream(`/xl/comments${this.id}.xml`);\n    }\n    return this._commentsStream;\n  }\n\n  get vmlStream() {\n    if (!this._vmlStream) {\n      // eslint-disable-next-line no-underscore-dangle\n      this._vmlStream = this._workbook._openStream(`xl/drawings/vmlDrawing${this.id}.vml`);\n    }\n    return this._vmlStream;\n  }\n\n  _addRelationships() {\n    const commentRel = {\n      Type: RelType.Comments,\n      Target: `../comments${this.id}.xml`,\n    };\n    this._sheetRelsWriter.addRelationship(commentRel);\n\n    const vmlDrawingRel = {\n      Type: RelType.VmlDrawing,\n      Target: `../drawings/vmlDrawing${this.id}.vml`,\n    };\n    this.vmlRelId = this._sheetRelsWriter.addRelationship(vmlDrawingRel);\n  }\n\n  _addCommentRefs() {\n    this._workbook.commentRefs.push({\n      commentName: `comments${this.id}`,\n      vmlDrawing: `vmlDrawing${this.id}`,\n    });\n  }\n\n  _writeOpen() {\n    this.commentsStream.write(\n      '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n        '<comments xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">' +\n        '<authors><author>Author</author></authors>' +\n        '<commentList>'\n    );\n    this.vmlStream.write(\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n        '<xml xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\">' +\n        '<o:shapelayout v:ext=\"edit\">' +\n        '<o:idmap v:ext=\"edit\" data=\"1\" />' +\n        '</o:shapelayout>' +\n        '<v:shapetype id=\"_x0000_t202\" coordsize=\"21600,21600\" o:spt=\"202\" path=\"m,l,21600r21600,l21600,xe\">' +\n        '<v:stroke joinstyle=\"miter\" />' +\n        '<v:path gradientshapeok=\"t\" o:connecttype=\"rect\" />' +\n        '</v:shapetype>'\n    );\n  }\n\n  _writeComment(comment, index) {\n    const commentXform = new CommentXform();\n    const commentsXmlStream = new XmlStream();\n    commentXform.render(commentsXmlStream, comment);\n    this.commentsStream.write(commentsXmlStream.xml);\n\n    const vmlShapeXform = new VmlShapeXform();\n    const vmlXmlStream = new XmlStream();\n    vmlShapeXform.render(vmlXmlStream, comment, index);\n    this.vmlStream.write(vmlXmlStream.xml);\n  }\n\n  _writeClose() {\n    this.commentsStream.write('</commentList></comments>');\n    this.vmlStream.write('</xml>');\n  }\n\n  addComments(comments) {\n    if (comments && comments.length) {\n      if (!this.startedData) {\n        this._worksheet.comments = [];\n        this._writeOpen();\n        this._addRelationships();\n        this._addCommentRefs();\n        this.startedData = true;\n      }\n\n      comments.forEach(item => {\n        item.refAddress = colCache.decodeAddress(item.ref);\n      });\n\n      comments.forEach(comment => {\n        this._writeComment(comment, this.count);\n        this.count += 1;\n      });\n    }\n  }\n\n  commit() {\n    if (this.count) {\n      this._writeClose();\n      this.commentsStream.end();\n      this.vmlStream.end();\n    }\n  }\n}\n\nmodule.exports = SheetCommentsWriter;\n","const fs = require('fs');\nconst {EventEmitter} = require('events');\nconst {PassThrough, Readable} = require('readable-stream');\nconst nodeStream = require('stream');\nconst unzip = require('unzipper');\nconst tmp = require('tmp');\nconst iterateStream = require('../../utils/iterate-stream');\nconst parseSax = require('../../utils/parse-sax');\n\nconst StyleManager = require('../../xlsx/xform/style/styles-xform');\nconst WorkbookXform = require('../../xlsx/xform/book/workbook-xform');\nconst RelationshipsXform = require('../../xlsx/xform/core/relationships-xform');\n\nconst WorksheetReader = require('./worksheet-reader');\nconst HyperlinkReader = require('./hyperlink-reader');\n\ntmp.setGracefulCleanup();\n\nclass WorkbookReader extends EventEmitter {\n  constructor(input, options = {}) {\n    super();\n\n    this.input = input;\n\n    this.options = {\n      worksheets: 'emit',\n      sharedStrings: 'cache',\n      hyperlinks: 'ignore',\n      styles: 'ignore',\n      entries: 'ignore',\n      ...options,\n    };\n\n    this.styles = new StyleManager();\n    this.styles.init();\n  }\n\n  _getStream(input) {\n    if (input instanceof nodeStream.Readable || input instanceof Readable) {\n      return input;\n    }\n    if (typeof input === 'string') {\n      return fs.createReadStream(input);\n    }\n    throw new Error(`Could not recognise input: ${input}`);\n  }\n\n  async read(input, options) {\n    try {\n      for await (const {eventType, value} of this.parse(input, options)) {\n        switch (eventType) {\n          case 'shared-strings':\n            this.emit(eventType, value);\n            break;\n          case 'worksheet':\n            this.emit(eventType, value);\n            await value.read();\n            break;\n          case 'hyperlinks':\n            this.emit(eventType, value);\n            break;\n        }\n      }\n      this.emit('end');\n      this.emit('finished');\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const {eventType, value} of this.parse()) {\n      if (eventType === 'worksheet') {\n        yield value;\n      }\n    }\n  }\n\n  async *parse(input, options) {\n    if (options) this.options = options;\n    const stream = (this.stream = this._getStream(input || this.input));\n    const zip = unzip.Parse({forceStream: true});\n    stream.pipe(zip);\n\n    // worksheets, deferred for parsing after shared strings reading\n    const waitingWorkSheets = [];\n\n    for await (const entry of iterateStream(zip)) {\n      let match;\n      let sheetNo;\n      switch (entry.path) {\n        case '_rels/.rels':\n          break;\n        case 'xl/_rels/workbook.xml.rels':\n          await this._parseRels(entry);\n          break;\n        case 'xl/workbook.xml':\n          await this._parseWorkbook(entry);\n          break;\n        case 'xl/sharedStrings.xml':\n          yield* this._parseSharedStrings(entry);\n          break;\n        case 'xl/styles.xml':\n          await this._parseStyles(entry);\n          break;\n        default:\n          if (entry.path.match(/xl\\/worksheets\\/sheet\\d+[.]xml/)) {\n            match = entry.path.match(/xl\\/worksheets\\/sheet(\\d+)[.]xml/);\n            sheetNo = match[1];\n            if (this.sharedStrings && this.workbookRels) {\n              yield* this._parseWorksheet(iterateStream(entry), sheetNo);\n            } else {\n              // create temp file for each worksheet\n              await new Promise((resolve, reject) => {\n                tmp.file((err, path, fd, tempFileCleanupCallback) => {\n                  if (err) {\n                    return reject(err);\n                  }\n                  waitingWorkSheets.push({sheetNo, path, tempFileCleanupCallback});\n\n                  const tempStream = fs.createWriteStream(path);\n                  tempStream.on('error', reject);\n                  entry.pipe(tempStream);\n                  return tempStream.on('finish', () => {\n                    return resolve();\n                  });\n                });\n              });\n            }\n          } else if (entry.path.match(/xl\\/worksheets\\/_rels\\/sheet\\d+[.]xml.rels/)) {\n            match = entry.path.match(/xl\\/worksheets\\/_rels\\/sheet(\\d+)[.]xml.rels/);\n            sheetNo = match[1];\n            yield* this._parseHyperlinks(iterateStream(entry), sheetNo);\n          }\n          break;\n      }\n      entry.autodrain();\n    }\n\n    for (const {sheetNo, path, tempFileCleanupCallback} of waitingWorkSheets) {\n      let fileStream = fs.createReadStream(path);\n      // TODO: Remove once node v8 is deprecated\n      // Detect and upgrade old fileStreams\n      if (!fileStream[Symbol.asyncIterator]) {\n        fileStream = fileStream.pipe(new PassThrough());\n      }\n      yield* this._parseWorksheet(fileStream, sheetNo);\n      tempFileCleanupCallback();\n    }\n  }\n\n  _emitEntry(payload) {\n    if (this.options.entries === 'emit') {\n      this.emit('entry', payload);\n    }\n  }\n\n  async _parseRels(entry) {\n    const xform = new RelationshipsXform();\n    this.workbookRels = await xform.parseStream(iterateStream(entry));\n  }\n\n  async _parseWorkbook(entry) {\n    this._emitEntry({type: 'workbook'});\n\n    const workbook = new WorkbookXform();\n    await workbook.parseStream(iterateStream(entry));\n\n    this.properties = workbook.map.workbookPr;\n    this.model = workbook.model;\n  }\n\n  async *_parseSharedStrings(entry) {\n    this._emitEntry({type: 'shared-strings'});\n    switch (this.options.sharedStrings) {\n      case 'cache':\n        this.sharedStrings = [];\n        break;\n      case 'emit':\n        break;\n      default:\n        return;\n    }\n\n    let text = null;\n    let richText = [];\n    let index = 0;\n    let font = null;\n    for await (const events of parseSax(iterateStream(entry))) {\n      for (const {eventType, value} of events) {\n        if (eventType === 'opentag') {\n          const node = value;\n          switch (node.name) {\n            case 'b':\n              font = font || {};\n              font.bold = true;\n              break;\n            case 'charset':\n              font = font || {};\n              font.charset = parseInt(node.attributes.charset, 10);\n              break;\n            case 'color':\n              font = font || {};\n              font.color = {};\n              if (node.attributes.rgb) {\n                font.color.argb = node.attributes.argb;\n              }\n              if (node.attributes.val) {\n                font.color.argb = node.attributes.val;\n              }\n              if (node.attributes.theme) {\n                font.color.theme = node.attributes.theme;\n              }\n              break;\n            case 'family':\n              font = font || {};\n              font.family = parseInt(node.attributes.val, 10);\n              break;\n            case 'i':\n              font = font || {};\n              font.italic = true;\n              break;\n            case 'outline':\n              font = font || {};\n              font.outline = true;\n              break;\n            case 'rFont':\n              font = font || {};\n              font.name = node.value;\n              break;\n            case 'si':\n              font = null;\n              richText = [];\n              text = null;\n              break;\n            case 'sz':\n              font = font || {};\n              font.size = parseInt(node.attributes.val, 10);\n              break;\n            case 'strike':\n              break;\n            case 't':\n              text = null;\n              break;\n            case 'u':\n              font = font || {};\n              font.underline = true;\n              break;\n            case 'vertAlign':\n              font = font || {};\n              font.vertAlign = node.attributes.val;\n              break;\n          }\n        } else if (eventType === 'text') {\n          text = text ? text + value : value;\n        } else if (eventType === 'closetag') {\n          const node = value;\n          switch (node.name) {\n            case 'r':\n              richText.push({\n                font,\n                text,\n              });\n\n              font = null;\n              text = null;\n              break;\n            case 'si':\n              if (this.options.sharedStrings === 'cache') {\n                this.sharedStrings.push(richText.length ? {richText} : text);\n              } else if (this.options.sharedStrings === 'emit') {\n                yield {index: index++, text: richText.length ? {richText} : text};\n              }\n\n              richText = [];\n              font = null;\n              text = null;\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  async _parseStyles(entry) {\n    this._emitEntry({type: 'styles'});\n    if (this.options.styles === 'cache') {\n      this.styles = new StyleManager();\n      await this.styles.parseStream(iterateStream(entry));\n    }\n  }\n\n  *_parseWorksheet(iterator, sheetNo) {\n    this._emitEntry({type: 'worksheet', id: sheetNo});\n    const worksheetReader = new WorksheetReader({\n      workbook: this,\n      id: sheetNo,\n      iterator,\n      options: this.options,\n    });\n\n    const matchingRel = (this.workbookRels || []).find(rel => rel.Target === `worksheets/sheet${sheetNo}.xml`);\n    const matchingSheet = matchingRel && (this.model.sheets || []).find(sheet => sheet.rId === matchingRel.Id);\n    if (matchingSheet) {\n      worksheetReader.id = matchingSheet.id;\n      worksheetReader.name = matchingSheet.name;\n      worksheetReader.state = matchingSheet.state;\n    }\n    if (this.options.worksheets === 'emit') {\n      yield {eventType: 'worksheet', value: worksheetReader};\n    }\n  }\n\n  *_parseHyperlinks(iterator, sheetNo) {\n    this._emitEntry({type: 'hyperlinks', id: sheetNo});\n    const hyperlinksReader = new HyperlinkReader({\n      workbook: this,\n      id: sheetNo,\n      iterator,\n      options: this.options,\n    });\n    if (this.options.hyperlinks === 'emit') {\n      yield {eventType: 'hyperlinks', value: hyperlinksReader};\n    }\n  }\n}\n\n// for reference - these are the valid values for options\nWorkbookReader.Options = {\n  worksheets: ['emit', 'ignore'],\n  sharedStrings: ['cache', 'emit', 'ignore'],\n  hyperlinks: ['cache', 'emit', 'ignore'],\n  styles: ['cache', 'ignore'],\n  entries: ['emit', 'ignore'],\n};\n\nmodule.exports = WorkbookReader;\n","module.exports = async function* iterateStream(stream) {\n  const contents = [];\n  stream.on('data', data => contents.push(data));\n\n  let resolveStreamEndedPromise;\n  const streamEndedPromise = new Promise(resolve => (resolveStreamEndedPromise = resolve));\n\n  let ended = false;\n  stream.on('end', () => {\n    ended = true;\n    resolveStreamEndedPromise();\n  });\n\n  let error = false;\n  stream.on('error', err => {\n    error = err;\n    resolveStreamEndedPromise();\n  });\n\n  while (!ended || contents.length > 0) {\n    if (contents.length === 0) {\n      stream.resume();\n      // eslint-disable-next-line no-await-in-loop\n      await Promise.race([once(stream, 'data'), streamEndedPromise]);\n    } else {\n      stream.pause();\n      const data = contents.shift();\n      yield data;\n    }\n    if (error) throw error;\n  }\n  resolveStreamEndedPromise();\n};\n\nfunction once(eventEmitter, type) {\n  // TODO: Use require('events').once when node v10 is dropped\n  return new Promise(resolve => {\n    let fired = false;\n    const handler = () => {\n      if (!fired) {\n        fired = true;\n        eventEmitter.removeListener(type, handler);\n        resolve();\n      }\n    };\n    eventEmitter.addListener(type, handler);\n  });\n}\n","const {EventEmitter} = require('events');\nconst parseSax = require('../../utils/parse-sax');\n\nconst _ = require('../../utils/under-dash');\nconst utils = require('../../utils/utils');\nconst colCache = require('../../utils/col-cache');\nconst Dimensions = require('../../doc/range');\n\nconst Row = require('../../doc/row');\nconst Column = require('../../doc/column');\n\nclass WorksheetReader extends EventEmitter {\n  constructor({workbook, id, iterator, options}) {\n    super();\n\n    this.workbook = workbook;\n    this.id = id;\n    this.iterator = iterator;\n    this.options = options || {};\n\n    // and a name\n    this.name = `Sheet${this.id}`;\n\n    // column definitions\n    this._columns = null;\n    this._keys = {};\n\n    // keep a record of dimensions\n    this._dimensions = new Dimensions();\n  }\n\n  // destroy - not a valid operation for a streaming writer\n  // even though some streamers might be able to, it's a bad idea.\n  destroy() {\n    throw new Error('Invalid Operation: destroy');\n  }\n\n  // return the current dimensions of the writer\n  get dimensions() {\n    return this._dimensions;\n  }\n\n  // =========================================================================\n  // Columns\n\n  // get the current columns array.\n  get columns() {\n    return this._columns;\n  }\n\n  // get a single column by col number. If it doesn't exist, it and any gaps before it\n  // are created.\n  getColumn(c) {\n    if (typeof c === 'string') {\n      // if it matches a key'd column, return that\n      const col = this._keys[c];\n      if (col) {\n        return col;\n      }\n\n      // otherise, assume letter\n      c = colCache.l2n(c);\n    }\n    if (!this._columns) {\n      this._columns = [];\n    }\n    if (c > this._columns.length) {\n      let n = this._columns.length + 1;\n      while (n <= c) {\n        this._columns.push(new Column(this, n++));\n      }\n    }\n    return this._columns[c - 1];\n  }\n\n  getColumnKey(key) {\n    return this._keys[key];\n  }\n\n  setColumnKey(key, value) {\n    this._keys[key] = value;\n  }\n\n  deleteColumnKey(key) {\n    delete this._keys[key];\n  }\n\n  eachColumnKey(f) {\n    _.each(this._keys, f);\n  }\n\n  async read() {\n    try {\n      for await (const events of this.parse()) {\n        for (const {eventType, value} of events) {\n          this.emit(eventType, value);\n        }\n      }\n      this.emit('finished');\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const events of this.parse()) {\n      for (const {eventType, value} of events) {\n        if (eventType === 'row') {\n          yield value;\n        }\n      }\n    }\n  }\n\n  async *parse() {\n    const {iterator, options} = this;\n    let emitSheet = false;\n    let emitHyperlinks = false;\n    let hyperlinks = null;\n    switch (options.worksheets) {\n      case 'emit':\n        emitSheet = true;\n        break;\n      case 'prep':\n        break;\n      default:\n        break;\n    }\n    switch (options.hyperlinks) {\n      case 'emit':\n        emitHyperlinks = true;\n        break;\n      case 'cache':\n        this.hyperlinks = hyperlinks = {};\n        break;\n      default:\n        break;\n    }\n    if (!emitSheet && !emitHyperlinks && !hyperlinks) {\n      return;\n    }\n\n    // references\n    const {sharedStrings, styles, properties} = this.workbook;\n\n    // xml position\n    let inCols = false;\n    let inRows = false;\n    let inHyperlinks = false;\n\n    // parse state\n    let cols = null;\n    let row = null;\n    let c = null;\n    let current = null;\n    for await (const events of parseSax(iterator)) {\n      const worksheetEvents = [];\n      for (const {eventType, value} of events) {\n        if (eventType === 'opentag') {\n          const node = value;\n          if (emitSheet) {\n            switch (node.name) {\n              case 'cols':\n                inCols = true;\n                cols = [];\n                break;\n              case 'sheetData':\n                inRows = true;\n                break;\n\n              case 'col':\n                if (inCols) {\n                  cols.push({\n                    min: parseInt(node.attributes.min, 10),\n                    max: parseInt(node.attributes.max, 10),\n                    width: parseFloat(node.attributes.width),\n                    styleId: parseInt(node.attributes.style || '0', 10),\n                  });\n                }\n                break;\n\n              case 'row':\n                if (inRows) {\n                  const r = parseInt(node.attributes.r, 10);\n                  row = new Row(this, r);\n                  if (node.attributes.ht) {\n                    row.height = parseFloat(node.attributes.ht);\n                  }\n                  if (node.attributes.s) {\n                    const styleId = parseInt(node.attributes.s, 10);\n                    const style = styles.getStyleModel(styleId);\n                    if (style) {\n                      row.style = style;\n                    }\n                  }\n                }\n                break;\n              case 'c':\n                if (row) {\n                  c = {\n                    ref: node.attributes.r,\n                    s: parseInt(node.attributes.s, 10),\n                    t: node.attributes.t,\n                  };\n                }\n                break;\n              case 'f':\n                if (c) {\n                  current = c.f = {text: ''};\n                }\n                break;\n              case 'v':\n                if (c) {\n                  current = c.v = {text: ''};\n                }\n                break;\n              case 'is':\n              case 't':\n                if (c) {\n                  current = c.v = {text: ''};\n                }\n                break;\n              case 'mergeCell':\n                break;\n              default:\n                break;\n            }\n          }\n\n          // =================================================================\n          //\n          if (emitHyperlinks || hyperlinks) {\n            switch (node.name) {\n              case 'hyperlinks':\n                inHyperlinks = true;\n                break;\n              case 'hyperlink':\n                if (inHyperlinks) {\n                  const hyperlink = {\n                    ref: node.attributes.ref,\n                    rId: node.attributes['r:id'],\n                  };\n                  if (emitHyperlinks) {\n                    worksheetEvents.push({eventType: 'hyperlink', value: hyperlink});\n                  } else {\n                    hyperlinks[hyperlink.ref] = hyperlink;\n                  }\n                }\n                break;\n              default:\n                break;\n            }\n          }\n        } else if (eventType === 'text') {\n          // only text data is for sheet values\n          if (emitSheet) {\n            if (current) {\n              current.text += value;\n            }\n          }\n        } else if (eventType === 'closetag') {\n          const node = value;\n          if (emitSheet) {\n            switch (node.name) {\n              case 'cols':\n                inCols = false;\n                this._columns = Column.fromModel(cols);\n                break;\n              case 'sheetData':\n                inRows = false;\n                break;\n\n              case 'row':\n                this._dimensions.expandRow(row);\n                worksheetEvents.push({eventType: 'row', value: row});\n                row = null;\n                break;\n\n              case 'c':\n                if (row && c) {\n                  const address = colCache.decodeAddress(c.ref);\n                  const cell = row.getCell(address.col);\n                  if (c.s) {\n                    const style = styles.getStyleModel(c.s);\n                    if (style) {\n                      cell.style = style;\n                    }\n                  }\n\n                  if (c.f) {\n                    const cellValue = {\n                      formula: c.f.text,\n                    };\n                    if (c.v) {\n                      if (c.t === 'str') {\n                        cellValue.result = utils.xmlDecode(c.v.text);\n                      } else {\n                        cellValue.result = parseFloat(c.v.text);\n                      }\n                    }\n                    cell.value = cellValue;\n                  } else if (c.v) {\n                    switch (c.t) {\n                      case 's': {\n                        const index = parseInt(c.v.text, 10);\n                        if (sharedStrings) {\n                          cell.value = sharedStrings[index];\n                        } else {\n                          cell.value = {\n                            sharedString: index,\n                          };\n                        }\n                        break;\n                      }\n\n                      case 'inlineStr':\n                      case 'str':\n                        cell.value = utils.xmlDecode(c.v.text);\n                        break;\n\n                      case 'e':\n                        cell.value = {error: c.v.text};\n                        break;\n\n                      case 'b':\n                        cell.value = parseInt(c.v.text, 10) !== 0;\n                        break;\n\n                      default:\n                        if (utils.isDateFmt(cell.numFmt)) {\n                          cell.value = utils.excelToDate(\n                            parseFloat(c.v.text),\n                            properties.model && properties.model.date1904\n                          );\n                        } else {\n                          cell.value = parseFloat(c.v.text);\n                        }\n                        break;\n                    }\n                  }\n                  if (hyperlinks) {\n                    const hyperlink = hyperlinks[c.ref];\n                    if (hyperlink) {\n                      cell.text = cell.value;\n                      cell.value = undefined;\n                      cell.hyperlink = hyperlink;\n                    }\n                  }\n                  c = null;\n                }\n                break;\n              default:\n                break;\n            }\n          }\n          if (emitHyperlinks || hyperlinks) {\n            switch (node.name) {\n              case 'hyperlinks':\n                inHyperlinks = false;\n                break;\n              default:\n                break;\n            }\n          }\n        }\n      }\n      if (worksheetEvents.length > 0) {\n        yield worksheetEvents;\n      }\n    }\n  }\n}\n\nmodule.exports = WorksheetReader;\n","const {EventEmitter} = require('events');\nconst parseSax = require('../../utils/parse-sax');\n\nconst Enums = require('../../doc/enums');\nconst RelType = require('../../xlsx/rel-type');\n\nclass HyperlinkReader extends EventEmitter {\n  constructor({workbook, id, iterator, options}) {\n    super();\n\n    this.workbook = workbook;\n    this.id = id;\n    this.iterator = iterator;\n    this.options = options;\n  }\n\n  get count() {\n    return (this.hyperlinks && this.hyperlinks.length) || 0;\n  }\n\n  each(fn) {\n    return this.hyperlinks.forEach(fn);\n  }\n\n  async read() {\n    const {iterator, options} = this;\n    let emitHyperlinks = false;\n    let hyperlinks = null;\n    switch (options.hyperlinks) {\n      case 'emit':\n        emitHyperlinks = true;\n        break;\n      case 'cache':\n        this.hyperlinks = hyperlinks = {};\n        break;\n      default:\n        break;\n    }\n\n    if (!emitHyperlinks && !hyperlinks) {\n      this.emit('finished');\n      return;\n    }\n\n    try {\n      for await (const events of parseSax(iterator)) {\n        for (const {eventType, value} of events) {\n          if (eventType === 'opentag') {\n            const node = value;\n            if (node.name === 'Relationship') {\n              const rId = node.attributes.Id;\n              switch (node.attributes.Type) {\n                case RelType.Hyperlink:\n                  {\n                    const relationship = {\n                      type: Enums.RelationshipType.Styles,\n                      rId,\n                      target: node.attributes.Target,\n                      targetMode: node.attributes.TargetMode,\n                    };\n                    if (emitHyperlinks) {\n                      this.emit('hyperlink', relationship);\n                    } else {\n                      hyperlinks[relationship.rId] = relationship;\n                    }\n                  }\n                  break;\n\n                default:\n                  break;\n              }\n            }\n          }\n        }\n      }\n      this.emit('finished');\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n}\n\nmodule.exports = HyperlinkReader;\n"]}